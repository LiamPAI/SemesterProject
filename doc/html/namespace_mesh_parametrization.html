<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Semester Project Liam Curtis: MeshParametrization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Semester Project Liam Curtis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">MeshParametrization Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for mesh parametrization operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f9448824e6524bc895d8bbaec536c19" id="r_a2f9448824e6524bc895d8bbaec536c19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f9448824e6524bc895d8bbaec536c19">checkVectorLengths</a> (const Eigen::MatrixXd &amp;vectors)</td></tr>
<tr class="memdesc:a2f9448824e6524bc895d8bbaec536c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates vector lengths in direction matrix.  <br /></td></tr>
<tr class="separator:a2f9448824e6524bc895d8bbaec536c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af570cae2ac6a402af20d6fb7faeecec1" id="r_af570cae2ac6a402af20d6fb7faeecec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af570cae2ac6a402af20d6fb7faeecec1">normalizeVectors</a> (Eigen::MatrixXd &amp;vectors)</td></tr>
<tr class="memdesc:af570cae2ac6a402af20d6fb7faeecec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes direction vectors to unit length.  <br /></td></tr>
<tr class="separator:af570cae2ac6a402af20d6fb7faeecec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2be81d0d3a5153798423ce3a58e3a1" id="r_a7e2be81d0d3a5153798423ce3a58e3a1"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e2be81d0d3a5153798423ce3a58e3a1">polynomialPoints</a> (<a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;param)</td></tr>
<tr class="memdesc:a7e2be81d0d3a5153798423ce3a58e3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates polynomial points from parametrization.  <br /></td></tr>
<tr class="separator:a7e2be81d0d3a5153798423ce3a58e3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352bc7821092c4f9a53dfeb16e6c02be" id="r_a352bc7821092c4f9a53dfeb16e6c02be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a352bc7821092c4f9a53dfeb16e6c02be">angleVectors</a> (<a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;param)</td></tr>
<tr class="memdesc:a352bc7821092c4f9a53dfeb16e6c02be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks angles between branch vectors.  <br /></td></tr>
<tr class="separator:a352bc7821092c4f9a53dfeb16e6c02be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007b5963525a05190de9860a14bfe526" id="r_a007b5963525a05190de9860a14bfe526"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a007b5963525a05190de9860a14bfe526">intersectionVectors</a> (<a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;param)</td></tr>
<tr class="memdesc:a007b5963525a05190de9860a14bfe526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for intersections between vectors.  <br /></td></tr>
<tr class="separator:a007b5963525a05190de9860a14bfe526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae691f88d5d85e37e64babb2ed0a7a07e" id="r_ae691f88d5d85e37e64babb2ed0a7a07e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae691f88d5d85e37e64babb2ed0a7a07e">intersectionBranches</a> (const Eigen::MatrixXd &amp;poly_points_1, const Eigen::MatrixXd &amp;poly_points_2)</td></tr>
<tr class="memdesc:ae691f88d5d85e37e64babb2ed0a7a07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for intersections between nearby branches.  <br /></td></tr>
<tr class="separator:ae691f88d5d85e37e64babb2ed0a7a07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f77b882649bfb2df66b607181e28e5" id="r_af7f77b882649bfb2df66b607181e28e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7f77b882649bfb2df66b607181e28e5">selfIntersection</a> (const Eigen::MatrixXd &amp;poly_points)</td></tr>
<tr class="memdesc:af7f77b882649bfb2df66b607181e28e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for self-intersections in branch.  <br /></td></tr>
<tr class="separator:af7f77b882649bfb2df66b607181e28e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f7f735900d22b64eb9024139a1f18e" id="r_a07f7f735900d22b64eb9024139a1f18e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Eigen::VectorXi &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07f7f735900d22b64eb9024139a1f18e">connectionPoints</a> (<a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;multiBranch)</td></tr>
<tr class="memdesc:a07f7f735900d22b64eb9024139a1f18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies connection points in multi-branch parametrization.  <br /></td></tr>
<tr class="separator:a07f7f735900d22b64eb9024139a1f18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f329e14a41574a8b4a5a8eafd152e2" id="r_a04f329e14a41574a8b4a5a8eafd152e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04f329e14a41574a8b4a5a8eafd152e2">meshParamValidator</a> (<a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;param)</td></tr>
<tr class="memdesc:a04f329e14a41574a8b4a5a8eafd152e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates complete mesh parametrization.  <br /></td></tr>
<tr class="separator:a04f329e14a41574a8b4a5a8eafd152e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30780085192c00fff5bcb5e554dccff5" id="r_a30780085192c00fff5bcb5e554dccff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30780085192c00fff5bcb5e554dccff5">pointToParametrization</a> (const Eigen::MatrixXd &amp;poly_points)</td></tr>
<tr class="memdesc:a30780085192c00fff5bcb5e554dccff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts polynomial points to mesh parametrization.  <br /></td></tr>
<tr class="separator:a30780085192c00fff5bcb5e554dccff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093eaca69176a6103201e1fc48f2d94d" id="r_a093eaca69176a6103201e1fc48f2d94d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a093eaca69176a6103201e1fc48f2d94d">generateMesh</a> (<a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;parametrization, const std::string &amp;mesh_name, double mesh_size, int order)</td></tr>
<tr class="memdesc:a093eaca69176a6103201e1fc48f2d94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates mesh from a <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> object.  <br /></td></tr>
<tr class="separator:a093eaca69176a6103201e1fc48f2d94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cf52833024ff2f310f53e68bf4ab36" id="r_ae7cf52833024ff2f310f53e68bf4ab36"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7cf52833024ff2f310f53e68bf4ab36">displacementBC</a> (const Eigen::MatrixXd &amp;branch, const Eigen::MatrixXd &amp;displacement, const Eigen::Vector2d &amp;point)</td></tr>
<tr class="memdesc:ae7cf52833024ff2f310f53e68bf4ab36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates displacement boundary condition at point.  <br /></td></tr>
<tr class="separator:ae7cf52833024ff2f310f53e68bf4ab36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd41b6a7ce9251b59725b4d6a93f631f" id="r_acd41b6a7ce9251b59725b4d6a93f631f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd41b6a7ce9251b59725b4d6a93f631f">fixFlaggedSolutionComponentsLE</a> (std::vector&lt; std::pair&lt; bool, Eigen::Vector2d &gt; &gt; &amp;select_vals, lf::assemble::COOMatrix&lt; double &gt; &amp;A, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;phi)</td></tr>
<tr class="memdesc:acd41b6a7ce9251b59725b4d6a93f631f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes matrix to format 2.7.6.15 of NUMPDE lecture document.  <br /></td></tr>
<tr class="separator:acd41b6a7ce9251b59725b4d6a93f631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b958aa901405b1ce4db0bcfd7b8d6d" id="r_a40b958aa901405b1ce4db0bcfd7b8d6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40b958aa901405b1ce4db0bcfd7b8d6d">elasticRegion</a> (const Eigen::MatrixXd &amp;stresses, double yieldStrength)</td></tr>
<tr class="memdesc:a40b958aa901405b1ce4db0bcfd7b8d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if stress state is within elastic region of the material.  <br /></td></tr>
<tr class="separator:a40b958aa901405b1ce4db0bcfd7b8d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ca202a06e1981f1b7f2ff7a6e532e3" id="r_a22ca202a06e1981f1b7f2ff7a6e532e3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22ca202a06e1981f1b7f2ff7a6e532e3">displacementEnergy</a> (<a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;param, Eigen::MatrixXd &amp;displacement, const <a class="el" href="structcalculation_params.html">calculationParams</a> &amp;calc_params)</td></tr>
<tr class="memdesc:a22ca202a06e1981f1b7f2ff7a6e532e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates displacement energy and checks if in the linear elastic region.  <br /></td></tr>
<tr class="separator:a22ca202a06e1981f1b7f2ff7a6e532e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for mesh parametrization operations. </p>
<p>Provides functionality for mesh generation, validation, and analysis </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a352bc7821092c4f9a53dfeb16e6c02be" name="a352bc7821092c4f9a53dfeb16e6c02be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352bc7821092c4f9a53dfeb16e6c02be">&#9670;&#160;</a></span>angleVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshParametrization::angleVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks angles between branch vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Mesh parametrization data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all angles are under 45 degrees </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  105</span>                                                                     {</div>
<div class="line"><span class="lineno">  106</span> </div>
<div class="line"><span class="lineno">  107</span>    <span class="comment">// Obtain the polynomial points for the parametrization, note that this normalizes the vectors already</span></div>
<div class="line"><span class="lineno">  108</span>    Eigen::MatrixXd poly_points = <a class="code hl_function" href="#a7e2be81d0d3a5153798423ce3a58e3a1">polynomialPoints</a>(param);</div>
<div class="line"><span class="lineno">  109</span> </div>
<div class="line"><span class="lineno">  110</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> branch = 0; branch &lt; param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; ++branch) {</div>
<div class="line"><span class="lineno">  111</span> </div>
<div class="line"><span class="lineno">  112</span>        <span class="comment">// For each part of the polynomial, we initialize straight lines from the points, and we assert that</span></div>
<div class="line"><span class="lineno">  113</span>        <span class="comment">// the angle is below 45 degrees</span></div>
<div class="line"><span class="lineno">  114</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; i++)</div>
<div class="line"><span class="lineno">  115</span>        {</div>
<div class="line"><span class="lineno">  116</span>            <span class="comment">// Initialize the lines, which will both come using the same terminal</span></div>
<div class="line"><span class="lineno">  117</span>            Eigen::Vector2d a = poly_points.block&lt;2, 1&gt;(4 * branch, i);</div>
<div class="line"><span class="lineno">  118</span>            Eigen::Vector2d b = poly_points.block&lt;2, 1&gt;(4 * branch + 2, i);</div>
<div class="line"><span class="lineno">  119</span>            Eigen::Vector2d c = poly_points.block&lt;2, 1&gt;(4 * branch, i + 1);</div>
<div class="line"><span class="lineno">  120</span>            Eigen::Vector2d d = poly_points.block&lt;2, 1&gt;(4 * branch + 2, i + 1);</div>
<div class="line"><span class="lineno">  121</span> </div>
<div class="line"><span class="lineno">  122</span>            <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> poly_lines (a, b, c, d);</div>
<div class="line"><span class="lineno">  123</span> </div>
<div class="line"><span class="lineno">  124</span>            <span class="comment">// If the angle is too large, we return false</span></div>
<div class="line"><span class="lineno">  125</span>            <span class="keywordflow">if</span> (poly_lines.angleBetweenLines() &gt; 45.001) {</div>
<div class="line"><span class="lineno">  126</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  127</span>            }</div>
<div class="line"><span class="lineno">  128</span>        }</div>
<div class="line"><span class="lineno">  129</span>    }</div>
<div class="line"><span class="lineno">  130</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  131</span>}</div>
<div class="ttc" id="aclass_line_mapping_html"><div class="ttname"><a href="class_line_mapping.html">LineMapping</a></div><div class="ttdoc">Class for mapping points between two line segments.</div><div class="ttdef"><b>Definition</b> line_mapping.h:20</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a7e2be81d0d3a5153798423ce3a58e3a1"><div class="ttname"><a href="#a7e2be81d0d3a5153798423ce3a58e3a1">MeshParametrization::polynomialPoints</a></div><div class="ttdeci">Eigen::MatrixXd polynomialPoints(MeshParametrizationData &amp;param)</div><div class="ttdoc">Generates polynomial points from parametrization.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:53</div></div>
<div class="ttc" id="astruct_mesh_parametrization_data_html_adda268017d91178d76eccae27c55ab01"><div class="ttname"><a href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">MeshParametrizationData::numBranches</a></div><div class="ttdeci">int numBranches</div><div class="ttdoc">Number of branches in parametrization.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:73</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f9448824e6524bc895d8bbaec536c19" name="a2f9448824e6524bc895d8bbaec536c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9448824e6524bc895d8bbaec536c19">&#9670;&#160;</a></span>checkVectorLengths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshParametrization::checkVectorLengths </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vectors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates vector lengths in direction matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectors</td><td>Matrix of direction vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all vectors have non-zero lengths </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   12</span>                                                                        {</div>
<div class="line"><span class="lineno">   13</span> </div>
<div class="line"><span class="lineno">   14</span>    <span class="keywordflow">if</span> (vectors.rows() % 2 != 0 or vectors.cols() != 3){</div>
<div class="line"><span class="lineno">   15</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   16</span>    }</div>
<div class="line"><span class="lineno">   17</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vectors.rows() / 2; ++i) {</div>
<div class="line"><span class="lineno">   18</span>        <span class="keyword">auto</span> norms = vectors.block&lt;2, 3&gt;(i * 2, 0).colwise().norm();</div>
<div class="line"><span class="lineno">   19</span> </div>
<div class="line"><span class="lineno">   20</span>        <span class="keywordflow">if</span> (!(norms.array() &gt; 1e-7).all()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   21</span> </div>
<div class="line"><span class="lineno">   22</span>    }</div>
<div class="line"><span class="lineno">   23</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   24</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a07f7f735900d22b64eb9024139a1f18e" name="a07f7f735900d22b64eb9024139a1f18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f7f735900d22b64eb9024139a1f18e">&#9670;&#160;</a></span>connectionPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Eigen::VectorXi &gt; MeshParametrization::connectionPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>multiBranch</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies connection points in multi-branch parametrization. </p>
<p>As mentioned in the local ordering of <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a>, these connection points must be found in the first columns of the relevant fields </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiBranch</td><td>Multi-branch parametrization data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optional vector of connection indices, std::nullopt if they aren't found </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  304</span>                                                                                                     {</div>
<div class="line"><span class="lineno">  305</span> </div>
<div class="line"><span class="lineno">  306</span>    <span class="comment">// If this is not a multi-branch parametrization, it is useless to call connectionPoints</span></div>
<div class="line"><span class="lineno">  307</span>    <span class="keywordflow">if</span> (multiBranch.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a> &lt; 3){</div>
<div class="line"><span class="lineno">  308</span>        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line"><span class="lineno">  309</span>    }</div>
<div class="line"><span class="lineno">  310</span> </div>
<div class="line"><span class="lineno">  311</span>    <span class="comment">// Find the matrix of polynomial points and initialize the matrix of connections</span></div>
<div class="line"><span class="lineno">  312</span>    Eigen::MatrixXd poly_points = polynomialPoints(multiBranch);</div>
<div class="line"><span class="lineno">  313</span>    Eigen::VectorXi connections = -1 * Eigen::VectorXi::Ones(multiBranch.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a> * 2);</div>
<div class="line"><span class="lineno">  314</span>    <span class="keywordtype">int</span> current = 0;</div>
<div class="line"><span class="lineno">  315</span> </div>
<div class="line"><span class="lineno">  316</span>    <span class="comment">// There will be a number of connections equal to the number of branches</span></div>
<div class="line"><span class="lineno">  317</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> connection = 0; connection &lt; multiBranch.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; connection++) {</div>
<div class="line"><span class="lineno">  318</span>        <span class="keywordtype">bool</span> match = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>        <span class="comment">// Iterate through all branches to find a possible match</span></div>
<div class="line"><span class="lineno">  321</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> branch = 0; branch &lt; multiBranch.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; branch++) {</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span>            <span class="comment">// If we are looking at our current branch, we skip over it</span></div>
<div class="line"><span class="lineno">  324</span>            <span class="keywordflow">if</span> (current / 2 == branch) {</div>
<div class="line"><span class="lineno">  325</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  326</span>            }</div>
<div class="line"><span class="lineno">  327</span>            <span class="keywordtype">double</span> check_1 = (poly_points.block&lt;2, 1&gt;(branch * 4, 0) -</div>
<div class="line"><span class="lineno">  328</span>                poly_points.block&lt;2, 1&gt;(current * 2, 0)).norm();</div>
<div class="line"><span class="lineno">  329</span>            <span class="keywordtype">double</span> check_2 = (poly_points.block&lt;2, 1&gt;(branch * 4 + 2, 0) -</div>
<div class="line"><span class="lineno">  330</span>                            poly_points.block&lt;2, 1&gt;(current * 2, 0)).norm();</div>
<div class="line"><span class="lineno">  331</span> </div>
<div class="line"><span class="lineno">  332</span>            <span class="comment">// If one of these points match, &quot;current&quot; is switched to the next point we want to find a match for and</span></div>
<div class="line"><span class="lineno">  333</span>            <span class="comment">// we update our connections matrix</span></div>
<div class="line"><span class="lineno">  334</span>            <span class="keywordflow">if</span> (check_1 &lt; 1e-7){</div>
<div class="line"><span class="lineno">  335</span>                match = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  336</span>                <span class="keywordflow">if</span> (connections[current] == -1 and connections[branch * 2] == -1) {</div>
<div class="line"><span class="lineno">  337</span>                    connections[current] = branch * 2;</div>
<div class="line"><span class="lineno">  338</span>                    connections[branch * 2] = current;</div>
<div class="line"><span class="lineno">  339</span>                }</div>
<div class="line"><span class="lineno">  340</span>                <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  341</span>                    match = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  342</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  343</span>                }</div>
<div class="line"><span class="lineno">  344</span>                current = branch * 2 + 1;</div>
<div class="line"><span class="lineno">  345</span>            }</div>
<div class="line"><span class="lineno">  346</span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (check_2 &lt; 1e-7) {</div>
<div class="line"><span class="lineno">  347</span>                match = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  348</span>                <span class="keywordflow">if</span> (connections[current] == -1 and connections[branch * 2 + 1] == -1) {</div>
<div class="line"><span class="lineno">  349</span>                    connections[current] = branch * 2 + 1;</div>
<div class="line"><span class="lineno">  350</span>                    connections[branch * 2 + 1] = current;</div>
<div class="line"><span class="lineno">  351</span>                }</div>
<div class="line"><span class="lineno">  352</span>                <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  353</span>                    match = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  354</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  355</span>                }</div>
<div class="line"><span class="lineno">  356</span>                current = branch * 2;</div>
<div class="line"><span class="lineno">  357</span>            }</div>
<div class="line"><span class="lineno">  358</span> </div>
<div class="line"><span class="lineno">  359</span>            <span class="comment">// Since we found a match, we can exit this inner loop</span></div>
<div class="line"><span class="lineno">  360</span>            <span class="keywordflow">if</span> (match) {</div>
<div class="line"><span class="lineno">  361</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  362</span>            }</div>
<div class="line"><span class="lineno">  363</span>        }</div>
<div class="line"><span class="lineno">  364</span>        <span class="comment">// If we haven&#39;t found a match, then the parametrization is incorrect, so we return &quot;false&quot;</span></div>
<div class="line"><span class="lineno">  365</span>        <span class="keywordflow">if</span> (!match) {</div>
<div class="line"><span class="lineno">  366</span>            <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line"><span class="lineno">  367</span>        }</div>
<div class="line"><span class="lineno">  368</span>    }</div>
<div class="line"><span class="lineno">  369</span>    <span class="comment">// Return the matrix of connection points</span></div>
<div class="line"><span class="lineno">  370</span>    <span class="keywordflow">return</span> connections;</div>
<div class="line"><span class="lineno">  371</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7cf52833024ff2f310f53e68bf4ab36" name="ae7cf52833024ff2f310f53e68bf4ab36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cf52833024ff2f310f53e68bf4ab36">&#9670;&#160;</a></span>displacementBC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector2d MeshParametrization::displacementBC </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>branch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>displacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2d &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates displacement boundary condition at point. </p>
<p>There might be multiple nodes on the edge for which displacement boundary conditions are defined. The displacement boundary conditions are provided at the end points of a line segment, this functions help to provide the interpolated displacement BCs for the "internal" nodes of the line segment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">branch</td><td>Branch geometry </td></tr>
    <tr><td class="paramname">displacement</td><td>Displacement boundary conditions </td></tr>
    <tr><td class="paramname">point</td><td>Point to calculate displacement at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2D displacement vector </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  616</span>                                                                                 {</div>
<div class="line"><span class="lineno">  617</span>    LF_ASSERT_MSG(branch.rows() == 4, <span class="stringliteral">&quot;poly points sent to displacementBC has incorrect number of rows, &quot;</span></div>
<div class="line"><span class="lineno">  618</span>                                      <span class="stringliteral">&quot;&quot;</span> &lt;&lt; branch.rows());</div>
<div class="line"><span class="lineno">  619</span>    LF_ASSERT_MSG(branch.cols() == 3, <span class="stringliteral">&quot;poly points sent to displacementBC has incorrect number of columns, &quot;</span></div>
<div class="line"><span class="lineno">  620</span>                                      <span class="stringliteral">&quot;&quot;</span> &lt;&lt; branch.cols());</div>
<div class="line"><span class="lineno">  621</span>    LF_ASSERT_MSG(displacement.rows() == 4, <span class="stringliteral">&quot;displacement sent to displacementBC has incorrect number of rows, &quot;</span></div>
<div class="line"><span class="lineno">  622</span>                                &lt;&lt; displacement.rows());</div>
<div class="line"><span class="lineno">  623</span> </div>
<div class="line"><span class="lineno">  624</span>    <span class="comment">// Note that the shape of branch is 4x3, so use this to generate the two possible lines the point might be on</span></div>
<div class="line"><span class="lineno">  625</span>    Eigen::Vector2d left_pointA = branch.block&lt;2, 1&gt;(0, 0);</div>
<div class="line"><span class="lineno">  626</span>    Eigen::Vector2d left_pointB = branch.block&lt;2, 1&gt;(2, 0);</div>
<div class="line"><span class="lineno">  627</span> </div>
<div class="line"><span class="lineno">  628</span>    Eigen::Vector2d right_pointA = branch.block&lt;2, 1&gt;(0, 2);</div>
<div class="line"><span class="lineno">  629</span>    Eigen::Vector2d right_pointB = branch.block&lt;2, 1&gt;(2, 2);</div>
<div class="line"><span class="lineno">  630</span> </div>
<div class="line"><span class="lineno">  631</span>    <span class="comment">// Using this mapping solely to test which line the point is on</span></div>
<div class="line"><span class="lineno">  632</span>    <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> my_lines(left_pointA, left_pointB, right_pointA, right_pointB);</div>
<div class="line"><span class="lineno">  633</span> </div>
<div class="line"><span class="lineno">  634</span>    <span class="comment">// Find which line the point is on and adjust the other line to the &quot;displaced&quot; line, so that we have a mapping</span></div>
<div class="line"><span class="lineno">  635</span>    <span class="comment">// from old line -&gt; new displaced line</span></div>
<div class="line"><span class="lineno">  636</span>    <span class="keywordflow">if</span> (displacement.cols() == 1)</div>
<div class="line"><span class="lineno">  637</span>    {   <span class="comment">// In this case, we have a multi-branch param, so our displacement occurs on the &quot;right&quot; of the branch</span></div>
<div class="line"><span class="lineno">  638</span>        <span class="keywordflow">if</span> (my_lines.isPointOnSecondLine(point)) {</div>
<div class="line"><span class="lineno">  639</span>            my_lines.update(right_pointA, right_pointB, right_pointA + displacement.block&lt;2, 1&gt;(0, 0),</div>
<div class="line"><span class="lineno">  640</span>                    right_pointB + displacement.block&lt;2, 1&gt;(2, 0));</div>
<div class="line"><span class="lineno">  641</span>        }</div>
<div class="line"><span class="lineno">  642</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  643</span>            LF_ASSERT_MSG(<span class="keyword">false</span>, <span class="stringliteral">&quot;The given point is not on either line in displacementBC&quot;</span>);</div>
<div class="line"><span class="lineno">  644</span>            <span class="keywordflow">return</span> Eigen::Vector2d::Zero();</div>
<div class="line"><span class="lineno">  645</span>        }</div>
<div class="line"><span class="lineno">  646</span>    }</div>
<div class="line"><span class="lineno">  647</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  648</span>    {   <span class="comment">// In this case we have a single-branch param, so we need to see if the point is on the right or left</span></div>
<div class="line"><span class="lineno">  649</span>        <span class="keywordflow">if</span> (my_lines.isPointOnFirstLine(point)) {</div>
<div class="line"><span class="lineno">  650</span>            my_lines.update(left_pointA, left_pointB, left_pointA + displacement.block&lt;2, 1&gt;(0, 0),</div>
<div class="line"><span class="lineno">  651</span>                left_pointB + displacement.block&lt;2, 1&gt;(2, 0));</div>
<div class="line"><span class="lineno">  652</span>        }</div>
<div class="line"><span class="lineno">  653</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (my_lines.isPointOnSecondLine(point)) {</div>
<div class="line"><span class="lineno">  654</span>            my_lines.update(right_pointA, right_pointB, right_pointA + displacement.block&lt;2, 1&gt;(0, 1),</div>
<div class="line"><span class="lineno">  655</span>                    right_pointB + displacement.block&lt;2, 1&gt;(2, 1));</div>
<div class="line"><span class="lineno">  656</span>        }</div>
<div class="line"><span class="lineno">  657</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  658</span>            LF_ASSERT_MSG(<span class="keyword">false</span>, <span class="stringliteral">&quot;The given point is not on either line in displacementBC&quot;</span>);</div>
<div class="line"><span class="lineno">  659</span>            <span class="keywordflow">return</span> Eigen::Vector2d::Zero();</div>
<div class="line"><span class="lineno">  660</span>        }</div>
<div class="line"><span class="lineno">  661</span>    }</div>
<div class="line"><span class="lineno">  662</span>    <span class="comment">// We return the displacement vector for the newly mapped point</span></div>
<div class="line"><span class="lineno">  663</span>    <span class="keywordflow">return</span> my_lines.mapPoint(point) - point;</div>
<div class="line"><span class="lineno">  664</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a22ca202a06e1981f1b7f2ff7a6e532e3" name="a22ca202a06e1981f1b7f2ff7a6e532e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ca202a06e1981f1b7f2ff7a6e532e3">&#9670;&#160;</a></span>displacementEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, double &gt; MeshParametrization::displacementEnergy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>displacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalculation_params.html">calculationParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>calc_params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates displacement energy and checks if in the linear elastic region. </p>
<p>Calls <a class="el" href="#a40b958aa901405b1ce4db0bcfd7b8d6d">elasticRegion</a> for the linear elastic check </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Mesh parametrization </td></tr>
    <tr><td class="paramname">displacement</td><td>Displacement boundary conditions </td></tr>
    <tr><td class="paramname">calc_params</td><td>Calculation parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of (is_valid, energy) </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  746</span>                                                                       {</div>
<div class="line"><span class="lineno">  747</span> </div>
<div class="line"><span class="lineno">  748</span>    <a class="code hl_function" href="#a093eaca69176a6103201e1fc48f2d94d">generateMesh</a>(param, <span class="stringliteral">&quot;displacementEnergy&quot;</span>, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a3ed82876c6fdc96b17b5d821e3bdbe2a">meshSize</a>, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a>);</div>
<div class="line"><span class="lineno">  749</span>    <span class="keyword">auto</span> factory = std::make_unique&lt;lf::mesh::hybrid2d::MeshFactory&gt;(2);</div>
<div class="line"><span class="lineno">  750</span>    <span class="keyword">const</span> std::filesystem::path here = __FILE__;</div>
<div class="line"><span class="lineno">  751</span>    <span class="keyword">auto</span> mesh_file = here.parent_path().parent_path();</div>
<div class="line"><span class="lineno">  752</span>    mesh_file += <span class="stringliteral">&quot;/meshes/displacementEnergy.msh&quot;</span>;</div>
<div class="line"><span class="lineno">  753</span>    lf::io::GmshReader reader(std::move(factory), mesh_file);</div>
<div class="line"><span class="lineno">  754</span>    <span class="keyword">const</span> std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh_ptr = reader.mesh();</div>
<div class="line"><span class="lineno">  755</span> </div>
<div class="line"><span class="lineno">  756</span>    <span class="comment">// Initialize the finite element space we will use for our calculation, depending on the order given</span></div>
<div class="line"><span class="lineno">  757</span>    std::shared_ptr&lt;lf::uscalfe::UniformScalarFESpace&lt;double&gt;&gt; fe_space;</div>
<div class="line"><span class="lineno">  758</span>    <span class="keywordflow">if</span> (calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a> == 1){</div>
<div class="line"><span class="lineno">  759</span>        fe_space = std::make_shared&lt;lf::uscalfe::FeSpaceLagrangeO1&lt;double&gt;&gt;(mesh_ptr);</div>
<div class="line"><span class="lineno">  760</span>    }</div>
<div class="line"><span class="lineno">  761</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  762</span>        fe_space = std::make_shared&lt;lf::uscalfe::FeSpaceLagrangeO2&lt;double&gt;&gt;(mesh_ptr);</div>
<div class="line"><span class="lineno">  763</span>    }</div>
<div class="line"><span class="lineno">  764</span> </div>
<div class="line"><span class="lineno">  765</span>    <span class="keyword">auto</span> poly_points = <a class="code hl_function" href="#a7e2be81d0d3a5153798423ce3a58e3a1">polynomialPoints</a>(param);</div>
<div class="line"><span class="lineno">  766</span>    <span class="keyword">const</span> lf::assemble::DofHandler &amp;dofh {fe_space-&gt;LocGlobMap()};</div>
<div class="line"><span class="lineno">  767</span>    <span class="keyword">const</span> lf::uscalfe::size_type N_dofs {dofh.NumDofs()};</div>
<div class="line"><span class="lineno">  768</span>    <span class="keyword">const</span> lf::mesh::Mesh &amp;mesh {*mesh_ptr};</div>
<div class="line"><span class="lineno">  769</span> </div>
<div class="line"><span class="lineno">  770</span>    <span class="comment">// Initialize useful objects to set up our boundary conditions</span></div>
<div class="line"><span class="lineno">  771</span>    lf::mesh::utils::CodimMeshDataSet bd_flags{mesh_ptr, 2, <span class="keyword">false</span>};</div>
<div class="line"><span class="lineno">  772</span>    std::vector&lt;std::pair&lt;bool, Eigen::Vector2d&gt;&gt; displacementBCs(N_dofs);</div>
<div class="line"><span class="lineno">  773</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; bc : displacementBCs) {</div>
<div class="line"><span class="lineno">  774</span>        bc.first = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  775</span>        bc.second = Eigen::Vector2d::Zero();</div>
<div class="line"><span class="lineno">  776</span>    }</div>
<div class="line"><span class="lineno">  777</span> </div>
<div class="line"><span class="lineno">  778</span>    <span class="comment">// This loop goes through all edges to identify which are on the boundaries we are interested in</span></div>
<div class="line"><span class="lineno">  779</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> lf::mesh::Entity *edge: mesh.Entities((1))) {</div>
<div class="line"><span class="lineno">  780</span> </div>
<div class="line"><span class="lineno">  781</span>        <span class="comment">// If the physical entity vector is non-empty, we investigate the edge&#39;s nodes</span></div>
<div class="line"><span class="lineno">  782</span>        <span class="keywordflow">if</span> (!reader.PhysicalEntityNr(*edge).empty()) {</div>
<div class="line"><span class="lineno">  783</span>            <span class="keywordtype">int</span> tag = reader.PhysicalEntityNr(*edge)[0];</div>
<div class="line"><span class="lineno">  784</span> </div>
<div class="line"><span class="lineno">  785</span>            <span class="comment">// Iterate through the nodes on this edge, and prescribe a displacement BC if we haven&#39;t done so already</span></div>
<div class="line"><span class="lineno">  786</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span> node : edge-&gt;SubEntities(1)) {</div>
<div class="line"><span class="lineno">  787</span>                <span class="keywordflow">if</span> (!bd_flags(*node)) {</div>
<div class="line"><span class="lineno">  788</span>                    bd_flags(*node) = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  789</span> </div>
<div class="line"><span class="lineno">  790</span>                    Eigen::Vector2d BC;</div>
<div class="line"><span class="lineno">  791</span>                    <span class="keywordflow">if</span> (poly_points.rows() == 4) {</div>
<div class="line"><span class="lineno">  792</span>                        BC = <a class="code hl_function" href="#ae7cf52833024ff2f310f53e68bf4ab36">displacementBC</a>(poly_points, displacement,</div>
<div class="line"><span class="lineno">  793</span>                            node-&gt;Geometry()-&gt;Global(node-&gt;Geometry()-&gt;RefEl().NodeCoords()));</div>
<div class="line"><span class="lineno">  794</span>                    }</div>
<div class="line"><span class="lineno">  795</span>                    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  796</span>                        BC = <a class="code hl_function" href="#ae7cf52833024ff2f310f53e68bf4ab36">displacementBC</a>(poly_points.block&lt;4, 3&gt;((tag - 1) * 4, 0),</div>
<div class="line"><span class="lineno">  797</span>                            displacement.block((tag - 1) * 4, 0, 4, displacement.cols()),</div>
<div class="line"><span class="lineno">  798</span>                            node-&gt;Geometry()-&gt;Global(node-&gt;Geometry()-&gt;RefEl().NodeCoords()));</div>
<div class="line"><span class="lineno">  799</span>                    }</div>
<div class="line"><span class="lineno">  800</span>                    displacementBCs[mesh.Index(*node)] = {<span class="keyword">true</span>, BC};</div>
<div class="line"><span class="lineno">  801</span>                }</div>
<div class="line"><span class="lineno">  802</span>            }</div>
<div class="line"><span class="lineno">  803</span>        }</div>
<div class="line"><span class="lineno">  804</span>    }</div>
<div class="line"><span class="lineno">  805</span> </div>
<div class="line"><span class="lineno">  806</span>    <span class="comment">// Declare matrices and vector that will hold our solution, phi doesn&#39;t need to be changed for now</span></div>
<div class="line"><span class="lineno">  807</span>    lf::assemble::COOMatrix&lt;double&gt; A(N_dofs*2, N_dofs*2);</div>
<div class="line"><span class="lineno">  808</span>    Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt; phi(N_dofs*2);</div>
<div class="line"><span class="lineno">  809</span>    phi.setZero();</div>
<div class="line"><span class="lineno">  810</span> </div>
<div class="line"><span class="lineno">  811</span>    <span class="comment">// Build the stiffness matrix</span></div>
<div class="line"><span class="lineno">  812</span>    <span class="comment">// TODO: double check whether this is a planeStrain calculation (it is if this is set to true)</span></div>
<div class="line"><span class="lineno">  813</span>    <span class="keywordflow">if</span> (calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a> == 1) {</div>
<div class="line"><span class="lineno">  814</span>        <a class="code hl_class" href="class_linear_matrix_computation_1_1_linear_f_e_element_matrix.html">LinearMatrixComputation::LinearFEElementMatrix</a> assemble{calc_params.<a class="code hl_variable" href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">youngsModulus</a>,</div>
<div class="line"><span class="lineno">  815</span>            calc_params.<a class="code hl_variable" href="structcalculation_params.html#a474cb6b7c18758b753f1eda8d423604e">poissonRatio</a>, <span class="keyword">true</span>};</div>
<div class="line"><span class="lineno">  816</span>        <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#adbfe31593abe48a26e05aa1f964cdc70">LinearElasticityAssembler::AssembleMatrixLocally</a>(0, dofh, dofh, assemble, A);</div>
<div class="line"><span class="lineno">  817</span>    }</div>
<div class="line"><span class="lineno">  818</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  819</span>        <a class="code hl_class" href="class_parametric_matrix_computation_1_1_parametric_f_e_element_matrix.html">ParametricMatrixComputation::ParametricFEElementMatrix</a> assemble{calc_params.<a class="code hl_variable" href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">youngsModulus</a>,</div>
<div class="line"><span class="lineno">  820</span>            calc_params.<a class="code hl_variable" href="structcalculation_params.html#a474cb6b7c18758b753f1eda8d423604e">poissonRatio</a>, <span class="keyword">true</span>};</div>
<div class="line"><span class="lineno">  821</span>        <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#adbfe31593abe48a26e05aa1f964cdc70">LinearElasticityAssembler::AssembleMatrixLocally</a>(0, dofh, dofh, assemble, A);</div>
<div class="line"><span class="lineno">  822</span>    }</div>
<div class="line"><span class="lineno">  823</span> </div>
<div class="line"><span class="lineno">  824</span>    <span class="comment">// Send to fixFlaggedSolutionsComponents to fit to the shape mentioned in NUMPDE 2.7.6.15</span></div>
<div class="line"><span class="lineno">  825</span>    <a class="code hl_function" href="#acd41b6a7ce9251b59725b4d6a93f631f">fixFlaggedSolutionComponentsLE</a>(displacementBCs, A, phi);</div>
<div class="line"><span class="lineno">  826</span> </div>
<div class="line"><span class="lineno">  827</span>    <span class="comment">// Solve the liner system and return the resulting displacement vector</span></div>
<div class="line"><span class="lineno">  828</span>    Eigen::SparseMatrix A_crs = A.makeSparse();</div>
<div class="line"><span class="lineno">  829</span>    Eigen::SparseLU&lt;Eigen::SparseMatrix&lt;double&gt;&gt; solver;</div>
<div class="line"><span class="lineno">  830</span>    solver.compute(A_crs);</div>
<div class="line"><span class="lineno">  831</span>    Eigen::VectorXd sol_vec = solver.solve(phi);</div>
<div class="line"><span class="lineno">  832</span> </div>
<div class="line"><span class="lineno">  833</span>    <span class="keywordtype">bool</span> linear_elastic;</div>
<div class="line"><span class="lineno">  834</span>    <span class="keywordtype">double</span> energy = 0;</div>
<div class="line"><span class="lineno">  835</span> </div>
<div class="line"><span class="lineno">  836</span>    <span class="comment">// Calculate the stress and strains to check if we are still in the linear elastic region, and calculate the energy</span></div>
<div class="line"><span class="lineno">  837</span>    <span class="keywordflow">if</span> (calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a> == 1){</div>
<div class="line"><span class="lineno">  838</span>        <a class="code hl_class" href="class_linear_matrix_computation_1_1_linear_f_e_element_matrix.html">LinearMatrixComputation::LinearFEElementMatrix</a> assemble{calc_params.<a class="code hl_variable" href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">youngsModulus</a>,</div>
<div class="line"><span class="lineno">  839</span>            calc_params.<a class="code hl_variable" href="structcalculation_params.html#a474cb6b7c18758b753f1eda8d423604e">poissonRatio</a>, <span class="keyword">true</span>};</div>
<div class="line"><span class="lineno">  840</span>        <span class="keyword">auto</span> stresses_strains = <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#a2b01541015c753760235905552a2225b">LinearElasticityAssembler::stressStrainLoader</a>(</div>
<div class="line"><span class="lineno">  841</span>            mesh_ptr, sol_vec, assemble, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a>);</div>
<div class="line"><span class="lineno">  842</span>        energy = <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#aa59969ea728ac197847183f3a73760ed">LinearElasticityAssembler::energyCalculator</a>(mesh_ptr, sol_vec, assemble, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a>);</div>
<div class="line"><span class="lineno">  843</span>        linear_elastic = <a class="code hl_function" href="#a40b958aa901405b1ce4db0bcfd7b8d6d">elasticRegion</a>(std::get&lt;2&gt;(stresses_strains), calc_params.<a class="code hl_variable" href="structcalculation_params.html#ace9b6fd27b86d83388100ac6ec85ce68">yieldStrength</a>);</div>
<div class="line"><span class="lineno">  844</span>    }</div>
<div class="line"><span class="lineno">  845</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  846</span>        <a class="code hl_class" href="class_parametric_matrix_computation_1_1_parametric_f_e_element_matrix.html">ParametricMatrixComputation::ParametricFEElementMatrix</a> assemble{calc_params.<a class="code hl_variable" href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">youngsModulus</a>,</div>
<div class="line"><span class="lineno">  847</span>            calc_params.<a class="code hl_variable" href="structcalculation_params.html#a474cb6b7c18758b753f1eda8d423604e">poissonRatio</a>, <span class="keyword">true</span>};</div>
<div class="line"><span class="lineno">  848</span>        <span class="keyword">auto</span> stresses_strains = <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#a2b01541015c753760235905552a2225b">LinearElasticityAssembler::stressStrainLoader</a>(</div>
<div class="line"><span class="lineno">  849</span>            mesh_ptr, sol_vec, assemble, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a>);</div>
<div class="line"><span class="lineno">  850</span>        energy = <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#aa59969ea728ac197847183f3a73760ed">LinearElasticityAssembler::energyCalculator</a>(mesh_ptr, sol_vec, assemble, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a>);</div>
<div class="line"><span class="lineno">  851</span>        linear_elastic = <a class="code hl_function" href="#a40b958aa901405b1ce4db0bcfd7b8d6d">elasticRegion</a>(std::get&lt;2&gt;(stresses_strains), calc_params.<a class="code hl_variable" href="structcalculation_params.html#ace9b6fd27b86d83388100ac6ec85ce68">yieldStrength</a>);</div>
<div class="line"><span class="lineno">  852</span>    }</div>
<div class="line"><span class="lineno">  853</span> </div>
<div class="line"><span class="lineno">  854</span>    <span class="keywordflow">return</span> {linear_elastic, energy};</div>
<div class="line"><span class="lineno">  855</span>}</div>
<div class="ttc" id="aclass_linear_matrix_computation_1_1_linear_f_e_element_matrix_html"><div class="ttname"><a href="class_linear_matrix_computation_1_1_linear_f_e_element_matrix.html">LinearMatrixComputation::LinearFEElementMatrix</a></div><div class="ttdoc">Class for computing linear finite element stiffness matrices.</div><div class="ttdef"><b>Definition</b> linear_matrix_computation.h:20</div></div>
<div class="ttc" id="aclass_parametric_matrix_computation_1_1_parametric_f_e_element_matrix_html"><div class="ttname"><a href="class_parametric_matrix_computation_1_1_parametric_f_e_element_matrix.html">ParametricMatrixComputation::ParametricFEElementMatrix</a></div><div class="ttdoc">Class for computing parametric finite element stiffness matrices.</div><div class="ttdef"><b>Definition</b> parametric_matrix_computation.h:27</div></div>
<div class="ttc" id="anamespace_linear_elasticity_assembler_html_a2b01541015c753760235905552a2225b"><div class="ttname"><a href="namespace_linear_elasticity_assembler.html#a2b01541015c753760235905552a2225b">LinearElasticityAssembler::stressStrainLoader</a></div><div class="ttdeci">std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt; stressStrainLoader(const std::shared_ptr&lt; lf::mesh::Mesh &gt; &amp;mesh_ptr, Eigen::VectorXd &amp;disp_vec, ENTITY_MATRIX_PROVIDER &amp;assembler, int degree)</div><div class="ttdoc">Computes stress and strain fields from displacement solution.</div><div class="ttdef"><b>Definition</b> linear_elasticity_assembler.h:156</div></div>
<div class="ttc" id="anamespace_linear_elasticity_assembler_html_aa59969ea728ac197847183f3a73760ed"><div class="ttname"><a href="namespace_linear_elasticity_assembler.html#aa59969ea728ac197847183f3a73760ed">LinearElasticityAssembler::energyCalculator</a></div><div class="ttdeci">double energyCalculator(const std::shared_ptr&lt; lf::mesh::Mesh &gt; &amp;mesh_ptr, Eigen::VectorXd &amp;disp_vec, ENTITY_MATRIX_PROVIDER &amp;assembler, int degree)</div><div class="ttdoc">Calculates total strain energy of the system.</div><div class="ttdef"><b>Definition</b> linear_elasticity_assembler.h:244</div></div>
<div class="ttc" id="anamespace_linear_elasticity_assembler_html_adbfe31593abe48a26e05aa1f964cdc70"><div class="ttname"><a href="namespace_linear_elasticity_assembler.html#adbfe31593abe48a26e05aa1f964cdc70">LinearElasticityAssembler::AssembleMatrixLocally</a></div><div class="ttdeci">void AssembleMatrixLocally(lf::base::dim_t codim, const lf::assemble::DofHandler &amp;dof_handler_trial, const lf::assemble::DofHandler &amp;dof_handler_test, ENTITY_MATRIX_PROVIDER &amp;entity_matrix_provider, TMPMATRIX &amp;matrix)</div><div class="ttdoc">Assembles global stiffness matrix from local contributions.</div><div class="ttdef"><b>Definition</b> linear_elasticity_assembler.h:30</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a093eaca69176a6103201e1fc48f2d94d"><div class="ttname"><a href="#a093eaca69176a6103201e1fc48f2d94d">MeshParametrization::generateMesh</a></div><div class="ttdeci">void generateMesh(MeshParametrizationData &amp;parametrization, const std::string &amp;mesh_name, double mesh_size, int order)</div><div class="ttdoc">Generates mesh from a MeshParametrizationData object.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:435</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a40b958aa901405b1ce4db0bcfd7b8d6d"><div class="ttname"><a href="#a40b958aa901405b1ce4db0bcfd7b8d6d">MeshParametrization::elasticRegion</a></div><div class="ttdeci">bool elasticRegion(const Eigen::MatrixXd &amp;stresses, double yieldStrength)</div><div class="ttdoc">Checks if stress state is within elastic region of the material.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:721</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_acd41b6a7ce9251b59725b4d6a93f631f"><div class="ttname"><a href="#acd41b6a7ce9251b59725b4d6a93f631f">MeshParametrization::fixFlaggedSolutionComponentsLE</a></div><div class="ttdeci">void fixFlaggedSolutionComponentsLE(std::vector&lt; std::pair&lt; bool, Eigen::Vector2d &gt; &gt; &amp;select_vals, lf::assemble::COOMatrix&lt; double &gt; &amp;A, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;phi)</div><div class="ttdoc">Fixes matrix to format 2.7.6.15 of NUMPDE lecture document.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:669</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_ae7cf52833024ff2f310f53e68bf4ab36"><div class="ttname"><a href="#ae7cf52833024ff2f310f53e68bf4ab36">MeshParametrization::displacementBC</a></div><div class="ttdeci">Eigen::Vector2d displacementBC(const Eigen::MatrixXd &amp;branch, const Eigen::MatrixXd &amp;displacement, const Eigen::Vector2d &amp;point)</div><div class="ttdoc">Calculates displacement boundary condition at point.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:615</div></div>
<div class="ttc" id="astructcalculation_params_html_a3ed82876c6fdc96b17b5d821e3bdbe2a"><div class="ttname"><a href="structcalculation_params.html#a3ed82876c6fdc96b17b5d821e3bdbe2a">calculationParams::meshSize</a></div><div class="ttdeci">double meshSize</div><div class="ttdoc">Mesh element size parameter.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:39</div></div>
<div class="ttc" id="astructcalculation_params_html_a474cb6b7c18758b753f1eda8d423604e"><div class="ttname"><a href="structcalculation_params.html#a474cb6b7c18758b753f1eda8d423604e">calculationParams::poissonRatio</a></div><div class="ttdeci">double poissonRatio</div><div class="ttdoc">Poisson's ratio (ν)</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:38</div></div>
<div class="ttc" id="astructcalculation_params_html_a9839ec496ba2e56a9c539506f6a1f2c1"><div class="ttname"><a href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">calculationParams::order</a></div><div class="ttdeci">int order</div><div class="ttdoc">Finite element order (1 or 2)</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:40</div></div>
<div class="ttc" id="astructcalculation_params_html_ace9b6fd27b86d83388100ac6ec85ce68"><div class="ttname"><a href="structcalculation_params.html#ace9b6fd27b86d83388100ac6ec85ce68">calculationParams::yieldStrength</a></div><div class="ttdeci">double yieldStrength</div><div class="ttdoc">Material yield strength.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:36</div></div>
<div class="ttc" id="astructcalculation_params_html_ae54bfa79920c9d530abaae7bc3faa4ed"><div class="ttname"><a href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">calculationParams::youngsModulus</a></div><div class="ttdeci">double youngsModulus</div><div class="ttdoc">Young's modulus (E)</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:37</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a40b958aa901405b1ce4db0bcfd7b8d6d" name="a40b958aa901405b1ce4db0bcfd7b8d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b958aa901405b1ce4db0bcfd7b8d6d">&#9670;&#160;</a></span>elasticRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshParametrization::elasticRegion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>stresses</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>yieldStrength</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if stress state is within elastic region of the material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stresses</td><td>Matrix of stress components </td></tr>
    <tr><td class="paramname">yieldStrength</td><td>Material yield strength </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if within elastic region </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  721</span>                                                                                           {</div>
<div class="line"><span class="lineno">  722</span> </div>
<div class="line"><span class="lineno">  723</span>    <span class="comment">// stresses and strains have the same number of columns, iterate through each column and check our criteria</span></div>
<div class="line"><span class="lineno">  724</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; stresses.cols(); i++) {</div>
<div class="line"><span class="lineno">  725</span>        <span class="comment">// Calculate the von Mises stress</span></div>
<div class="line"><span class="lineno">  726</span>        <span class="keywordtype">double</span> sigma_xx = stresses(0, i);</div>
<div class="line"><span class="lineno">  727</span>        <span class="keywordtype">double</span> sigma_yy = stresses(1, i);</div>
<div class="line"><span class="lineno">  728</span>        <span class="keywordtype">double</span> sigma_xy = stresses(2, i);</div>
<div class="line"><span class="lineno">  729</span> </div>
<div class="line"><span class="lineno">  730</span>        <span class="keywordtype">double</span> von_mises = std::sqrt(sigma_xx*sigma_xx + sigma_yy*sigma_yy</div>
<div class="line"><span class="lineno">  731</span>                                    - sigma_xx*sigma_yy + 3*sigma_xy*sigma_xy);</div>
<div class="line"><span class="lineno">  732</span> </div>
<div class="line"><span class="lineno">  733</span>        <span class="keywordflow">if</span> (von_mises &gt; yieldStrength) {</div>
<div class="line"><span class="lineno">  734</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  735</span>        }</div>
<div class="line"><span class="lineno">  736</span>    }</div>
<div class="line"><span class="lineno">  737</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  738</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acd41b6a7ce9251b59725b4d6a93f631f" name="acd41b6a7ce9251b59725b4d6a93f631f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd41b6a7ce9251b59725b4d6a93f631f">&#9670;&#160;</a></span>fixFlaggedSolutionComponentsLE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshParametrization::fixFlaggedSolutionComponentsLE </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; bool, Eigen::Vector2d &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>select_vals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lf::assemble::COOMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>phi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixes matrix to format 2.7.6.15 of NUMPDE lecture document. </p>
<p>Given that some displacement boundary conditions are prescribed on the boundary, this function ensures that the corresponding rows of the Galerkin matrix for these rows are altered to the identity, and the corresponding elements in the solution vector are modified as well to reflect this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">select_vals</td><td>Vector of flagged components and values </td></tr>
    <tr><td class="paramname">A</td><td>Galerkin matrix </td></tr>
    <tr><td class="paramname">phi</td><td>Solution vector </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  671</span>                                                                                                     {</div>
<div class="line"><span class="lineno">  672</span>    <span class="comment">// Note here N is technically &quot;2N&quot; since each node has two coordinates</span></div>
<div class="line"><span class="lineno">  673</span>    <span class="keyword">const</span> lf::assemble::size_type N(A.cols());</div>
<div class="line"><span class="lineno">  674</span>    LF_ASSERT_MSG(A.rows() == N, <span class="stringliteral">&quot;Matrix must be square!&quot;</span>);</div>
<div class="line"><span class="lineno">  675</span>    LF_ASSERT_MSG(N == phi.size(), <span class="stringliteral">&quot;Mismatch N = &quot;</span> &lt;&lt; N &lt;&lt; <span class="stringliteral">&quot; &lt;-&gt; b.size() = &quot;</span> &lt;&lt; phi.size());</div>
<div class="line"><span class="lineno">  676</span> </div>
<div class="line"><span class="lineno">  677</span>    Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt; tmp_vec(N);</div>
<div class="line"><span class="lineno">  678</span> </div>
<div class="line"><span class="lineno">  679</span>    <span class="comment">// Iterate over half of the total N_dofs, as that is how large selectvals is</span></div>
<div class="line"><span class="lineno">  680</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; N / 2; ++k) {</div>
<div class="line"><span class="lineno">  681</span>        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;sel_val = select_vals[k];</div>
<div class="line"><span class="lineno">  682</span> </div>
<div class="line"><span class="lineno">  683</span>        <span class="comment">// Add value to tmp_vec, knowing .second is a Eigen::Vector2d</span></div>
<div class="line"><span class="lineno">  684</span>        <span class="keywordflow">if</span> (sel_val.first) {</div>
<div class="line"><span class="lineno">  685</span>            tmp_vec[2 * k] = sel_val.second[0];</div>
<div class="line"><span class="lineno">  686</span>            tmp_vec[2 * k + 1] = sel_val.second[1];</div>
<div class="line"><span class="lineno">  687</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  688</span>            tmp_vec[2 * k] = 0.0;</div>
<div class="line"><span class="lineno">  689</span>            tmp_vec[2 * k + 1] = 0.0;</div>
<div class="line"><span class="lineno">  690</span>        }</div>
<div class="line"><span class="lineno">  691</span>    }</div>
<div class="line"><span class="lineno">  692</span>    A.MatVecMult(-1.0, tmp_vec, phi);</div>
<div class="line"><span class="lineno">  693</span> </div>
<div class="line"><span class="lineno">  694</span>    <span class="comment">// Adjust the values in the rhs vector</span></div>
<div class="line"><span class="lineno">  695</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; N / 2; ++k) {</div>
<div class="line"><span class="lineno">  696</span>        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;sel_val = select_vals[k];</div>
<div class="line"><span class="lineno">  697</span>        <span class="keywordflow">if</span> (sel_val.first) {</div>
<div class="line"><span class="lineno">  698</span>            phi[2 * k] = sel_val.second[0];</div>
<div class="line"><span class="lineno">  699</span>            phi[2 * k + 1] = sel_val.second[1];</div>
<div class="line"><span class="lineno">  700</span>        }</div>
<div class="line"><span class="lineno">  701</span>    }</div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span>    <span class="comment">// Adjust the values in the stiffness matrix to 0 where selectvals is true</span></div>
<div class="line"><span class="lineno">  704</span>    A.setZero([&amp;select_vals] (lf::assemble::gdof_idx_t i, lf::assemble::gdof_idx_t j) {</div>
<div class="line"><span class="lineno">  705</span>        <span class="keywordflow">return</span> (select_vals[i / 2].first || select_vals[j / 2].first);</div>
<div class="line"><span class="lineno">  706</span>    });</div>
<div class="line"><span class="lineno">  707</span> </div>
<div class="line"><span class="lineno">  708</span>    <span class="comment">// Adjust diagonal entries to 1 if selectvals is true</span></div>
<div class="line"><span class="lineno">  709</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; N / 2; ++k) {</div>
<div class="line"><span class="lineno">  710</span>        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;sel_val = select_vals[k];</div>
<div class="line"><span class="lineno">  711</span>        <span class="keywordflow">if</span> (sel_val.first) {</div>
<div class="line"><span class="lineno">  712</span>            A.AddToEntry(2 * k, 2 * k, 1.0);</div>
<div class="line"><span class="lineno">  713</span>            A.AddToEntry(2 * k + 1, 2 * k + 1, 1.0);</div>
<div class="line"><span class="lineno">  714</span>        }</div>
<div class="line"><span class="lineno">  715</span>    }</div>
<div class="line"><span class="lineno">  716</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a093eaca69176a6103201e1fc48f2d94d" name="a093eaca69176a6103201e1fc48f2d94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093eaca69176a6103201e1fc48f2d94d">&#9670;&#160;</a></span>generateMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshParametrization::generateMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parametrization</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>mesh_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.01</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates mesh from a <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parametrization</td><td>Mesh parametrization data </td></tr>
    <tr><td class="paramname">mesh_name</td><td>Output mesh file name </td></tr>
    <tr><td class="paramname">mesh_size</td><td>Mesh element size (no .msh extension required) </td></tr>
    <tr><td class="paramname">order</td><td>Finite element order </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  436</span>                                        {</div>
<div class="line"><span class="lineno">  437</span> </div>
<div class="line"><span class="lineno">  438</span>    Eigen::MatrixXd poly_points = <a class="code hl_function" href="#a7e2be81d0d3a5153798423ce3a58e3a1">polynomialPoints</a>(parametrization);</div>
<div class="line"><span class="lineno">  439</span> </div>
<div class="line"><span class="lineno">  440</span>    <span class="comment">// I&#39;m choosing not to add a model name due to possible repeats, only initializing gmsh</span></div>
<div class="line"><span class="lineno">  441</span>    gmsh::initialize();</div>
<div class="line"><span class="lineno">  442</span> </div>
<div class="line"><span class="lineno">  443</span>    gmsh::option::setNumber(<span class="stringliteral">&quot;General.Verbosity&quot;</span>, 2);</div>
<div class="line"><span class="lineno">  444</span> </div>
<div class="line"><span class="lineno">  445</span>    <span class="comment">// In this case, there are just 6 points to add, 2 linear lines, 2 splines, and a surface with all curves</span></div>
<div class="line"><span class="lineno">  446</span>    <span class="keywordflow">if</span> (parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a> == 1) {</div>
<div class="line"><span class="lineno">  447</span> </div>
<div class="line"><span class="lineno">  448</span>        <span class="comment">// Add the points defined by poly_points</span></div>
<div class="line"><span class="lineno">  449</span>        <span class="keywordtype">int</span> p1 = gmsh::model::geo::addPoint(poly_points(0, 0), poly_points(1, 0), 0.0, mesh_size);</div>
<div class="line"><span class="lineno">  450</span>        <span class="keywordtype">int</span> p2 = gmsh::model::geo::addPoint(poly_points(0, 1), poly_points(1, 1), 0.0, mesh_size);</div>
<div class="line"><span class="lineno">  451</span>        <span class="keywordtype">int</span> p3 = gmsh::model::geo::addPoint(poly_points(0, 2), poly_points(1, 2), 0.0, mesh_size);</div>
<div class="line"><span class="lineno">  452</span>        <span class="keywordtype">int</span> p4 = gmsh::model::geo::addPoint(poly_points(2, 0), poly_points(3, 0), 0.0, mesh_size);</div>
<div class="line"><span class="lineno">  453</span>        <span class="keywordtype">int</span> p5 = gmsh::model::geo::addPoint(poly_points(2, 1), poly_points(3, 1), 0.0, mesh_size);</div>
<div class="line"><span class="lineno">  454</span>        <span class="keywordtype">int</span> p6 = gmsh::model::geo::addPoint(poly_points(2, 2), poly_points(3, 2), 0.0, mesh_size);</div>
<div class="line"><span class="lineno">  455</span> </div>
<div class="line"><span class="lineno">  456</span>        <span class="comment">// Create our two splines and two lines, the points are ordered such that a curve loop is easy to define</span></div>
<div class="line"><span class="lineno">  457</span>        <span class="keywordtype">int</span> l1 = gmsh::model::geo::addLine(p1, p4);</div>
<div class="line"><span class="lineno">  458</span>        <span class="keywordtype">int</span> l2 = gmsh::model::geo::addLine(p6, p3);</div>
<div class="line"><span class="lineno">  459</span>        <span class="keywordtype">int</span> s1 = gmsh::model::geo::addSpline({p3, p2, p1});</div>
<div class="line"><span class="lineno">  460</span>        <span class="keywordtype">int</span> s2 = gmsh::model::geo::addSpline({p4, p5, p6});</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span>        <span class="comment">// Add a curve loop and create a surface</span></div>
<div class="line"><span class="lineno">  463</span>        <span class="keywordtype">int</span> c1 = gmsh::model::geo::addCurveLoop({l1, s2, l2, s1});</div>
<div class="line"><span class="lineno">  464</span>        <span class="keywordtype">int</span> pl1 = gmsh::model::geo::addPlaneSurface({c1});</div>
<div class="line"><span class="lineno">  465</span> </div>
<div class="line"><span class="lineno">  466</span>        gmsh::model::geo::synchronize();</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span>        <span class="comment">// I add physical groups on the lines, which is where I intend to incorporate displacement BCs</span></div>
<div class="line"><span class="lineno">  469</span>        gmsh::model::addPhysicalGroup(1, {l1}, 1);</div>
<div class="line"><span class="lineno">  470</span>        gmsh::model::addPhysicalGroup(1, {l2}, 2);</div>
<div class="line"><span class="lineno">  471</span>        gmsh::model::addPhysicalGroup(2, {pl1}, 3);</div>
<div class="line"><span class="lineno">  472</span>    }</div>
<div class="line"><span class="lineno">  473</span> </div>
<div class="line"><span class="lineno">  474</span>    <span class="comment">// In this case, the number of total points to add is highly variable</span></div>
<div class="line"><span class="lineno">  475</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a> &gt;= 3) {</div>
<div class="line"><span class="lineno">  476</span> </div>
<div class="line"><span class="lineno">  477</span>        <span class="comment">// Initialize matrix that will hold the points that are connected, this will be the basis for center_lines</span></div>
<div class="line"><span class="lineno">  478</span>        <span class="keyword">auto</span> connected_points = <a class="code hl_function" href="#a07f7f735900d22b64eb9024139a1f18e">connectionPoints</a>(parametrization);</div>
<div class="line"><span class="lineno">  479</span> </div>
<div class="line"><span class="lineno">  480</span>        Eigen::VectorXi connections = -1 * Eigen::VectorXi::Ones(parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a> * 2);</div>
<div class="line"><span class="lineno">  481</span> </div>
<div class="line"><span class="lineno">  482</span>        <span class="comment">// The purpose of centerLines is to hold the tags of lines that are in the center of this multi-branch</span></div>
<div class="line"><span class="lineno">  483</span>        <span class="comment">// It holds the tag of the line followed by the points used to define it, in the right order</span></div>
<div class="line"><span class="lineno">  484</span>        std::vector&lt;std::pair&lt;int, std::pair&lt;int, int&gt;&gt;&gt; center_lines(parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>);</div>
<div class="line"><span class="lineno">  485</span> </div>
<div class="line"><span class="lineno">  486</span>        <span class="comment">// Vectors to hold the would be tags of line and surfaces to later add physical grouos</span></div>
<div class="line"><span class="lineno">  487</span>        std::vector&lt;int&gt; line_tags(parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>);</div>
<div class="line"><span class="lineno">  488</span>        std::vector&lt;int&gt; surface_tags (parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a> + 1);</div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>        <span class="comment">// Start a loop to add each branch to the mesh</span></div>
<div class="line"><span class="lineno">  491</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> branch = 0; branch &lt; parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; ++branch) {</div>
<div class="line"><span class="lineno">  492</span>            <span class="comment">// This vector will hold the &quot;names&quot; of the points we add to the mesh</span></div>
<div class="line"><span class="lineno">  493</span>            std::vector&lt;int&gt; points;</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  495</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> point = 0; point &lt; 6; ++point) {</div>
<div class="line"><span class="lineno">  496</span>                <span class="comment">// Declare indices we&#39;ll access in poly points to add the points</span></div>
<div class="line"><span class="lineno">  497</span>                <span class="keywordtype">int</span> row = branch * 4 + (point / 3) * 2;</div>
<div class="line"><span class="lineno">  498</span>                <span class="keywordtype">int</span> col = point % 3;</div>
<div class="line"><span class="lineno">  499</span> </div>
<div class="line"><span class="lineno">  500</span>                <span class="comment">// Check if the point we are adding is one of the center points</span></div>
<div class="line"><span class="lineno">  501</span>                <span class="keywordflow">if</span> (col == 0) {</div>
<div class="line"><span class="lineno">  502</span>                    <span class="keywordtype">int</span> center_point = 2 * branch + point / 3;</div>
<div class="line"><span class="lineno">  503</span>                    <span class="comment">// If this is true, then we&#39;ve already &quot;added&quot; this point, so we add the tag of the point</span></div>
<div class="line"><span class="lineno">  504</span>                    <span class="comment">// we&#39;ve already added to the points vector</span></div>
<div class="line"><span class="lineno">  505</span>                    <span class="keywordflow">if</span> (connected_points.value()[center_point] &lt; center_point) {</div>
<div class="line"><span class="lineno">  506</span>                        points.push_back(connections[center_point]);</div>
<div class="line"><span class="lineno">  507</span>                    }</div>
<div class="line"><span class="lineno">  508</span>                    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  509</span>                        <span class="keywordtype">int</span> new_point = gmsh::model::geo::addPoint(poly_points(row, col),</div>
<div class="line"><span class="lineno">  510</span>                            poly_points(row + 1, col), 0.0, mesh_size);</div>
<div class="line"><span class="lineno">  511</span>                        points.push_back(new_point);</div>
<div class="line"><span class="lineno">  512</span>                        connections[center_point] = new_point;</div>
<div class="line"><span class="lineno">  513</span>                        connections[connected_points.value()[center_point]] = new_point;</div>
<div class="line"><span class="lineno">  514</span>                    }</div>
<div class="line"><span class="lineno">  515</span>                }</div>
<div class="line"><span class="lineno">  516</span>                <span class="comment">// If we don&#39;t add a center point, we can immediately add it</span></div>
<div class="line"><span class="lineno">  517</span>                <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  518</span>                    <span class="keywordtype">int</span> new_point = gmsh::model::geo::addPoint(poly_points(row, col),</div>
<div class="line"><span class="lineno">  519</span>                        poly_points(row + 1, col), 0.0, mesh_size);</div>
<div class="line"><span class="lineno">  520</span>                    points.push_back(new_point);</div>
<div class="line"><span class="lineno">  521</span>                }</div>
<div class="line"><span class="lineno">  522</span>            }</div>
<div class="line"><span class="lineno">  523</span>            <span class="comment">// Create our two splines and two lines, using the points vector</span></div>
<div class="line"><span class="lineno">  524</span>            <span class="keywordtype">int</span> l1 = gmsh::model::geo::addLine(points[0], points[3]);</div>
<div class="line"><span class="lineno">  525</span>            <span class="keywordtype">int</span> l2 = gmsh::model::geo::addLine(points[5], points[2]);</div>
<div class="line"><span class="lineno">  526</span>            <span class="keywordtype">int</span> s1 = gmsh::model::geo::addSpline({points[2], points[1], points[0]});</div>
<div class="line"><span class="lineno">  527</span>            <span class="keywordtype">int</span> s2 = gmsh::model::geo::addSpline({points[3], points[4], points[5]});</div>
<div class="line"><span class="lineno">  528</span> </div>
<div class="line"><span class="lineno">  529</span>            <span class="comment">// Add a curve loop and create a surface</span></div>
<div class="line"><span class="lineno">  530</span>            <span class="keywordtype">int</span> c1 = gmsh::model::geo::addCurveLoop({l1, s2, l2, s1});</div>
<div class="line"><span class="lineno">  531</span>            <span class="keywordtype">int</span> pl1 = gmsh::model::geo::addPlaneSurface({c1});</div>
<div class="line"><span class="lineno">  532</span> </div>
<div class="line"><span class="lineno">  533</span>            gmsh::model::geo::synchronize();</div>
<div class="line"><span class="lineno">  534</span>            <span class="comment">// Add the line that will contain a displacement BC and the center line</span></div>
<div class="line"><span class="lineno">  535</span>            center_lines[branch] = std::pair(l1, std::pair(points[0], points[3]));</div>
<div class="line"><span class="lineno">  536</span>            line_tags[branch] = l2;</div>
<div class="line"><span class="lineno">  537</span>            surface_tags[branch] = pl1;</div>
<div class="line"><span class="lineno">  538</span>        }</div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span>        <span class="comment">// We now need to add the center part of the mesh using the initialized values in center_lines, but we must</span></div>
<div class="line"><span class="lineno">  541</span>        <span class="comment">// determine the correct orientation</span></div>
<div class="line"><span class="lineno">  542</span>        std::vector&lt;int&gt; lines(parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>);</div>
<div class="line"><span class="lineno">  543</span>        lines[0] = center_lines[0].first;</div>
<div class="line"><span class="lineno">  544</span> </div>
<div class="line"><span class="lineno">  545</span>        <span class="keywordtype">int</span> next_point = center_lines[0].second.second;</div>
<div class="line"><span class="lineno">  546</span>        <span class="keywordtype">int</span> current_line = lines[0];</div>
<div class="line"><span class="lineno">  547</span> </div>
<div class="line"><span class="lineno">  548</span>        <span class="comment">// Iterate through the lines in centerLines</span></div>
<div class="line"><span class="lineno">  549</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> line = 1; line &lt; parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; ++line) {</div>
<div class="line"><span class="lineno">  550</span>            <span class="comment">// See which line has the point we&#39;re interested in, and we add this to lines using the correct orientation</span></div>
<div class="line"><span class="lineno">  551</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;center_line : center_lines) {</div>
<div class="line"><span class="lineno">  552</span>                <span class="keywordflow">if</span> (center_line.first == current_line) {</div>
<div class="line"><span class="lineno">  553</span>                    <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  554</span>                }</div>
<div class="line"><span class="lineno">  555</span>                <span class="keywordflow">if</span> (center_line.second.first == next_point) {</div>
<div class="line"><span class="lineno">  556</span>                    lines[line] = center_line.first;</div>
<div class="line"><span class="lineno">  557</span>                    current_line = center_line.first;</div>
<div class="line"><span class="lineno">  558</span>                    next_point = center_line.second.second;</div>
<div class="line"><span class="lineno">  559</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  560</span>                }</div>
<div class="line"><span class="lineno">  561</span>                <span class="keywordflow">if</span> (center_line.second.second == next_point) {</div>
<div class="line"><span class="lineno">  562</span>                    lines[line] = -center_line.first;</div>
<div class="line"><span class="lineno">  563</span>                    current_line = center_line.first;</div>
<div class="line"><span class="lineno">  564</span>                    next_point = center_line.second.first;</div>
<div class="line"><span class="lineno">  565</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  566</span>                }</div>
<div class="line"><span class="lineno">  567</span>            }</div>
<div class="line"><span class="lineno">  568</span>        }</div>
<div class="line"><span class="lineno">  569</span>        <span class="comment">// Add the curve loop and the surface</span></div>
<div class="line"><span class="lineno">  570</span>        <span class="keywordtype">int</span> c2 = gmsh::model::geo::addCurveLoop(lines);</div>
<div class="line"><span class="lineno">  571</span>        <span class="keywordtype">int</span> pl1 = gmsh::model::geo::addPlaneSurface({c2});</div>
<div class="line"><span class="lineno">  572</span> </div>
<div class="line"><span class="lineno">  573</span>        gmsh::model::geo::synchronize();</div>
<div class="line"><span class="lineno">  574</span>        surface_tags[parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>] = pl1;</div>
<div class="line"><span class="lineno">  575</span> </div>
<div class="line"><span class="lineno">  576</span>        <span class="comment">// Add the physical groups using our line_tags and surface_tags vectors</span></div>
<div class="line"><span class="lineno">  577</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> branch = 0; branch &lt; parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; ++branch) {</div>
<div class="line"><span class="lineno">  578</span>            gmsh::model::addPhysicalGroup(1, {line_tags[branch]}, branch + 1);</div>
<div class="line"><span class="lineno">  579</span>        }</div>
<div class="line"><span class="lineno">  580</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> branch = 0; branch &lt;= parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; ++branch) {</div>
<div class="line"><span class="lineno">  581</span>            gmsh::model::addPhysicalGroup(2, {surface_tags[branch]}, parametrization.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a> + branch + 1);</div>
<div class="line"><span class="lineno">  582</span>        }</div>
<div class="line"><span class="lineno">  583</span>    }</div>
<div class="line"><span class="lineno">  584</span> </div>
<div class="line"><span class="lineno">  585</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  586</span>        LF_ASSERT_MSG(<span class="keyword">false</span>, <span class="stringliteral">&quot;Parametrization was a number of branches other than 1 or 3+, invalid&quot;</span>);</div>
<div class="line"><span class="lineno">  587</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  588</span>    }</div>
<div class="line"><span class="lineno">  589</span> </div>
<div class="line"><span class="lineno">  590</span>    <span class="comment">// Create the paths for the .geo and .msh files</span></div>
<div class="line"><span class="lineno">  591</span>    <span class="keyword">const</span> std::filesystem::path here = __FILE__;</div>
<div class="line"><span class="lineno">  592</span>    <span class="keyword">auto</span> working_dir = here.parent_path().parent_path();</div>
<div class="line"><span class="lineno">  593</span>    <span class="keyword">auto</span> geo_path = working_dir / <span class="stringliteral">&quot;geometries&quot;</span> / (mesh_name + <span class="stringliteral">&quot;.geo_unrolled&quot;</span>);</div>
<div class="line"><span class="lineno">  594</span>    <span class="keyword">auto</span> mesh_path = working_dir / <span class="stringliteral">&quot;meshes&quot;</span> / (mesh_name + <span class="stringliteral">&quot;.msh&quot;</span>);</div>
<div class="line"><span class="lineno">  595</span> </div>
<div class="line"><span class="lineno">  596</span>    <span class="comment">// Set the order to 2 if desired, else default is order 1</span></div>
<div class="line"><span class="lineno">  597</span>    <span class="keywordflow">if</span> (order == 2) gmsh::option::setNumber(<span class="stringliteral">&quot;Mesh.ElementOrder&quot;</span>, 2);</div>
<div class="line"><span class="lineno">  598</span> </div>
<div class="line"><span class="lineno">  599</span>    <span class="comment">// Ensure the outputted mesh version is Version 2 ASCII</span></div>
<div class="line"><span class="lineno">  600</span>    gmsh::option::setNumber(<span class="stringliteral">&quot;Mesh.MshFileVersion&quot;</span>, 2.2);</div>
<div class="line"><span class="lineno">  601</span>    gmsh::option::setNumber(<span class="stringliteral">&quot;Mesh.Binary&quot;</span>, 0);</div>
<div class="line"><span class="lineno">  602</span> </div>
<div class="line"><span class="lineno">  603</span>    gmsh::model::mesh::generate(2);</div>
<div class="line"><span class="lineno">  604</span> </div>
<div class="line"><span class="lineno">  605</span>    <span class="comment">// Write the .geo file, containing only geometric entities</span></div>
<div class="line"><span class="lineno">  606</span>    gmsh::write(geo_path.string());</div>
<div class="line"><span class="lineno">  607</span> </div>
<div class="line"><span class="lineno">  608</span>    <span class="comment">// Write the .msh file and finalize</span></div>
<div class="line"><span class="lineno">  609</span>    gmsh::write(mesh_path.string());</div>
<div class="line"><span class="lineno">  610</span>    gmsh::finalize();</div>
<div class="line"><span class="lineno">  611</span>}</div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a07f7f735900d22b64eb9024139a1f18e"><div class="ttname"><a href="#a07f7f735900d22b64eb9024139a1f18e">MeshParametrization::connectionPoints</a></div><div class="ttdeci">std::optional&lt; Eigen::VectorXi &gt; connectionPoints(MeshParametrizationData &amp;multiBranch)</div><div class="ttdoc">Identifies connection points in multi-branch parametrization.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:304</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae691f88d5d85e37e64babb2ed0a7a07e" name="ae691f88d5d85e37e64babb2ed0a7a07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae691f88d5d85e37e64babb2ed0a7a07e">&#9670;&#160;</a></span>intersectionBranches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshParametrization::intersectionBranches </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>poly_points_1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>poly_points_2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for intersections between nearby branches. </p>
<p>Does not include overlap at end points of the branch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly_points_1</td><td>Polynomial points of first branch </td></tr>
    <tr><td class="paramname">poly_points_2</td><td>Polynomial points of second branch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if branches intersect </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  165</span>                                                                                                                     {</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span>    <span class="comment">// If the poly_points do not satisfy our shape requirements, we immediately return false</span></div>
<div class="line"><span class="lineno">  168</span>    <span class="keywordflow">if</span> (poly_points_1.rows() != 4 or poly_points_1.cols() != 3 or poly_points_2.rows() != 4</div>
<div class="line"><span class="lineno">  169</span>        or poly_points_2.cols() != 3) {</div>
<div class="line"><span class="lineno">  170</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  171</span>    }</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span>    <span class="comment">// I have 12 total line segments, and I need to check if any of the first 6 intersect with any of the other 6</span></div>
<div class="line"><span class="lineno">  174</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 6; ++i) {</div>
<div class="line"><span class="lineno">  175</span>        Eigen::Vector2d a;</div>
<div class="line"><span class="lineno">  176</span>        Eigen::Vector2d b;</div>
<div class="line"><span class="lineno">  177</span> </div>
<div class="line"><span class="lineno">  178</span>        <span class="comment">// In the first 4 iterations, we check the spline lines, and in the last 2 we check the straight lines</span></div>
<div class="line"><span class="lineno">  179</span>        <span class="keywordflow">if</span> (i &lt; 4) {</div>
<div class="line"><span class="lineno">  180</span>            a = poly_points_1.block&lt;2, 1&gt;((i / 2) * 2, i % 2);</div>
<div class="line"><span class="lineno">  181</span>            b = poly_points_1.block&lt;2, 1&gt;((i / 2) * 2, i % 2 + 1);</div>
<div class="line"><span class="lineno">  182</span>        }</div>
<div class="line"><span class="lineno">  183</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  184</span>            a = poly_points_1.block&lt;2, 1&gt;(0, (i - 4) * 2);</div>
<div class="line"><span class="lineno">  185</span>            b = poly_points_1.block&lt;2, 1&gt;(2, (i - 4) * 2);</div>
<div class="line"><span class="lineno">  186</span>        }</div>
<div class="line"><span class="lineno">  187</span> </div>
<div class="line"><span class="lineno">  188</span>        <span class="comment">// Iterate through the 4 spline portions of the second parametrization&#39;s points</span></div>
<div class="line"><span class="lineno">  189</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 4; ++j) {</div>
<div class="line"><span class="lineno">  190</span>            Eigen::Vector2d c = poly_points_2.block&lt;2, 1&gt;((j / 2) * 2, j % 2);</div>
<div class="line"><span class="lineno">  191</span>            Eigen::Vector2d d = poly_points_2.block&lt;2, 1&gt;((j / 2) * 2, j % 2 + 1);</div>
<div class="line"><span class="lineno">  192</span> </div>
<div class="line"><span class="lineno">  193</span>            <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> lines (a, b, c, d);</div>
<div class="line"><span class="lineno">  194</span> </div>
<div class="line"><span class="lineno">  195</span>            <span class="comment">// Since we can use this method for multi-branches, we don&#39;t include the ends for intersection</span></div>
<div class="line"><span class="lineno">  196</span>            <span class="keywordflow">if</span> (lines.linesIntersectWithoutEnds()) {</div>
<div class="line"><span class="lineno">  197</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  198</span>            }</div>
<div class="line"><span class="lineno">  199</span>        }</div>
<div class="line"><span class="lineno">  200</span> </div>
<div class="line"><span class="lineno">  201</span>        <span class="comment">// Iterate through the 2 line portions of the second parametrization&#39;s points</span></div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 2; ++j) {</div>
<div class="line"><span class="lineno">  203</span>            Eigen::Vector2d c = poly_points_2.block&lt;2, 1&gt;(0, j * 2);</div>
<div class="line"><span class="lineno">  204</span>            Eigen::Vector2d d = poly_points_2.block&lt;2, 1&gt;(2, j * 2);</div>
<div class="line"><span class="lineno">  205</span> </div>
<div class="line"><span class="lineno">  206</span>            <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> lines(a, b, c, d);</div>
<div class="line"><span class="lineno">  207</span> </div>
<div class="line"><span class="lineno">  208</span>            <span class="comment">// Since we can use this method for multi-branches, we don&#39;t include the ends for intersection</span></div>
<div class="line"><span class="lineno">  209</span>            <span class="keywordflow">if</span> (lines.linesIntersectWithoutEnds()) {</div>
<div class="line"><span class="lineno">  210</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  211</span>            }</div>
<div class="line"><span class="lineno">  212</span>        }</div>
<div class="line"><span class="lineno">  213</span>    }</div>
<div class="line"><span class="lineno">  214</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  215</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a007b5963525a05190de9860a14bfe526" name="a007b5963525a05190de9860a14bfe526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007b5963525a05190de9860a14bfe526">&#9670;&#160;</a></span>intersectionVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshParametrization::intersectionVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for intersections between vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Mesh parametrization data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if no intersections found </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  135</span>                                                                            {</div>
<div class="line"><span class="lineno">  136</span> </div>
<div class="line"><span class="lineno">  137</span>    Eigen::MatrixXd poly_points = <a class="code hl_function" href="#a7e2be81d0d3a5153798423ce3a58e3a1">polynomialPoints</a>(param);</div>
<div class="line"><span class="lineno">  138</span> </div>
<div class="line"><span class="lineno">  139</span>    <span class="comment">// Iterate through each branch, and check them individually</span></div>
<div class="line"><span class="lineno">  140</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> branch = 0; branch &lt; param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; ++branch) {</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span>        <span class="comment">// Initialize the 6 points making up this branch so we can easily create lines with them</span></div>
<div class="line"><span class="lineno">  143</span>        Eigen::Vector2d a = poly_points.block&lt;2, 1&gt;(branch * 4, 0);</div>
<div class="line"><span class="lineno">  144</span>        Eigen::Vector2d b = poly_points.block&lt;2, 1&gt;(branch * 4, 1);</div>
<div class="line"><span class="lineno">  145</span>        Eigen::Vector2d c = poly_points.block&lt;2, 1&gt;(branch * 4, 2);</div>
<div class="line"><span class="lineno">  146</span>        Eigen::Vector2d d = poly_points.block&lt;2, 1&gt;(branch * 4 + 2, 0);</div>
<div class="line"><span class="lineno">  147</span>        Eigen::Vector2d e = poly_points.block&lt;2, 1&gt;(branch * 4 + 2, 1);</div>
<div class="line"><span class="lineno">  148</span>        Eigen::Vector2d f = poly_points.block&lt;2, 1&gt;(branch * 4 + 2, 2);</div>
<div class="line"><span class="lineno">  149</span> </div>
<div class="line"><span class="lineno">  150</span>        <span class="comment">// Initialize the 3 choose 2 number of lines possible, each representing the &quot;vectors&quot;</span></div>
<div class="line"><span class="lineno">  151</span>        <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> line1_2 (a, d, b, e);</div>
<div class="line"><span class="lineno">  152</span>        <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> line1_3 (a, d, c, f);</div>
<div class="line"><span class="lineno">  153</span>        <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> line2_3 (b, e, c, f);</div>
<div class="line"><span class="lineno">  154</span> </div>
<div class="line"><span class="lineno">  155</span>        <span class="comment">// If any of the lines intersect we return false</span></div>
<div class="line"><span class="lineno">  156</span>        <span class="keywordflow">if</span> (line1_2.linesIntersect() or line1_3.linesIntersect() or line2_3.linesIntersect()) {</div>
<div class="line"><span class="lineno">  157</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  158</span>        }</div>
<div class="line"><span class="lineno">  159</span>    }</div>
<div class="line"><span class="lineno">  160</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  161</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a04f329e14a41574a8b4a5a8eafd152e2" name="a04f329e14a41574a8b4a5a8eafd152e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f329e14a41574a8b4a5a8eafd152e2">&#9670;&#160;</a></span>meshParamValidator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshParametrization::meshParamValidator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates complete mesh parametrization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Mesh parametrization to validate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if parametrization is valid </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  382</span>                                                                           {</div>
<div class="line"><span class="lineno">  383</span> </div>
<div class="line"><span class="lineno">  384</span>    <span class="comment">// Check that widths are all positive and vectors have non-zero lengths</span></div>
<div class="line"><span class="lineno">  385</span>    <span class="keywordflow">if</span> (!(param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adc3fe2ea07198c41c220ac5fc42f0117">widths</a>.array() &gt; 1e-7).all()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  386</span>    <span class="keywordflow">if</span> (!<a class="code hl_function" href="#a2f9448824e6524bc895d8bbaec536c19">checkVectorLengths</a>(param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#a4e3e56c925463080a2a16eafecd61158">vectors</a>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  387</span> </div>
<div class="line"><span class="lineno">  388</span>    <span class="comment">// For a single branch, we ensure the angles of vectors are not too steep, the vectors don&#39;t intersect, and that</span></div>
<div class="line"><span class="lineno">  389</span>    <span class="comment">// the branch doesn&#39;t intersect with itself</span></div>
<div class="line"><span class="lineno">  390</span>    <span class="keywordflow">if</span> (param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a> == 1) {</div>
<div class="line"><span class="lineno">  391</span>        Eigen::MatrixXd poly_points = <a class="code hl_function" href="#a7e2be81d0d3a5153798423ce3a58e3a1">polynomialPoints</a>(param);</div>
<div class="line"><span class="lineno">  392</span> </div>
<div class="line"><span class="lineno">  393</span>        <span class="comment">// If any of the validating functions return false, then the parametrization is invalid and we return false</span></div>
<div class="line"><span class="lineno">  394</span>        <span class="keywordflow">if</span> (!(<a class="code hl_function" href="#a352bc7821092c4f9a53dfeb16e6c02be">angleVectors</a>(param) and <a class="code hl_function" href="#a007b5963525a05190de9860a14bfe526">intersectionVectors</a>(param) and <a class="code hl_function" href="#af7f77b882649bfb2df66b607181e28e5">selfIntersection</a>(poly_points))) {</div>
<div class="line"><span class="lineno">  395</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  396</span>        }</div>
<div class="line"><span class="lineno">  397</span>    }</div>
<div class="line"><span class="lineno">  398</span> </div>
<div class="line"><span class="lineno">  399</span>    <span class="comment">// In the multi-branch case, we ensure the above for all single branches, make sure they form a center, and that</span></div>
<div class="line"><span class="lineno">  400</span>    <span class="comment">// the multiple branches don&#39;t intersect each other</span></div>
<div class="line"><span class="lineno">  401</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a> &gt;= 3) {</div>
<div class="line"><span class="lineno">  402</span>        <span class="comment">// We first call connectionPoints to make sure that the points correctly overlap, otherwise return false</span></div>
<div class="line"><span class="lineno">  403</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="#a07f7f735900d22b64eb9024139a1f18e">connectionPoints</a>(param) == std::nullopt) {</div>
<div class="line"><span class="lineno">  404</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  405</span>        }</div>
<div class="line"><span class="lineno">  406</span> </div>
<div class="line"><span class="lineno">  407</span>        Eigen::MatrixXd poly_points = <a class="code hl_function" href="#a7e2be81d0d3a5153798423ce3a58e3a1">polynomialPoints</a>(param);</div>
<div class="line"><span class="lineno">  408</span> </div>
<div class="line"><span class="lineno">  409</span>        <span class="comment">// We now check each branch individually using the above helper methods to make sure they are all valid</span></div>
<div class="line"><span class="lineno">  410</span>        <span class="keywordflow">if</span> (!(<a class="code hl_function" href="#a352bc7821092c4f9a53dfeb16e6c02be">angleVectors</a>(param) and <a class="code hl_function" href="#a007b5963525a05190de9860a14bfe526">intersectionVectors</a>(param) and <a class="code hl_function" href="#af7f77b882649bfb2df66b607181e28e5">selfIntersection</a>(poly_points))) {</div>
<div class="line"><span class="lineno">  411</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  412</span>        }</div>
<div class="line"><span class="lineno">  413</span> </div>
<div class="line"><span class="lineno">  414</span>        <span class="comment">// We now make sure that none of the branches overlap with any of the others, not counting their center points</span></div>
<div class="line"><span class="lineno">  415</span>        <span class="comment">// overlapping, if any intersect, we return false, this ensures that all branches point outward</span></div>
<div class="line"><span class="lineno">  416</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; ++i) {</div>
<div class="line"><span class="lineno">  417</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i + 1; j &lt; param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; ++j) {</div>
<div class="line"><span class="lineno">  418</span>                <span class="keywordflow">if</span>(!<a class="code hl_function" href="#ae691f88d5d85e37e64babb2ed0a7a07e">intersectionBranches</a>(poly_points.block&lt;4, 3&gt;(i * 4, 0),</div>
<div class="line"><span class="lineno">  419</span>                    poly_points.block&lt;4, 3&gt;(j * 4, 0))) {</div>
<div class="line"><span class="lineno">  420</span>                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  421</span>                }</div>
<div class="line"><span class="lineno">  422</span>            }</div>
<div class="line"><span class="lineno">  423</span>        }</div>
<div class="line"><span class="lineno">  424</span>    }</div>
<div class="line"><span class="lineno">  425</span> </div>
<div class="line"><span class="lineno">  426</span>    <span class="comment">// A center can&#39;t exist with just 2 branches, and any other number outside 1 or 3+ doesn&#39;t make sense</span></div>
<div class="line"><span class="lineno">  427</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  428</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  429</span>    }</div>
<div class="line"><span class="lineno">  430</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  431</span>}</div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a007b5963525a05190de9860a14bfe526"><div class="ttname"><a href="#a007b5963525a05190de9860a14bfe526">MeshParametrization::intersectionVectors</a></div><div class="ttdeci">bool intersectionVectors(MeshParametrizationData &amp;param)</div><div class="ttdoc">Checks for intersections between vectors.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:135</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a2f9448824e6524bc895d8bbaec536c19"><div class="ttname"><a href="#a2f9448824e6524bc895d8bbaec536c19">MeshParametrization::checkVectorLengths</a></div><div class="ttdeci">bool checkVectorLengths(const Eigen::MatrixXd &amp;vectors)</div><div class="ttdoc">Validates vector lengths in direction matrix.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:12</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a352bc7821092c4f9a53dfeb16e6c02be"><div class="ttname"><a href="#a352bc7821092c4f9a53dfeb16e6c02be">MeshParametrization::angleVectors</a></div><div class="ttdeci">bool angleVectors(MeshParametrizationData &amp;param)</div><div class="ttdoc">Checks angles between branch vectors.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:105</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_ae691f88d5d85e37e64babb2ed0a7a07e"><div class="ttname"><a href="#ae691f88d5d85e37e64babb2ed0a7a07e">MeshParametrization::intersectionBranches</a></div><div class="ttdeci">bool intersectionBranches(const Eigen::MatrixXd &amp;poly_points_1, const Eigen::MatrixXd &amp;poly_points_2)</div><div class="ttdoc">Checks for intersections between nearby branches.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:165</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_af7f77b882649bfb2df66b607181e28e5"><div class="ttname"><a href="#af7f77b882649bfb2df66b607181e28e5">MeshParametrization::selfIntersection</a></div><div class="ttdeci">bool selfIntersection(const Eigen::MatrixXd &amp;poly_points)</div><div class="ttdoc">Checks for self-intersections in branch.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:219</div></div>
<div class="ttc" id="astruct_mesh_parametrization_data_html_a4e3e56c925463080a2a16eafecd61158"><div class="ttname"><a href="struct_mesh_parametrization_data.html#a4e3e56c925463080a2a16eafecd61158">MeshParametrizationData::vectors</a></div><div class="ttdeci">Eigen::MatrixXd vectors</div><div class="ttdoc">Matrix of direction vectors (2*numBranches × 3)</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:76</div></div>
<div class="ttc" id="astruct_mesh_parametrization_data_html_adc3fe2ea07198c41c220ac5fc42f0117"><div class="ttname"><a href="struct_mesh_parametrization_data.html#adc3fe2ea07198c41c220ac5fc42f0117">MeshParametrizationData::widths</a></div><div class="ttdeci">Eigen::MatrixXd widths</div><div class="ttdoc">Matrix of branch widths (numBranches × 3)</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:74</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af570cae2ac6a402af20d6fb7faeecec1" name="af570cae2ac6a402af20d6fb7faeecec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af570cae2ac6a402af20d6fb7faeecec1">&#9670;&#160;</a></span>normalizeVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshParametrization::normalizeVectors </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>vectors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes direction vectors to unit length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectors</td><td>Matrix of direction vectors (modified in-place) </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   28</span>                                                                  {</div>
<div class="line"><span class="lineno">   29</span>    LF_ASSERT_MSG(vectors.rows() % 2 == 0 and vectors.rows() != 0 and vectors.cols() == 3,</div>
<div class="line"><span class="lineno">   30</span>                  <span class="stringliteral">&quot;Shape of vectors does not allow for a correct parametrization in call to normalizeVectors&quot;</span>);</div>
<div class="line"><span class="lineno">   31</span> </div>
<div class="line"><span class="lineno">   32</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> num_branches = int(vectors.rows()) / 2;</div>
<div class="line"><span class="lineno">   33</span> </div>
<div class="line"><span class="lineno">   34</span>    <span class="comment">// Iterate through all branches</span></div>
<div class="line"><span class="lineno">   35</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> branch = 0; branch &lt; num_branches; ++branch) {</div>
<div class="line"><span class="lineno">   36</span>        <span class="keywordtype">double</span> eps = 1e-7;</div>
<div class="line"><span class="lineno">   37</span>        <span class="comment">// Calculate norms</span></div>
<div class="line"><span class="lineno">   38</span>        <span class="keyword">auto</span> norms = vectors.block&lt;2, 3&gt;(branch * 2, 0).colwise().norm();</div>
<div class="line"><span class="lineno">   39</span> </div>
<div class="line"><span class="lineno">   40</span>        LF_ASSERT_MSG((norms.array() &gt;= eps).all(), <span class="stringliteral">&quot;Norm of vectors approaching zero in call to NormalizeVectors&quot;</span>);</div>
<div class="line"><span class="lineno">   41</span> </div>
<div class="line"><span class="lineno">   42</span>        <span class="comment">// Make each set of vectors unit vectors</span></div>
<div class="line"><span class="lineno">   43</span>        vectors.block&lt;2, 3&gt;(branch * 2, 0) = vectors.block&lt;2, 3&gt;(branch * 2, 0).array().rowwise() / norms.array();</div>
<div class="line"><span class="lineno">   44</span>    }</div>
<div class="line"><span class="lineno">   45</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a30780085192c00fff5bcb5e554dccff5" name="a30780085192c00fff5bcb5e554dccff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30780085192c00fff5bcb5e554dccff5">&#9670;&#160;</a></span>pointToParametrization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> MeshParametrization::pointToParametrization </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>poly_points</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts polynomial points to mesh parametrization. </p>
<p>These polynomial points would be identical to the points field of a <a class="el" href="struct_parametrization_points.html">ParametrizationPoints</a> object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly_points</td><td>Matrix of polynomial points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mesh parametrization data </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  258</span>                                                                                                    {</div>
<div class="line"><span class="lineno">  259</span> </div>
<div class="line"><span class="lineno">  260</span>    <span class="comment">// Declare necessary objects for parametrization</span></div>
<div class="line"><span class="lineno">  261</span>    <span class="keywordtype">int</span> num_branches = poly_points.rows() / 4;</div>
<div class="line"><span class="lineno">  262</span>    Eigen::MatrixXd widths(num_branches, 3);</div>
<div class="line"><span class="lineno">  263</span>    Eigen::MatrixXd terminals(num_branches * 2, 3);</div>
<div class="line"><span class="lineno">  264</span>    Eigen::MatrixXd vectors(num_branches * 2, 3);</div>
<div class="line"><span class="lineno">  265</span> </div>
<div class="line"><span class="lineno">  266</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_branches; ++i) {</div>
<div class="line"><span class="lineno">  267</span>        widths(i, 0) = (poly_points.block&lt;2, 1&gt;(4 * i, 0) -</div>
<div class="line"><span class="lineno">  268</span>            poly_points.block&lt;2, 1&gt;(4 * i + 2, 0)).norm();</div>
<div class="line"><span class="lineno">  269</span>        widths(i, 1) = (poly_points.block&lt;2, 1&gt;(4 * i, 1) -</div>
<div class="line"><span class="lineno">  270</span>        poly_points.block&lt;2, 1&gt;(4 * i + 2, 1)).norm();</div>
<div class="line"><span class="lineno">  271</span>        widths(i, 2) = (poly_points.block&lt;2, 1&gt;(4 * i, 2) -</div>
<div class="line"><span class="lineno">  272</span>            poly_points.block&lt;2, 1&gt;(4 * i + 2, 2)).norm();</div>
<div class="line"><span class="lineno">  273</span> </div>
<div class="line"><span class="lineno">  274</span>        terminals.block&lt;2, 1&gt;(2 * i, 0) = (poly_points.block&lt;2, 1&gt;(4 * i, 0) +</div>
<div class="line"><span class="lineno">  275</span>            poly_points.block&lt;2, 1&gt;(4 * i + 2, 0)) / 2;</div>
<div class="line"><span class="lineno">  276</span>        terminals.block&lt;2, 1&gt;(2 * i, 1) = (poly_points.block&lt;2, 1&gt;(4 * i, 1) +</div>
<div class="line"><span class="lineno">  277</span>            poly_points.block&lt;2, 1&gt;(4 * i + 2, 1)) / 2;</div>
<div class="line"><span class="lineno">  278</span>        terminals.block&lt;2, 1&gt;(2 * i, 2) = (poly_points.block&lt;2, 1&gt;(4 * i, 2) +</div>
<div class="line"><span class="lineno">  279</span>            poly_points.block&lt;2, 1&gt;(4 * i + 2, 2)) / 2;</div>
<div class="line"><span class="lineno">  280</span> </div>
<div class="line"><span class="lineno">  281</span>        <span class="comment">// We do top minus bottom here to mimic the way that polynomial points calculates its points so that the</span></div>
<div class="line"><span class="lineno">  282</span>        <span class="comment">// mappings match up</span></div>
<div class="line"><span class="lineno">  283</span>        vectors.block&lt;2, 1&gt;(2 * i, 0) = (poly_points.block&lt;2, 1&gt;(4 * i, 0) -</div>
<div class="line"><span class="lineno">  284</span>            poly_points.block&lt;2, 1&gt;(4 * i + 2, 0)).normalized();</div>
<div class="line"><span class="lineno">  285</span>        vectors.block&lt;2, 1&gt;(2 * i, 1) = (poly_points.block&lt;2, 1&gt;(4 * i, 1) -</div>
<div class="line"><span class="lineno">  286</span>        poly_points.block&lt;2, 1&gt;(4 * i + 2, 1)).normalized();</div>
<div class="line"><span class="lineno">  287</span>        vectors.block&lt;2, 1&gt;(2 * i, 2) = (poly_points.block&lt;2, 1&gt;(4 * i, 2) -</div>
<div class="line"><span class="lineno">  288</span>            poly_points.block&lt;2, 1&gt;(4 * i + 2, 2)).normalized();</div>
<div class="line"><span class="lineno">  289</span>    }</div>
<div class="line"><span class="lineno">  290</span> </div>
<div class="line"><span class="lineno">  291</span>    <a class="code hl_struct" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> parametrization {num_branches, widths, terminals, vectors};</div>
<div class="line"><span class="lineno">  292</span>    LF_ASSERT_MSG(<a class="code hl_function" href="#a04f329e14a41574a8b4a5a8eafd152e2">meshParamValidator</a>(parametrization), <span class="stringliteral">&quot;Invalid polynomial points sent to the function &quot;</span></div>
<div class="line"><span class="lineno">  293</span>    <span class="stringliteral">&quot;pointToParametrization, with values \n&quot;</span> &lt;&lt; poly_points);</div>
<div class="line"><span class="lineno">  294</span>    <span class="keywordflow">return</span> parametrization;</div>
<div class="line"><span class="lineno">  295</span>}</div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a04f329e14a41574a8b4a5a8eafd152e2"><div class="ttname"><a href="#a04f329e14a41574a8b4a5a8eafd152e2">MeshParametrization::meshParamValidator</a></div><div class="ttdeci">bool meshParamValidator(MeshParametrizationData &amp;param)</div><div class="ttdoc">Validates complete mesh parametrization.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:382</div></div>
<div class="ttc" id="astruct_mesh_parametrization_data_html"><div class="ttname"><a href="struct_mesh_parametrization_data.html">MeshParametrizationData</a></div><div class="ttdoc">Container for mesh parametrization geometric data.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:72</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e2be81d0d3a5153798423ce3a58e3a1" name="a7e2be81d0d3a5153798423ce3a58e3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2be81d0d3a5153798423ce3a58e3a1">&#9670;&#160;</a></span>polynomialPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd MeshParametrization::polynomialPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates polynomial points from parametrization. </p>
<p>uses <a class="el" href="#af570cae2ac6a402af20d6fb7faeecec1">normalizeVectors</a> to ensure normalized vectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Mesh parametrization data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of polynomial points, equivalent to points field of <a class="el" href="struct_parametrization_points.html">ParametrizationPoints</a> </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   53</span>                                                                                   {</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>    <span class="comment">// Normalize the vectors, this checks to make sure that vectors has an acceptable shape</span></div>
<div class="line"><span class="lineno">   56</span>    <a class="code hl_function" href="#af570cae2ac6a402af20d6fb7faeecec1">normalizeVectors</a>(param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#a4e3e56c925463080a2a16eafecd61158">vectors</a>);</div>
<div class="line"><span class="lineno">   57</span>    Eigen::MatrixXd poly_points(param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a> * 4, 3);</div>
<div class="line"><span class="lineno">   58</span>    poly_points.setZero();</div>
<div class="line"><span class="lineno">   59</span> </div>
<div class="line"><span class="lineno">   60</span>    <span class="comment">// Initialize the default polynomial points for each branch, note these are unordered</span></div>
<div class="line"><span class="lineno">   61</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> branch = 0; branch &lt; param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; branch++) {</div>
<div class="line"><span class="lineno">   62</span> </div>
<div class="line"><span class="lineno">   63</span>        <span class="comment">// Initialize the polynomial points for each of the 3 terminals</span></div>
<div class="line"><span class="lineno">   64</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)</div>
<div class="line"><span class="lineno">   65</span>        {</div>
<div class="line"><span class="lineno">   66</span>            <span class="comment">//Initialize the points on the &quot;first side&quot; of the branch</span></div>
<div class="line"><span class="lineno">   67</span>            poly_points.block&lt;2, 1&gt;(4 * branch, i) = param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#a6757fe1055d22523c940926dfe594bd8">terminals</a>.block&lt;2, 1&gt;(2 * branch, i)</div>
<div class="line"><span class="lineno">   68</span>                                                     + param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adc3fe2ea07198c41c220ac5fc42f0117">widths</a>(branch, i) * param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#a4e3e56c925463080a2a16eafecd61158">vectors</a>.block&lt;2, 1&gt;(2 * branch, i) / 2;</div>
<div class="line"><span class="lineno">   69</span> </div>
<div class="line"><span class="lineno">   70</span>            <span class="comment">//Initialize the points on the &quot;second side&quot; of the branch</span></div>
<div class="line"><span class="lineno">   71</span>            poly_points.block&lt;2, 1&gt;(4 * branch + 2, i) = param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#a6757fe1055d22523c940926dfe594bd8">terminals</a>.block&lt;2, 1&gt;(2 * branch, i)</div>
<div class="line"><span class="lineno">   72</span>                                                         - param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adc3fe2ea07198c41c220ac5fc42f0117">widths</a>(branch, i) * param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#a4e3e56c925463080a2a16eafecd61158">vectors</a>.block&lt;2, 1&gt;(2 * branch, i) / 2;</div>
<div class="line"><span class="lineno">   73</span>        }</div>
<div class="line"><span class="lineno">   74</span>    }</div>
<div class="line"><span class="lineno">   75</span> </div>
<div class="line"><span class="lineno">   76</span>    <span class="comment">// This for loop goes through and makes sure that the polynomial points are ordered correctly for each branch,</span></div>
<div class="line"><span class="lineno">   77</span>    <span class="comment">// avoiding overlapping polynomials</span></div>
<div class="line"><span class="lineno">   78</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> branch = 0; branch &lt; param.<a class="code hl_variable" href="struct_mesh_parametrization_data.html#adda268017d91178d76eccae27c55ab01">numBranches</a>; branch++) {</div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span>        <span class="comment">// For each part of the polynomial, we initialize straight lines from the points, and if they intersect,</span></div>
<div class="line"><span class="lineno">   81</span>        <span class="comment">// we switch the points</span></div>
<div class="line"><span class="lineno">   82</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i)</div>
<div class="line"><span class="lineno">   83</span>        {</div>
<div class="line"><span class="lineno">   84</span>            Eigen::Vector2d a = poly_points.block&lt;2, 1&gt;(4 * branch, i);</div>
<div class="line"><span class="lineno">   85</span>            Eigen::Vector2d b = poly_points.block&lt;2, 1&gt;(4 * branch, i + 1);</div>
<div class="line"><span class="lineno">   86</span>            Eigen::Vector2d c = poly_points.block&lt;2, 1&gt;(4 * branch + 2, i);</div>
<div class="line"><span class="lineno">   87</span>            Eigen::Vector2d d = poly_points.block&lt;2, 1&gt;(4 * branch + 2, i + 1);</div>
<div class="line"><span class="lineno">   88</span> </div>
<div class="line"><span class="lineno">   89</span>            <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> poly_lines (a, b, c, d);</div>
<div class="line"><span class="lineno">   90</span> </div>
<div class="line"><span class="lineno">   91</span>            <span class="comment">// If they intersect, we swap the points at column i + 1, since for our basis we assume the first</span></div>
<div class="line"><span class="lineno">   92</span>            <span class="comment">// terminal is correct</span></div>
<div class="line"><span class="lineno">   93</span>            <span class="keywordflow">if</span> (poly_lines.linesIntersect())</div>
<div class="line"><span class="lineno">   94</span>            {</div>
<div class="line"><span class="lineno">   95</span>                poly_points.block&lt;2, 1&gt;(4 * branch, i + 1).swap(</div>
<div class="line"><span class="lineno">   96</span>                    poly_points.block&lt;2, 1&gt;(4 * branch + 2, i + 1));</div>
<div class="line"><span class="lineno">   97</span>            }</div>
<div class="line"><span class="lineno">   98</span>        }</div>
<div class="line"><span class="lineno">   99</span>    }</div>
<div class="line"><span class="lineno">  100</span>    <span class="keywordflow">return</span> poly_points;</div>
<div class="line"><span class="lineno">  101</span>}</div>
<div class="ttc" id="anamespace_mesh_parametrization_html_af570cae2ac6a402af20d6fb7faeecec1"><div class="ttname"><a href="#af570cae2ac6a402af20d6fb7faeecec1">MeshParametrization::normalizeVectors</a></div><div class="ttdeci">void normalizeVectors(Eigen::MatrixXd &amp;vectors)</div><div class="ttdoc">Normalizes direction vectors to unit length.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:28</div></div>
<div class="ttc" id="astruct_mesh_parametrization_data_html_a6757fe1055d22523c940926dfe594bd8"><div class="ttname"><a href="struct_mesh_parametrization_data.html#a6757fe1055d22523c940926dfe594bd8">MeshParametrizationData::terminals</a></div><div class="ttdeci">Eigen::MatrixXd terminals</div><div class="ttdoc">Matrix of terminal points (2*numBranches × 3)</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:75</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af7f77b882649bfb2df66b607181e28e5" name="af7f77b882649bfb2df66b607181e28e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f77b882649bfb2df66b607181e28e5">&#9670;&#160;</a></span>selfIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshParametrization::selfIntersection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>poly_points</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for self-intersections in branch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly_points</td><td>Polynomial points of branch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if self-intersection found </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  219</span>                                                                           {</div>
<div class="line"><span class="lineno">  220</span> </div>
<div class="line"><span class="lineno">  221</span>    <span class="comment">// If the poly_points do not satisfy our shape requirements, we immediately return false</span></div>
<div class="line"><span class="lineno">  222</span>    <span class="keywordflow">if</span> (poly_points.rows() % 4 != 0 or poly_points.cols() != 3) {</div>
<div class="line"><span class="lineno">  223</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  224</span>    }</div>
<div class="line"><span class="lineno">  225</span> </div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordtype">int</span> num_branches = poly_points.rows() / 4;</div>
<div class="line"><span class="lineno">  227</span> </div>
<div class="line"><span class="lineno">  228</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> branch = 0; branch &lt; num_branches; ++branch) {</div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span>        Eigen::MatrixXd current_branch = poly_points.block&lt;4, 3&gt;(branch * 4, 0);</div>
<div class="line"><span class="lineno">  231</span> </div>
<div class="line"><span class="lineno">  232</span>        <span class="comment">// We have 3 line pairing types to check</span></div>
<div class="line"><span class="lineno">  233</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {</div>
<div class="line"><span class="lineno">  234</span>            <span class="comment">// Declare the 2 points we will be using on the first line</span></div>
<div class="line"><span class="lineno">  235</span>            Eigen::Vector2d a = current_branch.block&lt;2, 1&gt;((i / 2) * 2, i % 2);</div>
<div class="line"><span class="lineno">  236</span>            Eigen::Vector2d b = current_branch.block&lt;2, 1&gt;((i / 2) * 2, i % 2 + 1);</div>
<div class="line"><span class="lineno">  237</span> </div>
<div class="line"><span class="lineno">  238</span>            <span class="comment">// We iterate through the remaining lines and check if they intersect</span></div>
<div class="line"><span class="lineno">  239</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i + 1; j &lt; 4; ++j) {</div>
<div class="line"><span class="lineno">  240</span>                <span class="comment">// Declare the 2 points we will be using on the second line</span></div>
<div class="line"><span class="lineno">  241</span>                Eigen::Vector2d c = current_branch.block&lt;2, 1&gt;((j / 2) * 2, j % 2);</div>
<div class="line"><span class="lineno">  242</span>                Eigen::Vector2d d = current_branch.block&lt;2, 1&gt;((j / 2) * 2, j % 2 + 1);</div>
<div class="line"><span class="lineno">  243</span> </div>
<div class="line"><span class="lineno">  244</span>                <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> lines (a, b, c, d);</div>
<div class="line"><span class="lineno">  245</span> </div>
<div class="line"><span class="lineno">  246</span>                <span class="keywordflow">if</span> (lines.linesIntersectWithoutEnds()) {</div>
<div class="line"><span class="lineno">  247</span>                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  248</span>                }</div>
<div class="line"><span class="lineno">  249</span>            }</div>
<div class="line"><span class="lineno">  250</span>        }</div>
<div class="line"><span class="lineno">  251</span>    }</div>
<div class="line"><span class="lineno">  252</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  253</span>}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
