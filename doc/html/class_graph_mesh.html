<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Semester Project Liam Curtis: GraphMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Semester Project Liam Curtis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_graph_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">GraphMesh Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for managing 2D graph-like meshes.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="graph__mesh_8h_source.html">graph_mesh.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b46499c4e0d600ccbdde70d12c4c46b" id="r_a8b46499c4e0d600ccbdde70d12c4c46b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b46499c4e0d600ccbdde70d12c4c46b">GraphMesh</a> ()</td></tr>
<tr class="memdesc:a8b46499c4e0d600ccbdde70d12c4c46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a8b46499c4e0d600ccbdde70d12c4c46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e5df1cdc7a90e0f843900adc8049a5" id="r_af9e5df1cdc7a90e0f843900adc8049a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9e5df1cdc7a90e0f843900adc8049a5">~GraphMesh</a> ()</td></tr>
<tr class="memdesc:af9e5df1cdc7a90e0f843900adc8049a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:af9e5df1cdc7a90e0f843900adc8049a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136067707a44e48d8311772675a8d70f" id="r_a136067707a44e48d8311772675a8d70f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a136067707a44e48d8311772675a8d70f">loadMeshFromFile</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a136067707a44e48d8311772675a8d70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads mesh from file.  <br /></td></tr>
<tr class="separator:a136067707a44e48d8311772675a8d70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae89bff77790a2b075b81fbb930c8daf" id="r_aae89bff77790a2b075b81fbb930c8daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae89bff77790a2b075b81fbb930c8daf">closeMesh</a> ()</td></tr>
<tr class="memdesc:aae89bff77790a2b075b81fbb930c8daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes mesh construction.  <br /></td></tr>
<tr class="separator:aae89bff77790a2b075b81fbb930c8daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0da0f35d40771dc43748ccd50e61f3" id="r_aeb0da0f35d40771dc43748ccd50e61f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb0da0f35d40771dc43748ccd50e61f3">buildGraphFromMesh</a> ()</td></tr>
<tr class="memdesc:aeb0da0f35d40771dc43748ccd50e61f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs graph representation from mesh.  <br /></td></tr>
<tr class="separator:aeb0da0f35d40771dc43748ccd50e61f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189c38ee8966659c6bcbdfc70ca4f85d" id="r_a189c38ee8966659c6bcbdfc70ca4f85d"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a189c38ee8966659c6bcbdfc70ca4f85d">getConnectedEdges</a> (int nodeId)</td></tr>
<tr class="memdesc:a189c38ee8966659c6bcbdfc70ca4f85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets edges connected to a node.  <br /></td></tr>
<tr class="separator:a189c38ee8966659c6bcbdfc70ca4f85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfdf95067ee7e8a951aebad8ccbb666" id="r_afbfdf95067ee7e8a951aebad8ccbb666"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbfdf95067ee7e8a951aebad8ccbb666">getNodesOfEdge</a> (int edgeId)</td></tr>
<tr class="memdesc:afbfdf95067ee7e8a951aebad8ccbb666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets nodes connected to an edge.  <br /></td></tr>
<tr class="separator:afbfdf95067ee7e8a951aebad8ccbb666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50a12679d36cf91148589bb5d1d80c8" id="r_ac50a12679d36cf91148589bb5d1d80c8"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac50a12679d36cf91148589bb5d1d80c8">getConnectedNodes</a> (int nodeId)</td></tr>
<tr class="memdesc:ac50a12679d36cf91148589bb5d1d80c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets nodes connected to a node.  <br /></td></tr>
<tr class="separator:ac50a12679d36cf91148589bb5d1d80c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb23f58e6049d4358dad7534b6fb64b" id="r_a9cb23f58e6049d4358dad7534b6fb64b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb23f58e6049d4358dad7534b6fb64b">getNodeSurfaces</a> (int nodeId)</td></tr>
<tr class="memdesc:a9cb23f58e6049d4358dad7534b6fb64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets surface tags for a node.  <br /></td></tr>
<tr class="separator:a9cb23f58e6049d4358dad7534b6fb64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f158e83e65920b9dbbf85e6b03bfb7" id="r_a01f158e83e65920b9dbbf85e6b03bfb7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01f158e83e65920b9dbbf85e6b03bfb7">getNodeBoundary</a> (int nodeId)</td></tr>
<tr class="memdesc:a01f158e83e65920b9dbbf85e6b03bfb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets boundary tags for a node.  <br /></td></tr>
<tr class="separator:a01f158e83e65920b9dbbf85e6b03bfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67a3e31d7aebdc8128887c585fa95d4" id="r_ac67a3e31d7aebdc8128887c585fa95d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac67a3e31d7aebdc8128887c585fa95d4">getEdgeSurfaces</a> (int edgeId)</td></tr>
<tr class="memdesc:ac67a3e31d7aebdc8128887c585fa95d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets surface tags for an edge.  <br /></td></tr>
<tr class="separator:ac67a3e31d7aebdc8128887c585fa95d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e1768ffaa85a7754ee44392b1d47e8" id="r_a94e1768ffaa85a7754ee44392b1d47e8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94e1768ffaa85a7754ee44392b1d47e8">getEdgeBoundary</a> (int edgeId)</td></tr>
<tr class="memdesc:a94e1768ffaa85a7754ee44392b1d47e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets boundary tags for an edge.  <br /></td></tr>
<tr class="separator:a94e1768ffaa85a7754ee44392b1d47e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457d2958e23b465070fa1e32b82c15b7" id="r_a457d2958e23b465070fa1e32b82c15b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_part_graph.html">PartGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a457d2958e23b465070fa1e32b82c15b7">splitMesh</a> (double targetPartSize, double nodeEdgePortion)</td></tr>
<tr class="memdesc:a457d2958e23b465070fa1e32b82c15b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits mesh into parts.  <br /></td></tr>
<tr class="separator:a457d2958e23b465070fa1e32b82c15b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e1a725acf060f5a522e92843454134" id="r_a27e1a725acf060f5a522e92843454134"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27e1a725acf060f5a522e92843454134">getPartGeometry</a> (const <a class="el" href="struct_mesh_part.html">MeshPart</a> &amp;part)</td></tr>
<tr class="memdesc:a27e1a725acf060f5a522e92843454134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets geometry for a mesh part.  <br /></td></tr>
<tr class="separator:a27e1a725acf060f5a522e92843454134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cfbd15bbf85bc957f95a730522589d" id="r_af6cfbd15bbf85bc957f95a730522589d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6cfbd15bbf85bc957f95a730522589d">getGeometryPolynomialPoints</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;part_graph)</td></tr>
<tr class="memdesc:af6cfbd15bbf85bc957f95a730522589d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets polynomial points for the geometry.  <br /></td></tr>
<tr class="separator:af6cfbd15bbf85bc957f95a730522589d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164162900d8e97ee8e2cafb8baa90363" id="r_a164162900d8e97ee8e2cafb8baa90363"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; Eigen::MatrixXi &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a164162900d8e97ee8e2cafb8baa90363">getMeshPolynomialPoints</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;part_graph, const std::string &amp;mesh_file_name, int order)</td></tr>
<tr class="memdesc:a164162900d8e97ee8e2cafb8baa90363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets polynomial points for the mesh.  <br /></td></tr>
<tr class="separator:a164162900d8e97ee8e2cafb8baa90363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cf9af0db6518e7c6f896a1cb6a0a2e" id="r_ae2cf9af0db6518e7c6f896a1cb6a0a2e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2cf9af0db6518e7c6f896a1cb6a0a2e">getGeometryParametrizations</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;part_graph)</td></tr>
<tr class="memdesc:ae2cf9af0db6518e7c6f896a1cb6a0a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets parametrizations for the geometry.  <br /></td></tr>
<tr class="separator:ae2cf9af0db6518e7c6f896a1cb6a0a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4456e3afd0edca8c2851ad6029e94124" id="r_a4456e3afd0edca8c2851ad6029e94124"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4456e3afd0edca8c2851ad6029e94124">getMeshParametrizations</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;part_graph, const std::string &amp;mesh_file_name, int order)</td></tr>
<tr class="memdesc:a4456e3afd0edca8c2851ad6029e94124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets parametrizations for mesh.  <br /></td></tr>
<tr class="separator:a4456e3afd0edca8c2851ad6029e94124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3476770f845a7c33911fe96eff3c617" id="r_ab3476770f845a7c33911fe96eff3c617"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3476770f845a7c33911fe96eff3c617">getInitialDisplacements</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;part_graph)</td></tr>
<tr class="memdesc:ab3476770f845a7c33911fe96eff3c617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets initial displacement vectors.  <br /></td></tr>
<tr class="separator:ab3476770f845a7c33911fe96eff3c617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3907a12bfc1caa034e08aab62040864" id="r_af3907a12bfc1caa034e08aab62040864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_n_training_params.html">NNTrainingParams</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3907a12bfc1caa034e08aab62040864">getNNTrainingParams</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;part_graph)</td></tr>
<tr class="memdesc:af3907a12bfc1caa034e08aab62040864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets training parameters for neural network.  <br /></td></tr>
<tr class="separator:af3907a12bfc1caa034e08aab62040864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe58192125ecaa4193b92519493ded6" id="r_aebe58192125ecaa4193b92519493ded6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_compatibility_condition.html">CompatibilityCondition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebe58192125ecaa4193b92519493ded6">getCompatibilityConditions</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;part_graph)</td></tr>
<tr class="memdesc:aebe58192125ecaa4193b92519493ded6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets compatibility conditions between parts.  <br /></td></tr>
<tr class="separator:aebe58192125ecaa4193b92519493ded6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866398fc97666239b0bcdf918ce580cb" id="r_a866398fc97666239b0bcdf918ce580cb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_fixed_displacement_condition.html">FixedDisplacementCondition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a866398fc97666239b0bcdf918ce580cb">getFixedDisplacementConditions</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;part_graph, const std::vector&lt; std::pair&lt; int, Eigen::Vector4d &gt; &gt; &amp;displacements)</td></tr>
<tr class="memdesc:a866398fc97666239b0bcdf918ce580cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets fixed displacement conditions.  <br /></td></tr>
<tr class="separator:a866398fc97666239b0bcdf918ce580cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5efe6a6d1322ffafd44e5d227d0b027" id="r_aa5efe6a6d1322ffafd44e5d227d0b027"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::VectorXd, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5efe6a6d1322ffafd44e5d227d0b027">meshFEMCalculation</a> (const std::string &amp;mesh_file_name, const std::vector&lt; std::pair&lt; int, Eigen::Vector4d &gt; &gt; &amp;displacements, const <a class="el" href="structcalculation_params.html">calculationParams</a> &amp;calc_params)</td></tr>
<tr class="memdesc:aa5efe6a6d1322ffafd44e5d227d0b027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs FEM calculation on a larger mesh.  <br /></td></tr>
<tr class="separator:aa5efe6a6d1322ffafd44e5d227d0b027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510e83220cddb19293e4b3adb20e2a51" id="r_a510e83220cddb19293e4b3adb20e2a51"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; Eigen::MatrixXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a510e83220cddb19293e4b3adb20e2a51">meshDisplacementVectors</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;part_graph, const std::string &amp;mesh_file_name, const std::vector&lt; std::pair&lt; int, Eigen::Vector4d &gt; &gt; &amp;fixed_displacements, const <a class="el" href="structcalculation_params.html">calculationParams</a> &amp;calc_params)</td></tr>
<tr class="memdesc:a510e83220cddb19293e4b3adb20e2a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes displacement vectors for each mesh parametrizations.  <br /></td></tr>
<tr class="separator:a510e83220cddb19293e4b3adb20e2a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727062f2e085cd97ad2007346ad5eccf" id="r_a727062f2e085cd97ad2007346ad5eccf"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a727062f2e085cd97ad2007346ad5eccf">meshEnergy</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;part_graph, const std::string &amp;mesh_file_name, const std::vector&lt; std::pair&lt; int, Eigen::Vector4d &gt; &gt; &amp;fixed_displacements, const <a class="el" href="structcalculation_params.html">calculationParams</a> &amp;calc_params)</td></tr>
<tr class="memdesc:a727062f2e085cd97ad2007346ad5eccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes energy change for each mesh parametrization individually according to displacement vectors.  <br /></td></tr>
<tr class="separator:a727062f2e085cd97ad2007346ad5eccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc53123269ec018b2484e359590ca186" id="r_abc53123269ec018b2484e359590ca186"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc53123269ec018b2484e359590ca186">getEdgeLength</a> (int edgeId)</td></tr>
<tr class="memdesc:abc53123269ec018b2484e359590ca186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets length of an edge.  <br /></td></tr>
<tr class="separator:abc53123269ec018b2484e359590ca186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d37ebae2f4bee3913773d9951aed6d" id="r_ae6d37ebae2f4bee3913773d9951aed6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d37ebae2f4bee3913773d9951aed6d">findSharedLine</a> (const std::vector&lt; int &gt; &amp;nodeBoundaryTags, const std::vector&lt; int &gt; &amp;edgeBoundaryTags)</td></tr>
<tr class="memdesc:ae6d37ebae2f4bee3913773d9951aed6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds shared boundary line between an edge an a node.  <br /></td></tr>
<tr class="separator:ae6d37ebae2f4bee3913773d9951aed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec778de2b75006ca9dfd067d6fe78f01" id="r_aec778de2b75006ca9dfd067d6fe78f01"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec778de2b75006ca9dfd067d6fe78f01">findSplineCurves</a> (const std::vector&lt; int &gt; &amp;edgeBoundaryTags)</td></tr>
<tr class="memdesc:aec778de2b75006ca9dfd067d6fe78f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds spline curves in boundary tags of an edge.  <br /></td></tr>
<tr class="separator:aec778de2b75006ca9dfd067d6fe78f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad522efd135fa5daecba00eeeaffcb940" id="r_ad522efd135fa5daecba00eeeaffcb940"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad522efd135fa5daecba00eeeaffcb940">determineSplineOrientation</a> (int splineTag, int sharedLineTag)</td></tr>
<tr class="memdesc:ad522efd135fa5daecba00eeeaffcb940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines spline orientation relative to node.  <br /></td></tr>
<tr class="separator:ad522efd135fa5daecba00eeeaffcb940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dde2184587428524c7eeb0c97b98c1" id="r_aa0dde2184587428524c7eeb0c97b98c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0dde2184587428524c7eeb0c97b98c1">printMeshGeometry</a> ()</td></tr>
<tr class="separator:aa0dde2184587428524c7eeb0c97b98c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ade42074c2b94f3675a3660289bb60b" id="r_a6ade42074c2b94f3675a3660289bb60b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ade42074c2b94f3675a3660289bb60b">buildSplitAndPrintMesh</a> (const std::string &amp;filename, double targetPartSize, double nodeEdgePortion)</td></tr>
<tr class="separator:a6ade42074c2b94f3675a3660289bb60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36de5dd2ec6798d3163ffaf049247f20" id="r_a36de5dd2ec6798d3163ffaf049247f20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36de5dd2ec6798d3163ffaf049247f20">printGraphState</a> ()</td></tr>
<tr class="separator:a36de5dd2ec6798d3163ffaf049247f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6bc452bb6da7e0331305c58e186397" id="r_a3a6bc452bb6da7e0331305c58e186397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a6bc452bb6da7e0331305c58e186397">printPartGraphState</a> (const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;partGraph)</td></tr>
<tr class="separator:a3a6bc452bb6da7e0331305c58e186397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a5fdb888382c672b3a16d076562b24" id="r_a52a5fdb888382c672b3a16d076562b24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52a5fdb888382c672b3a16d076562b24">printCompatibilityConditions</a> (const std::vector&lt; <a class="el" href="struct_compatibility_condition.html">CompatibilityCondition</a> &gt; &amp;conditions)</td></tr>
<tr class="separator:a52a5fdb888382c672b3a16d076562b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e7c3fc81e733eaa764b31be4f6df16" id="r_a23e7c3fc81e733eaa764b31be4f6df16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23e7c3fc81e733eaa764b31be4f6df16">printTrainingParams</a> (const <a class="el" href="struct_n_n_training_params.html">NNTrainingParams</a> &amp;params)</td></tr>
<tr class="separator:a23e7c3fc81e733eaa764b31be4f6df16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a39ebda16edb97cde0f770192a6d00" id="r_a28a39ebda16edb97cde0f770192a6d00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28a39ebda16edb97cde0f770192a6d00">printMeshData</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;geom_poly_points, const std::vector&lt; Eigen::MatrixXd &gt; &amp;mesh_poly_points, const std::vector&lt; Eigen::MatrixXi &gt; &amp;mesh_node_indices)</td></tr>
<tr class="separator:a28a39ebda16edb97cde0f770192a6d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0b3734921da617cfeb8f3036c6eee3" id="r_a7b0b3734921da617cfeb8f3036c6eee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b0b3734921da617cfeb8f3036c6eee3">compareMeshParametrizationData</a> (const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;data1, const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;data2)</td></tr>
<tr class="separator:a7b0b3734921da617cfeb8f3036c6eee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c4a6bf9b71266ad65a5e0274a70390" id="r_a87c4a6bf9b71266ad65a5e0274a70390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87c4a6bf9b71266ad65a5e0274a70390">printMatrixComparison</a> (const Eigen::MatrixXd &amp;m1, const Eigen::MatrixXd &amp;m2)</td></tr>
<tr class="separator:a87c4a6bf9b71266ad65a5e0274a70390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1070a4b42b2eb53989fb9ca29133bdab" id="r_a1070a4b42b2eb53989fb9ca29133bdab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1070a4b42b2eb53989fb9ca29133bdab">printMeshParamsAndDisplacements</a> (const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;mesh_params, const std::vector&lt; Eigen::MatrixXd &gt; &amp;displacements)</td></tr>
<tr class="separator:a1070a4b42b2eb53989fb9ca29133bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a61a23fd61bbd36d181a43f5b82a304" id="r_a4a61a23fd61bbd36d181a43f5b82a304"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a61a23fd61bbd36d181a43f5b82a304">printMeshParamsAndDisplacementsAndEnergies</a> (const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;mesh_params, const std::vector&lt; Eigen::MatrixXd &gt; &amp;displacements, const std::vector&lt; double &gt; &amp;energies)</td></tr>
<tr class="separator:a4a61a23fd61bbd36d181a43f5b82a304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130452deb2febae1092d4a0cbe0a8d7b" id="r_a130452deb2febae1092d4a0cbe0a8d7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a130452deb2febae1092d4a0cbe0a8d7b">printMeshParamsAndDisplacementsAndTrueEnergies</a> (const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;mesh_params, const std::vector&lt; Eigen::MatrixXd &gt; &amp;displacements, const std::vector&lt; double &gt; &amp;NN_energies, const std::vector&lt; double &gt; &amp;true_energies)</td></tr>
<tr class="separator:a130452deb2febae1092d4a0cbe0a8d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d843d6c74fc0db8c2c544c0081c6b0" id="r_a02d843d6c74fc0db8c2c544c0081c6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02d843d6c74fc0db8c2c544c0081c6b0">printMeshPointsAndDisplacements</a> (const std::vector&lt; <a class="el" href="struct_parametrization_points.html">ParametrizationPoints</a> &gt; &amp;mesh_points, const std::vector&lt; Eigen::MatrixXd &gt; &amp;displacements, const std::vector&lt; double &gt; &amp;energies)</td></tr>
<tr class="separator:a02d843d6c74fc0db8c2c544c0081c6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35fc86c81fd0b9c6de2058ea0e8c238" id="r_ae35fc86c81fd0b9c6de2058ea0e8c238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae35fc86c81fd0b9c6de2058ea0e8c238">printMeshMatricesAndDisplacements</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;mesh_points, const std::vector&lt; Eigen::MatrixXd &gt; &amp;displacements, const std::vector&lt; double &gt; &amp;NN_energies, const std::vector&lt; double &gt; &amp;true_energies)</td></tr>
<tr class="separator:ae35fc86c81fd0b9c6de2058ea0e8c238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd5933f4767a5b96e37868710b36c04" id="r_acdd5933f4767a5b96e37868710b36c04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdd5933f4767a5b96e37868710b36c04">printFixedDisplacementConditions</a> (const std::vector&lt; <a class="el" href="struct_fixed_displacement_condition.html">FixedDisplacementCondition</a> &gt; &amp;conditions)</td></tr>
<tr class="separator:acdd5933f4767a5b96e37868710b36c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d81c07ff9ade4b9186aad4b14ea9f0a" id="r_a9d81c07ff9ade4b9186aad4b14ea9f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d81c07ff9ade4b9186aad4b14ea9f0a">printMeshParamsAndEnergies</a> (const std::tuple&lt; std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; double &gt; &gt; &amp;data)</td></tr>
<tr class="separator:a9d81c07ff9ade4b9186aad4b14ea9f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a05e38d4ef4104faf709ec2c64146fdfb" id="r_a05e38d4ef4104faf709ec2c64146fdfb"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05e38d4ef4104faf709ec2c64146fdfb">centerPointParametrizations</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;point_vector)</td></tr>
<tr class="memdesc:a05e38d4ef4104faf709ec2c64146fdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centers parametrizations containing the polynomial points.  <br /></td></tr>
<tr class="separator:a05e38d4ef4104faf709ec2c64146fdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7f1768822a8f276a5779d0bed22a38" id="r_a6a7f1768822a8f276a5779d0bed22a38"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a7f1768822a8f276a5779d0bed22a38">centerMeshParametrizations</a> (const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;param_vector)</td></tr>
<tr class="memdesc:a6a7f1768822a8f276a5779d0bed22a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centers parametrizations of type <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a>.  <br /></td></tr>
<tr class="separator:a6a7f1768822a8f276a5779d0bed22a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3d3d464459cf4822c9b8b13b966e6cf3" id="r_a3d3d464459cf4822c9b8b13b966e6cf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d3d464459cf4822c9b8b13b966e6cf3">isBC</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a3d3d464459cf4822c9b8b13b966e6cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if name represents a boundary condition.  <br /></td></tr>
<tr class="separator:a3d3d464459cf4822c9b8b13b966e6cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683fc6b2538ac42600716c7f66f32e33" id="r_a683fc6b2538ac42600716c7f66f32e33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a683fc6b2538ac42600716c7f66f32e33">isNode</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a683fc6b2538ac42600716c7f66f32e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if name represents a node.  <br /></td></tr>
<tr class="separator:a683fc6b2538ac42600716c7f66f32e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218e4502de90e51bacd6d2cdda8ef559" id="r_a218e4502de90e51bacd6d2cdda8ef559"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a218e4502de90e51bacd6d2cdda8ef559">isNodeBoundary</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a218e4502de90e51bacd6d2cdda8ef559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if name represents a node boundary.  <br /></td></tr>
<tr class="separator:a218e4502de90e51bacd6d2cdda8ef559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1859c71201ea19368e6d0958849cfd87" id="r_a1859c71201ea19368e6d0958849cfd87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1859c71201ea19368e6d0958849cfd87">isEdge</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a1859c71201ea19368e6d0958849cfd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if name represents an edge.  <br /></td></tr>
<tr class="separator:a1859c71201ea19368e6d0958849cfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e0be86a3fbb160365bddb63396e8e8" id="r_a78e0be86a3fbb160365bddb63396e8e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78e0be86a3fbb160365bddb63396e8e8">isEdgeBoundary</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a78e0be86a3fbb160365bddb63396e8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if name represents an edge boundary.  <br /></td></tr>
<tr class="separator:a78e0be86a3fbb160365bddb63396e8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb392b63b56b74f3707e5e316f0fabaa" id="r_adb392b63b56b74f3707e5e316f0fabaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb392b63b56b74f3707e5e316f0fabaa">extractId</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:adb392b63b56b74f3707e5e316f0fabaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts ID number from physical group name.  <br /></td></tr>
<tr class="separator:adb392b63b56b74f3707e5e316f0fabaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca5f97b6538e7c87e7b7895f6851645" id="r_a7ca5f97b6538e7c87e7b7895f6851645"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ca5f97b6538e7c87e7b7895f6851645">extractBCId</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a7ca5f97b6538e7c87e7b7895f6851645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts boundary condition ID from name.  <br /></td></tr>
<tr class="separator:a7ca5f97b6538e7c87e7b7895f6851645"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa3f6281813689df21df1e3da33988b97" id="r_aa3f6281813689df21df1e3da33988b97"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="struct_node2_d.html">Node2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3f6281813689df21df1e3da33988b97">nodes</a></td></tr>
<tr class="memdesc:aa3f6281813689df21df1e3da33988b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of node IDs to nodes.  <br /></td></tr>
<tr class="separator:aa3f6281813689df21df1e3da33988b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fddd298e36dc790c25f569828df0e1" id="r_a08fddd298e36dc790c25f569828df0e1"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="struct_edge2_d.html">Edge2D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08fddd298e36dc790c25f569828df0e1">edges</a></td></tr>
<tr class="memdesc:a08fddd298e36dc790c25f569828df0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of edge IDs to edges.  <br /></td></tr>
<tr class="separator:a08fddd298e36dc790c25f569828df0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cec0dcae353a95b3692a871ecf4cd1" id="r_ad5cec0dcae353a95b3692a871ecf4cd1"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="struct_boundary_line.html">BoundaryLine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a></td></tr>
<tr class="memdesc:ad5cec0dcae353a95b3692a871ecf4cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of boundary IDs to boundary lines.  <br /></td></tr>
<tr class="separator:ad5cec0dcae353a95b3692a871ecf4cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for managing 2D graph-like meshes. </p>
<p>Handles mesh loading, processing, and analysis for FEM calculations and neural network training. Supports mesh subdivision and parametrization generation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8b46499c4e0d600ccbdde70d12c4c46b" name="a8b46499c4e0d600ccbdde70d12c4c46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b46499c4e0d600ccbdde70d12c4c46b">&#9670;&#160;</a></span>GraphMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GraphMesh::GraphMesh </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<div class="fragment"><div class="line"><span class="lineno">   31</span>                     {</div>
<div class="line"><span class="lineno">   32</span>    gmsh::initialize();</div>
<div class="line"><span class="lineno">   33</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af9e5df1cdc7a90e0f843900adc8049a5" name="af9e5df1cdc7a90e0f843900adc8049a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e5df1cdc7a90e0f843900adc8049a5">&#9670;&#160;</a></span>~GraphMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GraphMesh::~GraphMesh </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<div class="fragment"><div class="line"><span class="lineno">   35</span>                      {</div>
<div class="line"><span class="lineno">   36</span>    <span class="keywordflow">if</span> (gmsh::isInitialized()) {</div>
<div class="line"><span class="lineno">   37</span>        gmsh::finalize();</div>
<div class="line"><span class="lineno">   38</span>    }</div>
<div class="line"><span class="lineno">   39</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb0da0f35d40771dc43748ccd50e61f3" name="aeb0da0f35d40771dc43748ccd50e61f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0da0f35d40771dc43748ccd50e61f3">&#9670;&#160;</a></span>buildGraphFromMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::buildGraphFromMesh </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs graph representation from mesh. </p>
<p>In doing so, it uses the opened mesh from <a class="el" href="#a136067707a44e48d8311772675a8d70f">loadMeshFromFile</a> to initialize the fields of the <a class="el" href="class_graph_mesh.html">GraphMesh</a> class </p>
<div class="fragment"><div class="line"><span class="lineno">  115</span>                                   {</div>
<div class="line"><span class="lineno">  116</span>    <span class="comment">// Physical groups will be e.g. N2, EB2, note there should be (N + E) * 2 total groups, as each group will have a</span></div>
<div class="line"><span class="lineno">  117</span>    <span class="comment">// label for the 2D surface and the boundary surrounding it</span></div>
<div class="line"><span class="lineno">  118</span>    std::vector&lt;std::pair&lt;int, int&gt;&gt; groups;</div>
<div class="line"><span class="lineno">  119</span>    gmsh::model::getPhysicalGroups(groups);</div>
<div class="line"><span class="lineno">  120</span> </div>
<div class="line"><span class="lineno">  121</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; groups.size() &lt;&lt; <span class="stringliteral">&quot; physical groups.\n&quot;</span>;</div>
<div class="line"><span class="lineno">  122</span> </div>
<div class="line"><span class="lineno">  123</span>    <span class="comment">// TODO: Since I want to input BC physical groups into the mesh, I will be adding extra physical groups on the lines,</span></div>
<div class="line"><span class="lineno">  124</span>    <span class="comment">//  so find a way to skip over these in this loop, as they are not relevant for building the graph</span></div>
<div class="line"><span class="lineno">  125</span>    <span class="comment">// TODO: Perhaps also find a way to initialize the BCs of the graph using this loop actually</span></div>
<div class="line"><span class="lineno">  126</span>    <span class="comment">// Iterate through each group using its dimension and corresponding tag</span></div>
<div class="line"><span class="lineno">  127</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [dim, tag] : groups) {</div>
<div class="line"><span class="lineno">  128</span> </div>
<div class="line"><span class="lineno">  129</span>        <span class="comment">// Extract the name and id from this group</span></div>
<div class="line"><span class="lineno">  130</span>        std::string name;</div>
<div class="line"><span class="lineno">  131</span>        gmsh::model::getPhysicalName(dim, tag, name);</div>
<div class="line"><span class="lineno">  132</span> </div>
<div class="line"><span class="lineno">  133</span>        <span class="comment">// If this is a boundary line, we initialize the corresponding boundary but then skip over the</span></div>
<div class="line"><span class="lineno">  134</span>        <span class="comment">// rest of the implementation</span></div>
<div class="line"><span class="lineno">  135</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="#a3d3d464459cf4822c9b8b13b966e6cf3">isBC</a>(name)) {</div>
<div class="line"><span class="lineno">  136</span>            <span class="keywordtype">int</span> <span class="keywordtype">id</span> = <a class="code hl_function" href="#a7ca5f97b6538e7c87e7b7895f6851645">extractBCId</a>(name);</div>
<div class="line"><span class="lineno">  137</span>            std::vector&lt;int&gt; entities;</div>
<div class="line"><span class="lineno">  138</span>            gmsh::model::getEntitiesForPhysicalGroup(dim, tag, entities);</div>
<div class="line"><span class="lineno">  139</span> </div>
<div class="line"><span class="lineno">  140</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;Processing group: &quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; (dim: &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot;, tag: &quot;</span> &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot;, id: &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line"><span class="lineno">  141</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;  Entities: &quot;</span>;</div>
<div class="line"><span class="lineno">  142</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> entity : entities) std::cout &lt;&lt; entity &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno">  143</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">  144</span> </div>
<div class="line"><span class="lineno">  145</span>            <a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[id].id = id;</div>
<div class="line"><span class="lineno">  146</span>            <a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[id].curveTag = entities[0];</div>
<div class="line"><span class="lineno">  147</span>            <a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[id].physicalTag = tag;</div>
<div class="line"><span class="lineno">  148</span> </div>
<div class="line"><span class="lineno">  149</span>            std::vector&lt;double&gt; tMin, tMax;</div>
<div class="line"><span class="lineno">  150</span>            gmsh::model::getParametrizationBounds(1, entities[0], tMin, tMax);</div>
<div class="line"><span class="lineno">  151</span> </div>
<div class="line"><span class="lineno">  152</span>            std::vector&lt;double&gt; startPoint;</div>
<div class="line"><span class="lineno">  153</span>            gmsh::model::getValue(1, entities[0], tMin, startPoint);</div>
<div class="line"><span class="lineno">  154</span>            Eigen::Vector2d start_point;</div>
<div class="line"><span class="lineno">  155</span>            start_point &lt;&lt; startPoint[0], startPoint[1];</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span>            std::vector&lt;double&gt; endPoint;</div>
<div class="line"><span class="lineno">  158</span>            gmsh::model::getValue(1, entities[0], tMax, endPoint);</div>
<div class="line"><span class="lineno">  159</span>            Eigen::Vector2d end_point;</div>
<div class="line"><span class="lineno">  160</span>            end_point &lt;&lt; endPoint[0], endPoint[1];</div>
<div class="line"><span class="lineno">  161</span> </div>
<div class="line"><span class="lineno">  162</span>            <a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[id].points = {start_point, end_point};</div>
<div class="line"><span class="lineno">  163</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  164</span>        }</div>
<div class="line"><span class="lineno">  165</span>        <span class="keywordtype">int</span> <span class="keywordtype">id</span> = <a class="code hl_function" href="#adb392b63b56b74f3707e5e316f0fabaa">extractId</a>(name);</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span>        <span class="comment">// Obtain entities for this group for a node this will be the physical surface, and for a boundary, this will include</span></div>
<div class="line"><span class="lineno">  168</span>        <span class="comment">// the multiple curves that make up the boundary</span></div>
<div class="line"><span class="lineno">  169</span>        std::vector&lt;int&gt; entities;</div>
<div class="line"><span class="lineno">  170</span>        gmsh::model::getEntitiesForPhysicalGroup(dim, tag, entities);</div>
<div class="line"><span class="lineno">  171</span> </div>
<div class="line"><span class="lineno">  172</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Processing group: &quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; (dim: &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot;, tag: &quot;</span> &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot;, id: &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line"><span class="lineno">  173</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Entities: &quot;</span>;</div>
<div class="line"><span class="lineno">  174</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> entity : entities) std::cout &lt;&lt; entity &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno">  175</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">  176</span> </div>
<div class="line"><span class="lineno">  177</span>        <span class="comment">// Check which type of physical group this is and add the corresponding info to the correct struct</span></div>
<div class="line"><span class="lineno">  178</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="#a683fc6b2538ac42600716c7f66f32e33">isNode</a>(name)) {</div>
<div class="line"><span class="lineno">  179</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;  Identified as Node\n&quot;</span>;</div>
<div class="line"><span class="lineno">  180</span>            <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>[id].id = id;</div>
<div class="line"><span class="lineno">  181</span>            <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>[id].surfaceTags = entities;</div>
<div class="line"><span class="lineno">  182</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_function" href="#a218e4502de90e51bacd6d2cdda8ef559">isNodeBoundary</a>(name)) {</div>
<div class="line"><span class="lineno">  183</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;  Identified as Node Boundary\n&quot;</span>;</div>
<div class="line"><span class="lineno">  184</span>            <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>[id].boundaryTags = entities;</div>
<div class="line"><span class="lineno">  185</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_function" href="#a1859c71201ea19368e6d0958849cfd87">isEdge</a>(name)) {</div>
<div class="line"><span class="lineno">  186</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;  Identified as Edge\n&quot;</span>;</div>
<div class="line"><span class="lineno">  187</span>            <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[id].id = id;</div>
<div class="line"><span class="lineno">  188</span>            <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[id].surfaceTags = entities;</div>
<div class="line"><span class="lineno">  189</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_function" href="#a78e0be86a3fbb160365bddb63396e8e8">isEdgeBoundary</a>(name)) {</div>
<div class="line"><span class="lineno">  190</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;  Identified as Edge Boundary\n&quot;</span>;</div>
<div class="line"><span class="lineno">  191</span>            <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[id].boundaryTags = entities;</div>
<div class="line"><span class="lineno">  192</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  193</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;  Warning: Unrecognized group name format\n&quot;</span>;</div>
<div class="line"><span class="lineno">  194</span>        }</div>
<div class="line"><span class="lineno">  195</span> </div>
<div class="line"><span class="lineno">  196</span>    }</div>
<div class="line"><span class="lineno">  197</span> </div>
<div class="line"><span class="lineno">  198</span>    <span class="comment">// Iterate through edges to establish connections between nodes and edges</span></div>
<div class="line"><span class="lineno">  199</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Finding connections...\n&quot;</span>;</div>
<div class="line"><span class="lineno">  200</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; [edgeId, edge] : <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>) {</div>
<div class="line"><span class="lineno">  201</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Processing Edge &quot;</span> &lt;&lt; edgeId &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno">  202</span>        std::set&lt;int&gt; connectedNodes;</div>
<div class="line"><span class="lineno">  203</span> </div>
<div class="line"><span class="lineno">  204</span>        <span class="comment">// Iterate through the boundaries of the edge to see if any are associated to a node (at least 1 should be)</span></div>
<div class="line"><span class="lineno">  205</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> boundaryTag : edge.boundaryTags) {</div>
<div class="line"><span class="lineno">  206</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;  Checking boundary tag: &quot;</span> &lt;&lt; boundaryTag &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">  207</span>            <span class="comment">// Obtain the tags of curves on this particular boundary to see if they are part of other entities</span></div>
<div class="line"><span class="lineno">  208</span>            std::vector&lt;int&gt; curveGroups;</div>
<div class="line"><span class="lineno">  209</span>            gmsh::model::getPhysicalGroupsForEntity(1, boundaryTag, curveGroups);</div>
<div class="line"><span class="lineno">  210</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;    Associated node groups: &quot;</span>;</div>
<div class="line"><span class="lineno">  211</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> curveGroup : curveGroups) std::cout &lt;&lt; curveGroup &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno">  212</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">  213</span>            <span class="comment">// Iterate through the curves associated to this boundaryTag</span></div>
<div class="line"><span class="lineno">  214</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> curveGroup : curveGroups) {</div>
<div class="line"><span class="lineno">  215</span>                std::string entityName;</div>
<div class="line"><span class="lineno">  216</span>                <span class="comment">// Obtain the name of the group with this tag</span></div>
<div class="line"><span class="lineno">  217</span>                gmsh::model::getPhysicalName(1, curveGroup, entityName);</div>
<div class="line"><span class="lineno">  218</span><span class="comment">//                std::cout &lt;&lt; &quot;    Connected to Node with Name: &quot; &lt;&lt; nodeName &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line"><span class="lineno">  219</span>                <span class="comment">// If the name indcates a node through our naming system, we update connectedNodes and connectedEdges</span></div>
<div class="line"><span class="lineno">  220</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="#a218e4502de90e51bacd6d2cdda8ef559">isNodeBoundary</a>(entityName)) {</div>
<div class="line"><span class="lineno">  221</span>                    <span class="keywordtype">int</span> nodeId = <a class="code hl_function" href="#adb392b63b56b74f3707e5e316f0fabaa">extractId</a>(entityName);</div>
<div class="line"><span class="lineno">  222</span>                    std::cout &lt;&lt; <span class="stringliteral">&quot;    Connected to Node &quot;</span> &lt;&lt; nodeId &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">  223</span>                    connectedNodes.insert(nodeId);</div>
<div class="line"><span class="lineno">  224</span>                    <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>[nodeId].connectedEdges.insert(edgeId);</div>
<div class="line"><span class="lineno">  225</span>                }</div>
<div class="line"><span class="lineno">  226</span>            }</div>
<div class="line"><span class="lineno">  227</span>        }</div>
<div class="line"><span class="lineno">  228</span> </div>
<div class="line"><span class="lineno">  229</span>        <span class="comment">// Add our connectedNodes to our edge, this should always be of size either 1 or 2</span></div>
<div class="line"><span class="lineno">  230</span>        edge.connectedNodes.assign(connectedNodes.begin(), connectedNodes.end());</div>
<div class="line"><span class="lineno">  231</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Edge &quot;</span> &lt;&lt; edgeId &lt;&lt; <span class="stringliteral">&quot; is connected to nodes: &quot;</span>;</div>
<div class="line"><span class="lineno">  232</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nodeId : edge.connectedNodes) std::cout &lt;&lt; nodeId &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno">  233</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">  234</span>    }</div>
<div class="line"><span class="lineno">  235</span>}</div>
<div class="ttc" id="aclass_graph_mesh_html_a08fddd298e36dc790c25f569828df0e1"><div class="ttname"><a href="#a08fddd298e36dc790c25f569828df0e1">GraphMesh::edges</a></div><div class="ttdeci">std::map&lt; int, Edge2D &gt; edges</div><div class="ttdoc">Map of edge IDs to edges.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:190</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a1859c71201ea19368e6d0958849cfd87"><div class="ttname"><a href="#a1859c71201ea19368e6d0958849cfd87">GraphMesh::isEdge</a></div><div class="ttdeci">bool isEdge(const std::string &amp;name)</div><div class="ttdoc">Checks if name represents an edge.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:54</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a218e4502de90e51bacd6d2cdda8ef559"><div class="ttname"><a href="#a218e4502de90e51bacd6d2cdda8ef559">GraphMesh::isNodeBoundary</a></div><div class="ttdeci">bool isNodeBoundary(const std::string &amp;name)</div><div class="ttdoc">Checks if name represents a node boundary.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:50</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a3d3d464459cf4822c9b8b13b966e6cf3"><div class="ttname"><a href="#a3d3d464459cf4822c9b8b13b966e6cf3">GraphMesh::isBC</a></div><div class="ttdeci">bool isBC(const std::string &amp;name)</div><div class="ttdoc">Checks if name represents a boundary condition.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:42</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a683fc6b2538ac42600716c7f66f32e33"><div class="ttname"><a href="#a683fc6b2538ac42600716c7f66f32e33">GraphMesh::isNode</a></div><div class="ttdeci">bool isNode(const std::string &amp;name)</div><div class="ttdoc">Checks if name represents a node.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:46</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a78e0be86a3fbb160365bddb63396e8e8"><div class="ttname"><a href="#a78e0be86a3fbb160365bddb63396e8e8">GraphMesh::isEdgeBoundary</a></div><div class="ttdeci">bool isEdgeBoundary(const std::string &amp;name)</div><div class="ttdoc">Checks if name represents an edge boundary.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:58</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a7ca5f97b6538e7c87e7b7895f6851645"><div class="ttname"><a href="#a7ca5f97b6538e7c87e7b7895f6851645">GraphMesh::extractBCId</a></div><div class="ttdeci">int extractBCId(const std::string &amp;name)</div><div class="ttdoc">Extracts boundary condition ID from name.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:67</div></div>
<div class="ttc" id="aclass_graph_mesh_html_aa3f6281813689df21df1e3da33988b97"><div class="ttname"><a href="#aa3f6281813689df21df1e3da33988b97">GraphMesh::nodes</a></div><div class="ttdeci">std::map&lt; int, Node2D &gt; nodes</div><div class="ttdoc">Map of node IDs to nodes.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:189</div></div>
<div class="ttc" id="aclass_graph_mesh_html_ad5cec0dcae353a95b3692a871ecf4cd1"><div class="ttname"><a href="#ad5cec0dcae353a95b3692a871ecf4cd1">GraphMesh::boundaries</a></div><div class="ttdeci">std::map&lt; int, BoundaryLine &gt; boundaries</div><div class="ttdoc">Map of boundary IDs to boundary lines.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:191</div></div>
<div class="ttc" id="aclass_graph_mesh_html_adb392b63b56b74f3707e5e316f0fabaa"><div class="ttname"><a href="#adb392b63b56b74f3707e5e316f0fabaa">GraphMesh::extractId</a></div><div class="ttdeci">int extractId(const std::string &amp;name)</div><div class="ttdoc">Extracts ID number from physical group name.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:63</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ade42074c2b94f3675a3660289bb60b" name="a6ade42074c2b94f3675a3660289bb60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ade42074c2b94f3675a3660289bb60b">&#9670;&#160;</a></span>buildSplitAndPrintMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::buildSplitAndPrintMesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>targetPartSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>nodeEdgePortion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1311</span>                                                                                                               {</div>
<div class="line"><span class="lineno"> 1312</span>    <a class="code hl_function" href="#a136067707a44e48d8311772675a8d70f">loadMeshFromFile</a>(filename);</div>
<div class="line"><span class="lineno"> 1313</span> </div>
<div class="line"><span class="lineno"> 1314</span>    <a class="code hl_function" href="#aeb0da0f35d40771dc43748ccd50e61f3">buildGraphFromMesh</a>();</div>
<div class="line"><span class="lineno"> 1315</span> </div>
<div class="line"><span class="lineno"> 1316</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Initial Graph State:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1317</span>    <a class="code hl_function" href="#a36de5dd2ec6798d3163ffaf049247f20">printGraphState</a>();</div>
<div class="line"><span class="lineno"> 1318</span> </div>
<div class="line"><span class="lineno"> 1319</span>    <a class="code hl_struct" href="struct_part_graph.html">PartGraph</a> partGraph = <a class="code hl_function" href="#a457d2958e23b465070fa1e32b82c15b7">splitMesh</a>(targetPartSize, nodeEdgePortion);</div>
<div class="line"><span class="lineno"> 1320</span> </div>
<div class="line"><span class="lineno"> 1321</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\nSplit Mesh State:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1322</span>    <a class="code hl_function" href="#a3a6bc452bb6da7e0331305c58e186397">printPartGraphState</a>(partGraph);</div>
<div class="line"><span class="lineno"> 1323</span> </div>
<div class="line"><span class="lineno"> 1324</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\nPart Geometries:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1325</span>    <span class="keywordtype">int</span> count = 0;</div>
<div class="line"><span class="lineno"> 1326</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; part : partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>) {</div>
<div class="line"><span class="lineno"> 1327</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Part Type: &quot;</span> &lt;&lt; (part.type == <a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a> ? <span class="stringliteral">&quot;Node&quot;</span> : <span class="stringliteral">&quot;Edge&quot;</span>)</div>
<div class="line"><span class="lineno"> 1328</span>                  &lt;&lt; <span class="stringliteral">&quot;, ID: &quot;</span> &lt;&lt; part.id &lt;&lt; <span class="stringliteral">&quot;, SubID: &quot;</span> &lt;&lt; part.subId &lt;&lt; <span class="stringliteral">&quot;, Part Index: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1329</span> </div>
<div class="line"><span class="lineno"> 1330</span>        <span class="keyword">auto</span> geometry = <a class="code hl_function" href="#a27e1a725acf060f5a522e92843454134">getPartGeometry</a>(part);</div>
<div class="line"><span class="lineno"> 1331</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Value of poly_points is\n&quot;</span> &lt;&lt; geometry &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1332</span>        std::cout &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1333</span>        count++;</div>
<div class="line"><span class="lineno"> 1334</span>    }</div>
<div class="line"><span class="lineno"> 1335</span> </div>
<div class="line"><span class="lineno"> 1336</span>    <span class="keyword">auto</span> training_params = <a class="code hl_function" href="#af3907a12bfc1caa034e08aab62040864">getNNTrainingParams</a>(partGraph);</div>
<div class="line"><span class="lineno"> 1337</span>    <a class="code hl_function" href="#a23e7c3fc81e733eaa764b31be4f6df16">printTrainingParams</a>(training_params);</div>
<div class="line"><span class="lineno"> 1338</span> </div>
<div class="line"><span class="lineno"> 1339</span>    <span class="comment">// auto conditions = getCompatibilityConditions(partGraph);</span></div>
<div class="line"><span class="lineno"> 1340</span>    <span class="comment">// printCompatibilityConditions(conditions);</span></div>
<div class="line"><span class="lineno"> 1341</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1342</span>    <span class="comment">// auto geom_points = getGeometryPolynomialPoints(partGraph);</span></div>
<div class="line"><span class="lineno"> 1343</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1344</span>    <span class="comment">// auto [mesh_points, mesh_indices] = getMeshPolynomialPoints(partGraph, &quot;testNE3.msh&quot;, 1);</span></div>
<div class="line"><span class="lineno"> 1345</span>    <span class="comment">// printMeshData(geom_points, mesh_points, mesh_indices);</span></div>
<div class="line"><span class="lineno"> 1346</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1347</span>    <span class="comment">// auto mesh_parametrizations = getMeshParametrizations(partGraph, &quot;testNE3.msh&quot;, 1);</span></div>
<div class="line"><span class="lineno"> 1348</span>    <span class="comment">// auto geom_parametrizations = getGeometryParametrizations(partGraph);</span></div>
<div class="line"><span class="lineno"> 1349</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1350</span>    <span class="comment">// compareMeshParametrizationData(geom_parametrizations, mesh_parametrizations);</span></div>
<div class="line"><span class="lineno"> 1351</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1352</span>    <span class="comment">// auto centered_mesh_parametrizations = centerMeshParametrizations(mesh_parametrizations);</span></div>
<div class="line"><span class="lineno"> 1353</span>    <span class="comment">// compareMeshParametrizationData(mesh_parametrizations, centered_mesh_parametrizations);</span></div>
<div class="line"><span class="lineno"> 1354</span> </div>
<div class="line"><span class="lineno"> 1355</span>    <span class="comment">// auto centered_mesh_points = centerPointParametrizations(mesh_points);</span></div>
<div class="line"><span class="lineno"> 1356</span>    <span class="comment">// printMeshData(mesh_points, centered_mesh_points, mesh_indices);</span></div>
<div class="line"><span class="lineno"> 1357</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1358</span>    <span class="comment">// auto init_displacements = getInitialDisplacements(partGraph);</span></div>
<div class="line"><span class="lineno"> 1359</span>    <span class="comment">// printMeshParamsAndDisplacements(centered_mesh_parametrizations, init_displacements);</span></div>
<div class="line"><span class="lineno"> 1360</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1361</span>    <span class="comment">// std::vector&lt;std::pair&lt;int, Eigen::Vector4d&gt;&gt; test_displacements(3);</span></div>
<div class="line"><span class="lineno"> 1362</span>    <span class="comment">// Eigen::Vector4d disp1;</span></div>
<div class="line"><span class="lineno"> 1363</span>    <span class="comment">// disp1 &lt;&lt; -0.0002, -0.0002, -0.0001, 0.0001;</span></div>
<div class="line"><span class="lineno"> 1364</span>    <span class="comment">// Eigen::Vector4d disp2;</span></div>
<div class="line"><span class="lineno"> 1365</span>    <span class="comment">// disp2 &lt;&lt; -0.001,-0.001, -0.001, -0.001;</span></div>
<div class="line"><span class="lineno"> 1366</span>    <span class="comment">// Eigen::Vector4d disp3;</span></div>
<div class="line"><span class="lineno"> 1367</span>    <span class="comment">// disp3 &lt;&lt; 0.000, 0.000, 0.000, 0.000;</span></div>
<div class="line"><span class="lineno"> 1368</span>    <span class="comment">// test_displacements[0] = {1, disp1};</span></div>
<div class="line"><span class="lineno"> 1369</span>    <span class="comment">// test_displacements[1] = {2, disp2};</span></div>
<div class="line"><span class="lineno"> 1370</span>    <span class="comment">// test_displacements[2] = {3, disp3};</span></div>
<div class="line"><span class="lineno"> 1371</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1372</span>    <span class="comment">// calculationParams calc_params (5000000, 1000000000, 0.33, 0.05, 1);</span></div>
<div class="line"><span class="lineno"> 1373</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1374</span>    <span class="comment">// auto fixed_conditions = getFixedDisplacementConditions(partGraph, test_displacements);</span></div>
<div class="line"><span class="lineno"> 1375</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1376</span>    <span class="comment">// printFixedDisplacementConditions(fixed_conditions);</span></div>
<div class="line"><span class="lineno"> 1377</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1378</span>    <span class="comment">// auto disp_energy = meshFEMCalculation(&quot;testNE3.msh&quot;,</span></div>
<div class="line"><span class="lineno"> 1379</span>    <span class="comment">//     test_displacements, calc_params);</span></div>
<div class="line"><span class="lineno"> 1380</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1381</span>    <span class="comment">// std::cout &lt;&lt; &quot;The value of the true total energy change here is &quot; &lt;&lt; disp_energy.second &lt;&lt; std::endl;</span></div>
<div class="line"><span class="lineno"> 1382</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1383</span>    <span class="comment">// auto data = meshEnergy(partGraph, &quot;testNE3.msh&quot;, test_displacements, calc_params);</span></div>
<div class="line"><span class="lineno"> 1384</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1385</span>    <span class="comment">// printMeshParamsAndEnergies(data);</span></div>
<div class="line"><span class="lineno"> 1386</span> </div>
<div class="line"><span class="lineno"> 1387</span>}</div>
<div class="ttc" id="aclass_graph_mesh_html_a136067707a44e48d8311772675a8d70f"><div class="ttname"><a href="#a136067707a44e48d8311772675a8d70f">GraphMesh::loadMeshFromFile</a></div><div class="ttdeci">void loadMeshFromFile(const std::string &amp;filename)</div><div class="ttdoc">Loads mesh from file.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:73</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a23e7c3fc81e733eaa764b31be4f6df16"><div class="ttname"><a href="#a23e7c3fc81e733eaa764b31be4f6df16">GraphMesh::printTrainingParams</a></div><div class="ttdeci">void printTrainingParams(const NNTrainingParams &amp;params)</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:1461</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a27e1a725acf060f5a522e92843454134"><div class="ttname"><a href="#a27e1a725acf060f5a522e92843454134">GraphMesh::getPartGeometry</a></div><div class="ttdeci">Eigen::MatrixXd getPartGeometry(const MeshPart &amp;part)</div><div class="ttdoc">Gets geometry for a mesh part.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:1127</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a36de5dd2ec6798d3163ffaf049247f20"><div class="ttname"><a href="#a36de5dd2ec6798d3163ffaf049247f20">GraphMesh::printGraphState</a></div><div class="ttdeci">void printGraphState()</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:1389</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a3a6bc452bb6da7e0331305c58e186397"><div class="ttname"><a href="#a3a6bc452bb6da7e0331305c58e186397">GraphMesh::printPartGraphState</a></div><div class="ttdeci">void printPartGraphState(const PartGraph &amp;partGraph)</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:1426</div></div>
<div class="ttc" id="aclass_graph_mesh_html_a457d2958e23b465070fa1e32b82c15b7"><div class="ttname"><a href="#a457d2958e23b465070fa1e32b82c15b7">GraphMesh::splitMesh</a></div><div class="ttdeci">PartGraph splitMesh(double targetPartSize, double nodeEdgePortion)</div><div class="ttdoc">Splits mesh into parts.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:242</div></div>
<div class="ttc" id="aclass_graph_mesh_html_aeb0da0f35d40771dc43748ccd50e61f3"><div class="ttname"><a href="#aeb0da0f35d40771dc43748ccd50e61f3">GraphMesh::buildGraphFromMesh</a></div><div class="ttdeci">void buildGraphFromMesh()</div><div class="ttdoc">Constructs graph representation from mesh.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:115</div></div>
<div class="ttc" id="aclass_graph_mesh_html_af3907a12bfc1caa034e08aab62040864"><div class="ttname"><a href="#af3907a12bfc1caa034e08aab62040864">GraphMesh::getNNTrainingParams</a></div><div class="ttdeci">NNTrainingParams getNNTrainingParams(const PartGraph &amp;part_graph)</div><div class="ttdoc">Gets training parameters for neural network.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:678</div></div>
<div class="ttc" id="astruct_mesh_part_html_a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a"><div class="ttname"><a href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a></div><div class="ttdeci">@ NODE</div><div class="ttdef"><b>Definition</b> graph_mesh.h:162</div></div>
<div class="ttc" id="astruct_part_graph_html"><div class="ttname"><a href="struct_part_graph.html">PartGraph</a></div><div class="ttdoc">Graph representation of subdivided mesh.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:176</div></div>
<div class="ttc" id="astruct_part_graph_html_a97283d22bde3230f8cb4b56f053e9510"><div class="ttname"><a href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">PartGraph::parts</a></div><div class="ttdeci">std::vector&lt; MeshPart &gt; parts</div><div class="ttdoc">Mesh parts.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:177</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a7f1768822a8f276a5779d0bed22a38" name="a6a7f1768822a8f276a5779d0bed22a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7f1768822a8f276a5779d0bed22a38">&#9670;&#160;</a></span>centerMeshParametrizations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; GraphMesh::centerMeshParametrizations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>param_vector</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Centers parametrizations of type <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a>. </p>
<p>The returned vector is useful when optimizing the displacement vectors on a trained neural network. By centering these parametrizations at the origin, we ensure translation-invariance of the neural network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param_vector</td><td>Vector of parametrization data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of centered parametrization data </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  660</span>                                                            {</div>
<div class="line"><span class="lineno">  661</span>    std::vector&lt;MeshParametrizationData&gt; centered_param_vector;</div>
<div class="line"><span class="lineno">  662</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;param : param_vector) {</div>
<div class="line"><span class="lineno">  663</span>        Eigen::Vector2d center = <a class="code hl_function" href="namespace_data_operations.html#ab08b3135bf6da6012a8c83633d9e4b73">DataOperations::findCenter</a>(param);</div>
<div class="line"><span class="lineno">  664</span>        <a class="code hl_struct" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> centered_param (param);</div>
<div class="line"><span class="lineno">  665</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; param.numBranches; ++i) {</div>
<div class="line"><span class="lineno">  666</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 3; ++j) {</div>
<div class="line"><span class="lineno">  667</span>                centered_param.terminals.block&lt;2, 1&gt;(2 * i, j) =</div>
<div class="line"><span class="lineno">  668</span>                    centered_param.terminals.block&lt;2, 1&gt;(2 * i, j) - center;</div>
<div class="line"><span class="lineno">  669</span>            }</div>
<div class="line"><span class="lineno">  670</span>        }</div>
<div class="line"><span class="lineno">  671</span>        centered_param_vector.push_back(centered_param);</div>
<div class="line"><span class="lineno">  672</span>    }</div>
<div class="line"><span class="lineno">  673</span>    <span class="keywordflow">return</span> centered_param_vector;</div>
<div class="line"><span class="lineno">  674</span>}</div>
<div class="ttc" id="anamespace_data_operations_html_ab08b3135bf6da6012a8c83633d9e4b73"><div class="ttname"><a href="namespace_data_operations.html#ab08b3135bf6da6012a8c83633d9e4b73">DataOperations::findCenter</a></div><div class="ttdeci">Eigen::Vector2d findCenter(const MeshParametrizationData &amp;params)</div><div class="ttdoc">Finds the geometric centroid of a mesh parametrization.</div><div class="ttdef"><b>Definition</b> data_operations.cc:139</div></div>
<div class="ttc" id="astruct_mesh_parametrization_data_html"><div class="ttname"><a href="struct_mesh_parametrization_data.html">MeshParametrizationData</a></div><div class="ttdoc">Container for mesh parametrization geometric data.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:72</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a05e38d4ef4104faf709ec2c64146fdfb" name="a05e38d4ef4104faf709ec2c64146fdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e38d4ef4104faf709ec2c64146fdfb">&#9670;&#160;</a></span>centerPointParametrizations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::MatrixXd &gt; GraphMesh::centerPointParametrizations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point_vector</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Centers parametrizations containing the polynomial points. </p>
<p>The returned vector is useful when optimizing the displacement vectors on a trained neural network. By centering these parametrizations at the origin, we ensure translation-invariance of the neural network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_vector</td><td>Vector of point matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of centered point matrices </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  640</span>                                                                                                            {</div>
<div class="line"><span class="lineno">  641</span>    std::vector&lt;Eigen::MatrixXd&gt; centered_point_vector;</div>
<div class="line"><span class="lineno">  642</span> </div>
<div class="line"><span class="lineno">  643</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;points : point_vector) {</div>
<div class="line"><span class="lineno">  644</span>        Eigen::Vector2d center = <a class="code hl_function" href="namespace_data_operations.html#ab08b3135bf6da6012a8c83633d9e4b73">DataOperations::findCenter</a>(<a class="code hl_function" href="namespace_mesh_parametrization.html#a30780085192c00fff5bcb5e554dccff5">MeshParametrization::pointToParametrization</a>(points));</div>
<div class="line"><span class="lineno">  645</span>        Eigen::MatrixXd centered_points (points);</div>
<div class="line"><span class="lineno">  646</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; points.rows() / 2; ++i) {</div>
<div class="line"><span class="lineno">  647</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 3; ++j) {</div>
<div class="line"><span class="lineno">  648</span>                centered_points.block&lt;2, 1&gt;(2 * i, j) =</div>
<div class="line"><span class="lineno">  649</span>                    centered_points.block&lt;2, 1&gt;(2 * i, j) - center;</div>
<div class="line"><span class="lineno">  650</span>            }</div>
<div class="line"><span class="lineno">  651</span>        }</div>
<div class="line"><span class="lineno">  652</span>        centered_point_vector.push_back(centered_points);</div>
<div class="line"><span class="lineno">  653</span>    }</div>
<div class="line"><span class="lineno">  654</span>    <span class="keywordflow">return</span> centered_point_vector;</div>
<div class="line"><span class="lineno">  655</span>}</div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a30780085192c00fff5bcb5e554dccff5"><div class="ttname"><a href="namespace_mesh_parametrization.html#a30780085192c00fff5bcb5e554dccff5">MeshParametrization::pointToParametrization</a></div><div class="ttdeci">MeshParametrizationData pointToParametrization(const Eigen::MatrixXd &amp;poly_points)</div><div class="ttdoc">Converts polynomial points to mesh parametrization.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:258</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aae89bff77790a2b075b81fbb930c8daf" name="aae89bff77790a2b075b81fbb930c8daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae89bff77790a2b075b81fbb930c8daf">&#9670;&#160;</a></span>closeMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::closeMesh </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes mesh construction. </p>
<div class="fragment"><div class="line"><span class="lineno">  102</span>                          {</div>
<div class="line"><span class="lineno">  103</span>    <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">  104</span>        gmsh::clear();</div>
<div class="line"><span class="lineno">  105</span>        gmsh::finalize();</div>
<div class="line"><span class="lineno">  106</span>    }</div>
<div class="line"><span class="lineno">  107</span>    <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error &amp;e) {</div>
<div class="line"><span class="lineno">  108</span>        std::cerr &lt;&lt; <span class="stringliteral">&quot;Gmsh error: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  109</span>    }</div>
<div class="line"><span class="lineno">  110</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b0b3734921da617cfeb8f3036c6eee3" name="a7b0b3734921da617cfeb8f3036c6eee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0b3734921da617cfeb8f3036c6eee3">&#9670;&#160;</a></span>compareMeshParametrizationData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::compareMeshParametrizationData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1506</span>                                                                                     {</div>
<div class="line"><span class="lineno"> 1507</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; data1.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1508</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; d1 = data1[i];</div>
<div class="line"><span class="lineno"> 1509</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; d2 = data2[i];</div>
<div class="line"><span class="lineno"> 1510</span> </div>
<div class="line"><span class="lineno"> 1511</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Comparison of MeshParametrizationData &quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1512</span> </div>
<div class="line"><span class="lineno"> 1513</span>        <span class="comment">// Compare numBranches</span></div>
<div class="line"><span class="lineno"> 1514</span>        std::cout &lt;&lt; std::setw(20) &lt;&lt; <span class="stringliteral">&quot;numBranches:&quot;</span> &lt;&lt; std::setw(10) &lt;&lt; d1.numBranches</div>
<div class="line"><span class="lineno"> 1515</span>                  &lt;&lt; std::setw(10) &lt;&lt; d2.numBranches &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1516</span> </div>
<div class="line"><span class="lineno"> 1517</span>        <span class="comment">// Compare widths</span></div>
<div class="line"><span class="lineno"> 1518</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Widths:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1519</span>        <a class="code hl_function" href="#a87c4a6bf9b71266ad65a5e0274a70390">printMatrixComparison</a>(d1.widths, d2.widths);</div>
<div class="line"><span class="lineno"> 1520</span>        <span class="comment">// Compare terminals</span></div>
<div class="line"><span class="lineno"> 1521</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Terminals:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1522</span>        <a class="code hl_function" href="#a87c4a6bf9b71266ad65a5e0274a70390">printMatrixComparison</a>(d1.terminals, d2.terminals);</div>
<div class="line"><span class="lineno"> 1523</span>        <span class="comment">// Compare vectors</span></div>
<div class="line"><span class="lineno"> 1524</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Vectors:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1525</span>        <a class="code hl_function" href="#a87c4a6bf9b71266ad65a5e0274a70390">printMatrixComparison</a>(d1.vectors, d2.vectors);</div>
<div class="line"><span class="lineno"> 1526</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1527</span>    }</div>
<div class="line"><span class="lineno"> 1528</span>}</div>
<div class="ttc" id="aclass_graph_mesh_html_a87c4a6bf9b71266ad65a5e0274a70390"><div class="ttname"><a href="#a87c4a6bf9b71266ad65a5e0274a70390">GraphMesh::printMatrixComparison</a></div><div class="ttdeci">void printMatrixComparison(const Eigen::MatrixXd &amp;m1, const Eigen::MatrixXd &amp;m2)</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:1530</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad522efd135fa5daecba00eeeaffcb940" name="ad522efd135fa5daecba00eeeaffcb940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad522efd135fa5daecba00eeeaffcb940">&#9670;&#160;</a></span>determineSplineOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GraphMesh::determineSplineOrientation </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>splineTag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sharedLineTag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines spline orientation relative to node. </p>
<p>Splines are parametrized in Gmsh on the interval [0, 1], this function helps to determine on which node the 0 begins, so we can query the correct portion of a spline when extrapolating a part's geometry </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">splineTag</td><td>Spline tag </td></tr>
    <tr><td class="paramname">sharedLineTag</td><td>Shared line tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Orientation indicator (1 or -1) </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  488</span>                                                                          {</div>
<div class="line"><span class="lineno">  489</span>    std::vector&lt;std::pair&lt;int, int&gt;&gt; splinePoints, linePoints;</div>
<div class="line"><span class="lineno">  490</span>    gmsh::model::getBoundary({{1, splineTag}}, splinePoints, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  491</span>    gmsh::model::getBoundary({{1, sharedLineTag}}, linePoints, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  492</span> </div>
<div class="line"><span class="lineno">  493</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;The splineTag is &quot;</span> &lt;&lt; splineTag &lt;&lt; <span class="stringliteral">&quot; and the line tag is &quot;</span> &lt;&lt; sharedLineTag &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  495</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;splinePoints contents:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  496</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : splinePoints) {</div>
<div class="line"><span class="lineno">  497</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  498</span>    }</div>
<div class="line"><span class="lineno">  499</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;linePoints contents:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  500</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : linePoints) {</div>
<div class="line"><span class="lineno">  501</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  502</span>    }</div>
<div class="line"><span class="lineno">  503</span> </div>
<div class="line"><span class="lineno">  504</span>    <span class="comment">// Check if the start point of the spline is on the shared line, then it is oriented in the way we want</span></div>
<div class="line"><span class="lineno">  505</span>    <span class="keywordtype">bool</span> splineStartOnLine = (splinePoints[0].second == linePoints[0].second) ||</div>
<div class="line"><span class="lineno">  506</span>            (splinePoints[0].second == linePoints[1].second);</div>
<div class="line"><span class="lineno">  507</span>    <span class="keywordflow">return</span> splineStartOnLine ? 1 : -1;</div>
<div class="line"><span class="lineno">  508</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7ca5f97b6538e7c87e7b7895f6851645" name="a7ca5f97b6538e7c87e7b7895f6851645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca5f97b6538e7c87e7b7895f6851645">&#9670;&#160;</a></span>extractBCId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GraphMesh::extractBCId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts boundary condition ID from name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String containing BC ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Extracted BC ID number </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   67</span>                                                {</div>
<div class="line"><span class="lineno">   68</span>    <span class="keywordflow">return</span> std::stoi(name.substr(2));</div>
<div class="line"><span class="lineno">   69</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adb392b63b56b74f3707e5e316f0fabaa" name="adb392b63b56b74f3707e5e316f0fabaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb392b63b56b74f3707e5e316f0fabaa">&#9670;&#160;</a></span>extractId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GraphMesh::extractId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts ID number from physical group name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String containing ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Extracted ID number </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   63</span>                                              {</div>
<div class="line"><span class="lineno">   64</span>    <span class="keywordflow">return</span> std::stoi(name.substr(<a class="code hl_function" href="#a218e4502de90e51bacd6d2cdda8ef559">isNodeBoundary</a>(name) or <a class="code hl_function" href="#a78e0be86a3fbb160365bddb63396e8e8">isEdgeBoundary</a>(name) ? 2 : 1));</div>
<div class="line"><span class="lineno">   65</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae6d37ebae2f4bee3913773d9951aed6d" name="ae6d37ebae2f4bee3913773d9951aed6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d37ebae2f4bee3913773d9951aed6d">&#9670;&#160;</a></span>findSharedLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GraphMesh::findSharedLine </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodeBoundaryTags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edgeBoundaryTags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds shared boundary line between an edge an a node. </p>
<p>As specified in the geometry of an overall mesh, a curve of type Line will separate an edge from its node part, and this functions finds the tag of that line to know the direction of orientation of node -&gt; edge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeBoundaryTags</td><td>Node boundary tags </td></tr>
    <tr><td class="paramname">edgeBoundaryTags</td><td>Edge boundary tags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared line tag </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  451</span>                                                                                                            {</div>
<div class="line"><span class="lineno">  452</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nodeTag : nodeBoundaryTags) {</div>
<div class="line"><span class="lineno">  453</span>        <span class="comment">// Check if this node tag is shared with the edge boundary tags</span></div>
<div class="line"><span class="lineno">  454</span>        <span class="keywordflow">if</span> (std::find(edgeBoundaryTags.begin(), edgeBoundaryTags.end(), nodeTag) != edgeBoundaryTags.end()) {</div>
<div class="line"><span class="lineno">  455</span>            <span class="comment">// Verify that this is indeed a line curve</span></div>
<div class="line"><span class="lineno">  456</span>            <span class="keywordflow">return</span> nodeTag;</div>
<div class="line"><span class="lineno">  457</span>        }</div>
<div class="line"><span class="lineno">  458</span>    }</div>
<div class="line"><span class="lineno">  459</span>    <span class="keywordflow">return</span> -1; <span class="comment">// No shared line found, should never be reached ideally, unless a naming error has occurred with the original mesh</span></div>
<div class="line"><span class="lineno">  460</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aec778de2b75006ca9dfd067d6fe78f01" name="aec778de2b75006ca9dfd067d6fe78f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec778de2b75006ca9dfd067d6fe78f01">&#9670;&#160;</a></span>findSplineCurves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; GraphMesh::findSplineCurves </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edgeBoundaryTags</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds spline curves in boundary tags of an edge. </p>
<p>Knowing that the only allowed types for the spline are of type "Nurb", the curves are returned accordingly </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeBoundaryTags</td><td>Edge boundary tags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of spline curve tags </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  464</span>                                                                                 {</div>
<div class="line"><span class="lineno">  465</span> </div>
<div class="line"><span class="lineno">  466</span>    std::vector&lt;int&gt; splineTags;</div>
<div class="line"><span class="lineno">  467</span>    std::string curveType;</div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="line"><span class="lineno">  469</span>    <span class="comment">// Print contents of the two vectors for later testing</span></div>
<div class="line"><span class="lineno">  470</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;edgeBoundaryTags contents:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  471</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : edgeBoundaryTags) {</div>
<div class="line"><span class="lineno">  472</span>        std::cout &lt;&lt; pair &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  473</span>    }</div>
<div class="line"><span class="lineno">  474</span> </div>
<div class="line"><span class="lineno">  475</span>    <span class="comment">// iterate through edgeBoundary tags to find which ones are the splines</span></div>
<div class="line"><span class="lineno">  476</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edgeTag : edgeBoundaryTags) {</div>
<div class="line"><span class="lineno">  477</span>        gmsh::model::getType(1, edgeTag, curveType);</div>
<div class="line"><span class="lineno">  478</span>        <span class="keywordflow">if</span> (curveType == <span class="stringliteral">&quot;Nurb&quot;</span>) {</div>
<div class="line"><span class="lineno">  479</span>            splineTags.emplace_back(edgeTag);</div>
<div class="line"><span class="lineno">  480</span>        }</div>
<div class="line"><span class="lineno">  481</span>    }</div>
<div class="line"><span class="lineno">  482</span> </div>
<div class="line"><span class="lineno">  483</span>    <span class="keywordflow">return</span> splineTags;</div>
<div class="line"><span class="lineno">  484</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aebe58192125ecaa4193b92519493ded6" name="aebe58192125ecaa4193b92519493ded6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe58192125ecaa4193b92519493ded6">&#9670;&#160;</a></span>getCompatibilityConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_compatibility_condition.html">CompatibilityCondition</a> &gt; GraphMesh::getCompatibilityConditions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part_graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets compatibility conditions between parts. </p>
<p>Adjacent graph parts will need to have identical displacement vectors on the line that they share, this function returns a vector of data structures containing indices such that these conditions can be checked </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_graph</td><td>Graph of mesh parts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of compatibility conditions </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  759</span>                                                                                                   {</div>
<div class="line"><span class="lineno">  760</span>    std::vector&lt;CompatibilityCondition&gt; compatibility_conditions;</div>
<div class="line"><span class="lineno">  761</span>    std::unordered_set&lt;std::pair&lt;int, int&gt;, <a class="code hl_struct" href="struct_int_pair_hash.html">IntPairHash</a>, <a class="code hl_struct" href="struct_int_pair_equal.html">IntPairEqual</a>&gt; processed_conditions;</div>
<div class="line"><span class="lineno">  762</span> </div>
<div class="line"><span class="lineno">  763</span>    <span class="comment">// Lambda expression to check if we&#39;ve already added this condition or not previously</span></div>
<div class="line"><span class="lineno">  764</span>    <span class="keyword">auto</span> process_condition = [&amp;processed_conditions](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line"><span class="lineno">  765</span>        std::pair&lt;int, int&gt; current_condition = {std::min(a, b), std::max(a, b)};</div>
<div class="line"><span class="lineno">  766</span>        <span class="keywordflow">if</span> (processed_conditions.find(current_condition) == processed_conditions.end()) {</div>
<div class="line"><span class="lineno">  767</span>            processed_conditions.insert(current_condition);</div>
<div class="line"><span class="lineno">  768</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  769</span>        }</div>
<div class="line"><span class="lineno">  770</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  771</span>    };</div>
<div class="line"><span class="lineno">  772</span> </div>
<div class="line"><span class="lineno">  773</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.size(); i++) {</div>
<div class="line"><span class="lineno">  774</span>        <a class="code hl_struct" href="struct_mesh_part.html">MeshPart</a> part = part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>[i];</div>
<div class="line"><span class="lineno">  775</span> </div>
<div class="line"><span class="lineno">  776</span>        <span class="keywordflow">if</span> (part.<a class="code hl_variable" href="struct_mesh_part.html#ac2e2df82f1c9a6898bea7a6ad0f11a3a">type</a> == <a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a>) {</div>
<div class="line"><span class="lineno">  777</span>            <span class="comment">// Need to iterate through all connected parts for this node</span></div>
<div class="line"><span class="lineno">  778</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i].size(); j++) {</div>
<div class="line"><span class="lineno">  779</span> </div>
<div class="line"><span class="lineno">  780</span>                <span class="comment">// If we have not processed this condition yet, we do it now</span></div>
<div class="line"><span class="lineno">  781</span>                <span class="keywordflow">if</span> (process_condition(i, part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j])) {</div>
<div class="line"><span class="lineno">  782</span> </div>
<div class="line"><span class="lineno">  783</span>                    <span class="keywordflow">if</span> (part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].type == <a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a>) {</div>
<div class="line"><span class="lineno">  784</span> </div>
<div class="line"><span class="lineno">  785</span>                        <span class="comment">// Find the position of our node i within the adjacent node&#39;s adjacency list</span></div>
<div class="line"><span class="lineno">  786</span>                        <span class="keyword">auto</span> it =</div>
<div class="line"><span class="lineno">  787</span>                            std::find(part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].begin(),</div>
<div class="line"><span class="lineno">  788</span>                            part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].end(), i);</div>
<div class="line"><span class="lineno">  789</span> </div>
<div class="line"><span class="lineno">  790</span>                        LF_ASSERT_MSG(it != part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].end(),</div>
<div class="line"><span class="lineno">  791</span>                            <span class="stringliteral">&quot;Two nodes are connected in the part graph, but their adjacency lists are incorrect&quot;</span>);</div>
<div class="line"><span class="lineno">  792</span>                        <span class="keywordtype">int</span> index = std::distance(part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].begin(), it);</div>
<div class="line"><span class="lineno">  793</span> </div>
<div class="line"><span class="lineno">  794</span>                        std::pair&lt;int, int&gt; indices {i, part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]};</div>
<div class="line"><span class="lineno">  795</span>                        std::pair&lt;int, int&gt; first {j, 0};</div>
<div class="line"><span class="lineno">  796</span>                        std::pair&lt;int, int&gt; second {index, 0};</div>
<div class="line"><span class="lineno">  797</span>                        compatibility_conditions.emplace_back(indices, first, second);</div>
<div class="line"><span class="lineno">  798</span>                    }</div>
<div class="line"><span class="lineno">  799</span>                    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  800</span>                        <span class="comment">// Since this adjacent part is an edge, we must check if the node is first or second in the</span></div>
<div class="line"><span class="lineno">  801</span>                        <span class="comment">// corresponding graph to see which side the equivalent points are on</span></div>
<div class="line"><span class="lineno">  802</span>                        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge = <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].id];</div>
<div class="line"><span class="lineno">  803</span>                        <span class="keywordtype">bool</span> is_first_node = (edge.connectedNodes[0] == part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>[i].id);</div>
<div class="line"><span class="lineno">  804</span> </div>
<div class="line"><span class="lineno">  805</span>                        <span class="comment">// Initialize the pairs that will make up this compatibility condition</span></div>
<div class="line"><span class="lineno">  806</span>                        std::pair&lt;int, int&gt; indices {i, part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]};</div>
<div class="line"><span class="lineno">  807</span>                        std::pair&lt;int, int&gt; first {j, 0};</div>
<div class="line"><span class="lineno">  808</span>                        std::pair&lt;int, int&gt; second {0, is_first_node ? 0 : 1};</div>
<div class="line"><span class="lineno">  809</span>                        compatibility_conditions.emplace_back(indices, first, second);</div>
<div class="line"><span class="lineno">  810</span>                    }</div>
<div class="line"><span class="lineno">  811</span>                }</div>
<div class="line"><span class="lineno">  812</span>            }</div>
<div class="line"><span class="lineno">  813</span>        }</div>
<div class="line"><span class="lineno">  814</span> </div>
<div class="line"><span class="lineno">  815</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  816</span>            <span class="comment">// Need to iterate through all connected parts for this node</span></div>
<div class="line"><span class="lineno">  817</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i].size(); j++) {</div>
<div class="line"><span class="lineno">  818</span>                <span class="comment">// If we have not processed this condition yet, we do it now</span></div>
<div class="line"><span class="lineno">  819</span>                <span class="keywordflow">if</span> (process_condition(i, part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j])) {</div>
<div class="line"><span class="lineno">  820</span> </div>
<div class="line"><span class="lineno">  821</span>                    <span class="keywordflow">if</span> (part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].type == <a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a>) {</div>
<div class="line"><span class="lineno">  822</span>                        <span class="keyword">auto</span> it =</div>
<div class="line"><span class="lineno">  823</span>                            std::find(part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].begin(),</div>
<div class="line"><span class="lineno">  824</span>                            part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].end(), i);</div>
<div class="line"><span class="lineno">  825</span>                        LF_ASSERT_MSG(it != part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].end(),</div>
<div class="line"><span class="lineno">  826</span>                        <span class="stringliteral">&quot;An edge is connected to a node in the part graph, but their adjacency lists are incorrect&quot;</span>);</div>
<div class="line"><span class="lineno">  827</span> </div>
<div class="line"><span class="lineno">  828</span>                        <span class="keywordtype">int</span> index = std::distance(part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].begin(), it);</div>
<div class="line"><span class="lineno">  829</span>                        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge = <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>[i].id];</div>
<div class="line"><span class="lineno">  830</span>                        <span class="keywordtype">bool</span> is_first_node = (edge.connectedNodes[0] == part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>[i].id);</div>
<div class="line"><span class="lineno">  831</span> </div>
<div class="line"><span class="lineno">  832</span>                        std::pair&lt;int, int&gt; indices {i, part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]};</div>
<div class="line"><span class="lineno">  833</span>                        std::pair&lt;int, int&gt; first {0, is_first_node ? 0 : 1};</div>
<div class="line"><span class="lineno">  834</span>                        std::pair&lt;int, int&gt; second {index, 1};</div>
<div class="line"><span class="lineno">  835</span>                        compatibility_conditions.emplace_back(indices, first, second);</div>
<div class="line"><span class="lineno">  836</span>                    }</div>
<div class="line"><span class="lineno">  837</span>                    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  838</span>                        <span class="keywordtype">bool</span> is_first_part = part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>[i].subId &lt;</div>
<div class="line"><span class="lineno">  839</span>                            part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>[part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]].subId;</div>
<div class="line"><span class="lineno">  840</span> </div>
<div class="line"><span class="lineno">  841</span>                        std::pair&lt;int, int&gt; indices {i, part_graph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i][j]};</div>
<div class="line"><span class="lineno">  842</span>                        std::pair&lt;int, int&gt; first {0, is_first_part ? 1 : 0};</div>
<div class="line"><span class="lineno">  843</span>                        std::pair&lt;int, int&gt; second {0, is_first_part ? 0 : 1};</div>
<div class="line"><span class="lineno">  844</span>                        compatibility_conditions.emplace_back(indices, first, second);</div>
<div class="line"><span class="lineno">  845</span>                    }</div>
<div class="line"><span class="lineno">  846</span>                }</div>
<div class="line"><span class="lineno">  847</span>            }</div>
<div class="line"><span class="lineno">  848</span>        }</div>
<div class="line"><span class="lineno">  849</span>    }</div>
<div class="line"><span class="lineno">  850</span>    <span class="keywordflow">return</span> compatibility_conditions;</div>
<div class="line"><span class="lineno">  851</span>}</div>
<div class="ttc" id="astruct_int_pair_equal_html"><div class="ttname"><a href="struct_int_pair_equal.html">IntPairEqual</a></div><div class="ttdoc">Equality comparison for integer pairs.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:84</div></div>
<div class="ttc" id="astruct_int_pair_hash_html"><div class="ttname"><a href="struct_int_pair_hash.html">IntPairHash</a></div><div class="ttdoc">Hash function for integer pairs.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:72</div></div>
<div class="ttc" id="astruct_mesh_part_html"><div class="ttname"><a href="struct_mesh_part.html">MeshPart</a></div><div class="ttdoc">Part of a subdivided mesh, either node or edge.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:161</div></div>
<div class="ttc" id="astruct_mesh_part_html_ac2e2df82f1c9a6898bea7a6ad0f11a3a"><div class="ttname"><a href="struct_mesh_part.html#ac2e2df82f1c9a6898bea7a6ad0f11a3a">MeshPart::type</a></div><div class="ttdeci">enum MeshPart::Type type</div><div class="ttdoc">Part type (node or edge)</div></div>
<div class="ttc" id="astruct_part_graph_html_a5f328f00e2022805dfc1eb80ae8ef3f4"><div class="ttname"><a href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">PartGraph::adjacencyList</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; size_t &gt; &gt; adjacencyList</div><div class="ttdoc">Connectivity graph.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:178</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a189c38ee8966659c6bcbdfc70ca4f85d" name="a189c38ee8966659c6bcbdfc70ca4f85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189c38ee8966659c6bcbdfc70ca4f85d">&#9670;&#160;</a></span>getConnectedEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; int &gt; GraphMesh::getConnectedEdges </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nodeId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets edges connected to a node. </p>
<p>Uses <a class="el" href="class_graph_mesh.html">GraphMesh</a> fields to obtain the connected edges </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>Node identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set of connected edge IDs </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1240</span>                                                   {</div>
<div class="line"><span class="lineno"> 1241</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>[nodeId].connectedEdges;</div>
<div class="line"><span class="lineno"> 1242</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac50a12679d36cf91148589bb5d1d80c8" name="ac50a12679d36cf91148589bb5d1d80c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50a12679d36cf91148589bb5d1d80c8">&#9670;&#160;</a></span>getConnectedNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; int &gt; GraphMesh::getConnectedNodes </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nodeId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets nodes connected to a node. </p>
<p>Uses <a class="el" href="class_graph_mesh.html">GraphMesh</a> fields to obtain the connected nodes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>Node identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set of connected node IDs </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1249</span>                                                   {</div>
<div class="line"><span class="lineno"> 1250</span>    std::set&lt;int&gt; connectedNodes;</div>
<div class="line"><span class="lineno"> 1251</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edgeId : <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>[nodeId].connectedEdges) {</div>
<div class="line"><span class="lineno"> 1252</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edgeNodes = <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[edgeId].connectedNodes;</div>
<div class="line"><span class="lineno"> 1253</span>        connectedNodes.insert(edgeNodes.begin(), edgeNodes.end());</div>
<div class="line"><span class="lineno"> 1254</span>    }</div>
<div class="line"><span class="lineno"> 1255</span>    connectedNodes.erase(nodeId);</div>
<div class="line"><span class="lineno"> 1256</span>    <span class="keywordflow">return</span> connectedNodes;</div>
<div class="line"><span class="lineno"> 1257</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a94e1768ffaa85a7754ee44392b1d47e8" name="a94e1768ffaa85a7754ee44392b1d47e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e1768ffaa85a7754ee44392b1d47e8">&#9670;&#160;</a></span>getEdgeBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; GraphMesh::getEdgeBoundary </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>edgeId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets boundary tags for an edge. </p>
<p>Uses <a class="el" href="class_graph_mesh.html">GraphMesh</a> fields to obtain the edge boundary tags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeId</td><td>Edge identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of boundary tags </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1271</span>                                                    {</div>
<div class="line"><span class="lineno"> 1272</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[edgeId].boundaryTags;</div>
<div class="line"><span class="lineno"> 1273</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abc53123269ec018b2484e359590ca186" name="abc53123269ec018b2484e359590ca186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc53123269ec018b2484e359590ca186">&#9670;&#160;</a></span>getEdgeLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GraphMesh::getEdgeLength </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>edgeId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets length of an edge. </p>
<p>Repeatedly queries the spline curves of this edge to obtain an approximate length </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeId</td><td>Edge identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Edge length </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1189</span>                                          {</div>
<div class="line"><span class="lineno"> 1190</span> </div>
<div class="line"><span class="lineno"> 1191</span>    <span class="comment">// Find the spline curves of this edge</span></div>
<div class="line"><span class="lineno"> 1192</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge = <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>.at(edgeId);</div>
<div class="line"><span class="lineno"> 1193</span>    std::vector&lt;int&gt; splineTags = <a class="code hl_function" href="#aec778de2b75006ca9dfd067d6fe78f01">findSplineCurves</a>(edge.boundaryTags);</div>
<div class="line"><span class="lineno"> 1194</span> </div>
<div class="line"><span class="lineno"> 1195</span>    <span class="keywordtype">double</span> totalLength = 0.0;</div>
<div class="line"><span class="lineno"> 1196</span>    <span class="comment">// Iterate through both splines to find the length of each one</span></div>
<div class="line"><span class="lineno"> 1197</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> splineTag : splineTags) {</div>
<div class="line"><span class="lineno"> 1198</span>        std::vector&lt;double&gt; tMin, tMax;</div>
<div class="line"><span class="lineno"> 1199</span>        gmsh::model::getParametrizationBounds(1, splineTag, tMin, tMax);</div>
<div class="line"><span class="lineno"> 1200</span> </div>
<div class="line"><span class="lineno"> 1201</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;For splineTag &quot;</span> &lt;&lt; splineTag &lt;&lt; <span class="stringliteral">&quot; the min params are &quot;</span> &lt;&lt; tMin[0] &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1202</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;For splineTag &quot;</span> &lt;&lt; splineTag &lt;&lt; <span class="stringliteral">&quot; the max params are &quot;</span> &lt;&lt; tMax[0] &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1203</span> </div>
<div class="line"><span class="lineno"> 1204</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> numSamples = 10; <span class="comment">// Adjust this for better approximation</span></div>
<div class="line"><span class="lineno"> 1205</span>        <span class="keywordtype">double</span> splineLength = 0.0;</div>
<div class="line"><span class="lineno"> 1206</span>        std::vector&lt;double&gt; prevPoint;</div>
<div class="line"><span class="lineno"> 1207</span> </div>
<div class="line"><span class="lineno"> 1208</span>        <span class="comment">// We loop through the spline and add up lengths given by the points</span></div>
<div class="line"><span class="lineno"> 1209</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;= numSamples; ++i) {</div>
<div class="line"><span class="lineno"> 1210</span>            <span class="keywordtype">double</span> t = tMin[0] + (tMax[0] - tMin[0]) * i / numSamples;</div>
<div class="line"><span class="lineno"> 1211</span>            std::vector&lt;double&gt; point;</div>
<div class="line"><span class="lineno"> 1212</span>            gmsh::model::getValue(1, splineTag, {t}, point);</div>
<div class="line"><span class="lineno"> 1213</span> </div>
<div class="line"><span class="lineno"> 1214</span> </div>
<div class="line"><span class="lineno"> 1215</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;Value of t is &quot;</span> &lt;&lt; t &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1216</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;Value of point is &quot;</span> &lt;&lt; point[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; point[1] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; point[2] &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1217</span> </div>
<div class="line"><span class="lineno"> 1218</span>            <span class="keywordflow">if</span> (i &gt; 0) {</div>
<div class="line"><span class="lineno"> 1219</span>                <span class="keywordtype">double</span> segmentLength = std::sqrt(</div>
<div class="line"><span class="lineno"> 1220</span>                        std::pow(point[0] - prevPoint[0], 2) +</div>
<div class="line"><span class="lineno"> 1221</span>                        std::pow(point[1] - prevPoint[1], 2) +</div>
<div class="line"><span class="lineno"> 1222</span>                        std::pow(point[2] - prevPoint[2], 2)</div>
<div class="line"><span class="lineno"> 1223</span>                );</div>
<div class="line"><span class="lineno"> 1224</span>                splineLength += segmentLength;</div>
<div class="line"><span class="lineno"> 1225</span>                std::cout &lt;&lt; <span class="stringliteral">&quot;Segment length added on this iteration is &quot;</span> &lt;&lt; segmentLength &lt;&lt; <span class="stringliteral">&quot; with total length being &quot;</span> &lt;&lt; splineLength &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1226</span>            }</div>
<div class="line"><span class="lineno"> 1227</span> </div>
<div class="line"><span class="lineno"> 1228</span>            prevPoint = point;</div>
<div class="line"><span class="lineno"> 1229</span>        }</div>
<div class="line"><span class="lineno"> 1230</span> </div>
<div class="line"><span class="lineno"> 1231</span>        totalLength += splineLength;</div>
<div class="line"><span class="lineno"> 1232</span>    }</div>
<div class="line"><span class="lineno"> 1233</span> </div>
<div class="line"><span class="lineno"> 1234</span>    <span class="comment">// We want the average of the two splines approximately</span></div>
<div class="line"><span class="lineno"> 1235</span>    <span class="keywordflow">return</span> totalLength / splineTags.size();</div>
<div class="line"><span class="lineno"> 1236</span>}</div>
<div class="ttc" id="aclass_graph_mesh_html_aec778de2b75006ca9dfd067d6fe78f01"><div class="ttname"><a href="#aec778de2b75006ca9dfd067d6fe78f01">GraphMesh::findSplineCurves</a></div><div class="ttdeci">std::vector&lt; int &gt; findSplineCurves(const std::vector&lt; int &gt; &amp;edgeBoundaryTags)</div><div class="ttdoc">Finds spline curves in boundary tags of an edge.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:464</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac67a3e31d7aebdc8128887c585fa95d4" name="ac67a3e31d7aebdc8128887c585fa95d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67a3e31d7aebdc8128887c585fa95d4">&#9670;&#160;</a></span>getEdgeSurfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; GraphMesh::getEdgeSurfaces </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>edgeId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets surface tags for an edge. </p>
<p>Uses <a class="el" href="class_graph_mesh.html">GraphMesh</a> fields to obtain the edge surface tags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeId</td><td>Edge identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of surface tags </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1267</span>                                                    {</div>
<div class="line"><span class="lineno"> 1268</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[edgeId].surfaceTags;</div>
<div class="line"><span class="lineno"> 1269</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a866398fc97666239b0bcdf918ce580cb" name="a866398fc97666239b0bcdf918ce580cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866398fc97666239b0bcdf918ce580cb">&#9670;&#160;</a></span>getFixedDisplacementConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_fixed_displacement_condition.html">FixedDisplacementCondition</a> &gt; GraphMesh::getFixedDisplacementConditions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part_graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, Eigen::Vector4d &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>displacements</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets fixed displacement conditions. </p>
<p>Use the additional "free" edges that do not have compatbility conditions, displacement boundary conditions can be fixed with this function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_graph</td><td>Graph of mesh parts </td></tr>
    <tr><td class="paramname">displacements</td><td>Vector of numeric displacement specifications, the integer is the id of the physical group and the vector contains the actual displacement boundary conditions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of displacement conditions of type <a class="el" href="struct_fixed_displacement_condition.html">FixedDisplacementCondition</a> </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  857</span>                                                                                                  {</div>
<div class="line"><span class="lineno">  858</span> </div>
<div class="line"><span class="lineno">  859</span>    std::vector&lt;int&gt; possible_parametrizations(part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.size(), 0);</div>
<div class="line"><span class="lineno">  860</span>    <span class="keyword">auto</span> compatibility_conditions = <a class="code hl_function" href="#aebe58192125ecaa4193b92519493ded6">getCompatibilityConditions</a>(part_graph);</div>
<div class="line"><span class="lineno">  861</span> </div>
<div class="line"><span class="lineno">  862</span>    <span class="comment">// Iterate through all compatibility conditions to see which ones only have 1, as these are the parametrizations</span></div>
<div class="line"><span class="lineno">  863</span>    <span class="comment">// that can be fixed displacement BCs</span></div>
<div class="line"><span class="lineno">  864</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [indices, first, second] : compatibility_conditions) {</div>
<div class="line"><span class="lineno">  865</span>        possible_parametrizations[indices.first]++;</div>
<div class="line"><span class="lineno">  866</span>        possible_parametrizations[indices.second]++;</div>
<div class="line"><span class="lineno">  867</span>    }</div>
<div class="line"><span class="lineno">  868</span> </div>
<div class="line"><span class="lineno">  869</span>    <span class="comment">// We&#39;re able to get the geometric parametrizations because the used points will match the actual</span></div>
<div class="line"><span class="lineno">  870</span>    <span class="comment">// mesh parametrizations</span></div>
<div class="line"><span class="lineno">  871</span>    <span class="keyword">auto</span> parametrizations = <a class="code hl_function" href="#af6cfbd15bbf85bc957f95a730522589d">getGeometryPolynomialPoints</a>(part_graph);</div>
<div class="line"><span class="lineno">  872</span> </div>
<div class="line"><span class="lineno">  873</span>    <span class="comment">// Collect all the parametrizations that only have one compatibility condition, and obtain their indices</span></div>
<div class="line"><span class="lineno">  874</span>    std::vector&lt;std::pair&lt;int, Eigen::MatrixXd&gt;&gt; free_parametrizations;</div>
<div class="line"><span class="lineno">  875</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; possible_parametrizations.size(); ++i) {</div>
<div class="line"><span class="lineno">  876</span>        <span class="keywordflow">if</span> (possible_parametrizations[i] &gt; 1) <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  877</span>        free_parametrizations.emplace_back(i, parametrizations[i]);</div>
<div class="line"><span class="lineno">  878</span>    }</div>
<div class="line"><span class="lineno">  879</span> </div>
<div class="line"><span class="lineno">  880</span>    std::vector&lt;FixedDisplacementCondition&gt; fixed_conditions;</div>
<div class="line"><span class="lineno">  881</span> </div>
<div class="line"><span class="lineno">  882</span>    <span class="comment">// Iterate through the displacements to initialize our boundary conditions</span></div>
<div class="line"><span class="lineno">  883</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [boundary_idx, displacement_vector] : displacements) {</div>
<div class="line"><span class="lineno">  884</span>        <span class="keywordtype">bool</span> added = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  885</span> </div>
<div class="line"><span class="lineno">  886</span>        <span class="comment">// First, we find the parametrization that corresponds to this boundary_idx</span></div>
<div class="line"><span class="lineno">  887</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [index, param] : free_parametrizations) {</div>
<div class="line"><span class="lineno">  888</span>            <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> param_lines (param.block&lt;2, 1&gt;(0, 0), param.block&lt;2, 1&gt;(2, 0),</div>
<div class="line"><span class="lineno">  889</span>                param.block&lt;2, 1&gt;(0, 2), param.block&lt;2, 1&gt;(2, 2));</div>
<div class="line"><span class="lineno">  890</span> </div>
<div class="line"><span class="lineno">  891</span>            <span class="keywordflow">if</span> (param_lines.isPointOnFirstLine(<a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[boundary_idx].points.first) and</div>
<div class="line"><span class="lineno">  892</span>                param_lines.isPointOnFirstLine(<a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[boundary_idx].points.second)) {</div>
<div class="line"><span class="lineno">  893</span>                added = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  894</span>                fixed_conditions.emplace_back(std::make_pair(index, 0), displacement_vector);</div>
<div class="line"><span class="lineno">  895</span> </div>
<div class="line"><span class="lineno">  896</span>            }</div>
<div class="line"><span class="lineno">  897</span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (param_lines.isPointOnSecondLine(<a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[boundary_idx].points.first) and</div>
<div class="line"><span class="lineno">  898</span>                param_lines.isPointOnSecondLine(<a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[boundary_idx].points.second)) {</div>
<div class="line"><span class="lineno">  899</span>                added = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  900</span>                fixed_conditions.emplace_back(std::make_pair(index, 1), displacement_vector);</div>
<div class="line"><span class="lineno">  901</span>            }</div>
<div class="line"><span class="lineno">  902</span>            <span class="keywordflow">if</span> (added) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  903</span>        }</div>
<div class="line"><span class="lineno">  904</span>        LF_ASSERT_MSG(added, <span class="stringliteral">&quot;The provided displacement condition in getFixedDisplacementConditions is invalid&quot;</span>);</div>
<div class="line"><span class="lineno">  905</span>    }</div>
<div class="line"><span class="lineno">  906</span>    <span class="keywordflow">return</span> fixed_conditions;</div>
<div class="line"><span class="lineno">  907</span>}</div>
<div class="ttc" id="aclass_graph_mesh_html_aebe58192125ecaa4193b92519493ded6"><div class="ttname"><a href="#aebe58192125ecaa4193b92519493ded6">GraphMesh::getCompatibilityConditions</a></div><div class="ttdeci">std::vector&lt; CompatibilityCondition &gt; getCompatibilityConditions(const PartGraph &amp;part_graph)</div><div class="ttdoc">Gets compatibility conditions between parts.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:759</div></div>
<div class="ttc" id="aclass_graph_mesh_html_af6cfbd15bbf85bc957f95a730522589d"><div class="ttname"><a href="#af6cfbd15bbf85bc957f95a730522589d">GraphMesh::getGeometryPolynomialPoints</a></div><div class="ttdeci">std::vector&lt; Eigen::MatrixXd &gt; getGeometryPolynomialPoints(const PartGraph &amp;part_graph)</div><div class="ttdoc">Gets polynomial points for the geometry.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:513</div></div>
<div class="ttc" id="aclass_line_mapping_html"><div class="ttname"><a href="class_line_mapping.html">LineMapping</a></div><div class="ttdoc">Class for mapping points between two line segments.</div><div class="ttdef"><b>Definition</b> line_mapping.h:20</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae2cf9af0db6518e7c6f896a1cb6a0a2e" name="ae2cf9af0db6518e7c6f896a1cb6a0a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cf9af0db6518e7c6f896a1cb6a0a2e">&#9670;&#160;</a></span>getGeometryParametrizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; GraphMesh::getGeometryParametrizations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part_graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets parametrizations for the geometry. </p>
<p>The returned vector of <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> is semantically equivalent to what is returned from <a class="el" href="#af6cfbd15bbf85bc957f95a730522589d">getGeometryPolynomialPoints</a>, but in a different type form </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_graph</td><td>Graph of mesh parts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of parametrization data </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  590</span>                                                                                                     {</div>
<div class="line"><span class="lineno">  591</span>    std::vector&lt;MeshParametrizationData&gt; params_vector;</div>
<div class="line"><span class="lineno">  592</span> </div>
<div class="line"><span class="lineno">  593</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; part : part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>) {</div>
<div class="line"><span class="lineno">  594</span>        <span class="keyword">auto</span> geometry = <a class="code hl_function" href="#a27e1a725acf060f5a522e92843454134">getPartGeometry</a>(part);</div>
<div class="line"><span class="lineno">  595</span>        <span class="keyword">auto</span> parametrization = <a class="code hl_function" href="namespace_mesh_parametrization.html#a30780085192c00fff5bcb5e554dccff5">MeshParametrization::pointToParametrization</a>(geometry);</div>
<div class="line"><span class="lineno">  596</span>        params_vector.push_back(parametrization);</div>
<div class="line"><span class="lineno">  597</span>    }</div>
<div class="line"><span class="lineno">  598</span>    <span class="keywordflow">return</span> params_vector;</div>
<div class="line"><span class="lineno">  599</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af6cfbd15bbf85bc957f95a730522589d" name="af6cfbd15bbf85bc957f95a730522589d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cfbd15bbf85bc957f95a730522589d">&#9670;&#160;</a></span>getGeometryPolynomialPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::MatrixXd &gt; GraphMesh::getGeometryPolynomialPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part_graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets polynomial points for the geometry. </p>
<p>These geometry points are on the actual splines, but may not be points on the actual mesh </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_graph</td><td>Graph of mesh parts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of point matrices for each part, in the same order as in the <a class="el" href="struct_part_graph.html" title="Graph representation of subdivided mesh.">PartGraph</a> </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  513</span>                                                                                           {</div>
<div class="line"><span class="lineno">  514</span>    std::vector&lt;Eigen::MatrixXd&gt; points_vector;</div>
<div class="line"><span class="lineno">  515</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; part : part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>) {</div>
<div class="line"><span class="lineno">  516</span>        <span class="keyword">auto</span> geometry = <a class="code hl_function" href="#a27e1a725acf060f5a522e92843454134">getPartGeometry</a>(part);</div>
<div class="line"><span class="lineno">  517</span>        points_vector.push_back(geometry);</div>
<div class="line"><span class="lineno">  518</span>    }</div>
<div class="line"><span class="lineno">  519</span>    <span class="keywordflow">return</span> points_vector;</div>
<div class="line"><span class="lineno">  520</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab3476770f845a7c33911fe96eff3c617" name="ab3476770f845a7c33911fe96eff3c617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3476770f845a7c33911fe96eff3c617">&#9670;&#160;</a></span>getInitialDisplacements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::MatrixXd &gt; GraphMesh::getInitialDisplacements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part_graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets initial displacement vectors. </p>
<p>Currently, the initial displacement vectors are all initialized to 0, as a first guess for optimize_displacement_vectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_graph</td><td>Graph of mesh parts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of displacement matrices </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  619</span>                                                                                       {</div>
<div class="line"><span class="lineno">  620</span> </div>
<div class="line"><span class="lineno">  621</span>    std::vector&lt;Eigen::MatrixXd&gt; initial_displacements;</div>
<div class="line"><span class="lineno">  622</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; part : part_graph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>) {</div>
<div class="line"><span class="lineno">  623</span>        <span class="keywordflow">if</span> (part.type == <a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a>) {</div>
<div class="line"><span class="lineno">  624</span>            <span class="keywordtype">int</span> num = part.connectedEdges.size();</div>
<div class="line"><span class="lineno">  625</span>            Eigen::MatrixXd zeros (num * 4, 1);</div>
<div class="line"><span class="lineno">  626</span>            zeros.setZero();</div>
<div class="line"><span class="lineno">  627</span>            initial_displacements.push_back(zeros);</div>
<div class="line"><span class="lineno">  628</span>        }</div>
<div class="line"><span class="lineno">  629</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  630</span>            Eigen::MatrixXd zeros (4, 2);</div>
<div class="line"><span class="lineno">  631</span>            zeros.setZero();</div>
<div class="line"><span class="lineno">  632</span>            initial_displacements.push_back(zeros);</div>
<div class="line"><span class="lineno">  633</span>        }</div>
<div class="line"><span class="lineno">  634</span>    }</div>
<div class="line"><span class="lineno">  635</span>    <span class="keywordflow">return</span> initial_displacements;</div>
<div class="line"><span class="lineno">  636</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4456e3afd0edca8c2851ad6029e94124" name="a4456e3afd0edca8c2851ad6029e94124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4456e3afd0edca8c2851ad6029e94124">&#9670;&#160;</a></span>getMeshParametrizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; GraphMesh::getMeshParametrizations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part_graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets parametrizations for mesh. </p>
<p>The returned vector of <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> is semantically equivalent to what is returned from <a class="el" href="#a164162900d8e97ee8e2cafb8baa90363">getMeshPolynomialPoints</a>, but in a different type form </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_graph</td><td>Graph of mesh parts </td></tr>
    <tr><td class="paramname">mesh_file_name</td><td>Mesh file path </td></tr>
    <tr><td class="paramname">order</td><td>Polynomial order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of parametrization data </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  606</span>                                                {</div>
<div class="line"><span class="lineno">  607</span> </div>
<div class="line"><span class="lineno">  608</span>    std::vector&lt;MeshParametrizationData&gt; params_vector;</div>
<div class="line"><span class="lineno">  609</span>    <span class="keyword">auto</span> [mesh_point_vector, mesh_node_vector] = <a class="code hl_function" href="#a164162900d8e97ee8e2cafb8baa90363">getMeshPolynomialPoints</a>(part_graph, mesh_file_name, order);</div>
<div class="line"><span class="lineno">  610</span> </div>
<div class="line"><span class="lineno">  611</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; points : mesh_point_vector) {</div>
<div class="line"><span class="lineno">  612</span>        <span class="keyword">auto</span> parametrization = <a class="code hl_function" href="namespace_mesh_parametrization.html#a30780085192c00fff5bcb5e554dccff5">MeshParametrization::pointToParametrization</a>(points);</div>
<div class="line"><span class="lineno">  613</span>        params_vector.push_back(parametrization);</div>
<div class="line"><span class="lineno">  614</span>    }</div>
<div class="line"><span class="lineno">  615</span>    <span class="keywordflow">return</span> params_vector;</div>
<div class="line"><span class="lineno">  616</span>}</div>
<div class="ttc" id="aclass_graph_mesh_html_a164162900d8e97ee8e2cafb8baa90363"><div class="ttname"><a href="#a164162900d8e97ee8e2cafb8baa90363">GraphMesh::getMeshPolynomialPoints</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; Eigen::MatrixXi &gt; &gt; getMeshPolynomialPoints(const PartGraph &amp;part_graph, const std::string &amp;mesh_file_name, int order)</div><div class="ttdoc">Gets polynomial points for the mesh.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:526</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a164162900d8e97ee8e2cafb8baa90363" name="a164162900d8e97ee8e2cafb8baa90363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164162900d8e97ee8e2cafb8baa90363">&#9670;&#160;</a></span>getMeshPolynomialPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; Eigen::MatrixXi &gt; &gt; GraphMesh::getMeshPolynomialPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part_graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets polynomial points for the mesh. </p>
<p>The returned points are on the actual mesh, and not solely on the geometry </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_graph</td><td>Graph of mesh parts </td></tr>
    <tr><td class="paramname">mesh_file_name</td><td>Mesh file path </td></tr>
    <tr><td class="paramname">order</td><td>Polynomial order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of point matrices and node indices for future retrieval </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  527</span>                                                                             {</div>
<div class="line"><span class="lineno">  528</span> </div>
<div class="line"><span class="lineno">  529</span>    <span class="comment">// We next read the mesh file name into LehrFEM to easily retrieve the nodes and their coordinates</span></div>
<div class="line"><span class="lineno">  530</span>    <span class="keyword">auto</span> factory = std::make_unique&lt;lf::mesh::hybrid2d::MeshFactory&gt;(2);</div>
<div class="line"><span class="lineno">  531</span>    std::filesystem::path project_root = std::filesystem::current_path().parent_path();</div>
<div class="line"><span class="lineno">  532</span>    std::filesystem::path mesh_dir = project_root / <span class="stringliteral">&quot;meshes&quot;</span>;</div>
<div class="line"><span class="lineno">  533</span>    std::filesystem::path full_path = mesh_dir / mesh_file_name;</div>
<div class="line"><span class="lineno">  534</span> </div>
<div class="line"><span class="lineno">  535</span>    lf::io::GmshReader reader(std::move(factory), full_path);</div>
<div class="line"><span class="lineno">  536</span>    <span class="keyword">const</span> std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh_ptr = reader.mesh();</div>
<div class="line"><span class="lineno">  537</span>    <span class="keyword">const</span> lf::mesh::Mesh &amp;mesh {*mesh_ptr};</div>
<div class="line"><span class="lineno">  538</span> </div>
<div class="line"><span class="lineno">  539</span>    std::shared_ptr&lt;lf::uscalfe::UniformScalarFESpace&lt;double&gt;&gt; fe_space;</div>
<div class="line"><span class="lineno">  540</span>    <span class="keywordflow">if</span> (order == 1) {</div>
<div class="line"><span class="lineno">  541</span>        fe_space = std::make_shared&lt;lf::uscalfe::FeSpaceLagrangeO1&lt;double&gt;&gt;(mesh_ptr);</div>
<div class="line"><span class="lineno">  542</span>    }</div>
<div class="line"><span class="lineno">  543</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (order == 2) {</div>
<div class="line"><span class="lineno">  544</span>        fe_space = std::make_shared&lt;lf::uscalfe::FeSpaceLagrangeO2&lt;double&gt;&gt;(mesh_ptr);</div>
<div class="line"><span class="lineno">  545</span>    }</div>
<div class="line"><span class="lineno">  546</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  547</span>        LF_ASSERT_MSG(<span class="keyword">false</span>, <span class="stringliteral">&quot;Incorrect order sent to getMeshPolynomialPoints: &quot;</span> &lt;&lt; order);</div>
<div class="line"><span class="lineno">  548</span>    }</div>
<div class="line"><span class="lineno">  549</span>    <span class="keyword">const</span> lf::assemble::DofHandler &amp;dofh {fe_space-&gt;LocGlobMap()};</div>
<div class="line"><span class="lineno">  550</span> </div>
<div class="line"><span class="lineno">  551</span>    std::vector&lt;Eigen::MatrixXd&gt; geom_poly_points = <a class="code hl_function" href="#af6cfbd15bbf85bc957f95a730522589d">getGeometryPolynomialPoints</a>(part_graph);</div>
<div class="line"><span class="lineno">  552</span>    std::vector&lt;Eigen::MatrixXd&gt; mesh_poly_points;</div>
<div class="line"><span class="lineno">  553</span>    std::vector&lt;Eigen::MatrixXi&gt; mesh_node_indices;</div>
<div class="line"><span class="lineno">  554</span> </div>
<div class="line"><span class="lineno">  555</span>    <span class="comment">// Iterate through all point matrices</span></div>
<div class="line"><span class="lineno">  556</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;points : geom_poly_points) {</div>
<div class="line"><span class="lineno">  557</span>        <span class="keywordtype">int</span> num_points = points.rows() / 2 * 3;</div>
<div class="line"><span class="lineno">  558</span>        Eigen::MatrixXd mesh_points(points.rows(), points.cols());</div>
<div class="line"><span class="lineno">  559</span>        Eigen::MatrixXi mesh_indices(points.rows() / 2, points.cols());</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>        <span class="comment">// Iterate through all points of this particular matrix</span></div>
<div class="line"><span class="lineno">  562</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_points; ++i) {</div>
<div class="line"><span class="lineno">  563</span>            <span class="keywordtype">double</span> closest_distance = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line"><span class="lineno">  564</span>            Eigen::Vector2d closest_point = Eigen::Vector2d::Constant(std::numeric_limits&lt;double&gt;::max());</div>
<div class="line"><span class="lineno">  565</span>            <span class="keyword">auto</span> current_point = points.block&lt;2, 1&gt;(i / 3 * 2, i % 3);</div>
<div class="line"><span class="lineno">  566</span>            <span class="keywordtype">int</span> current_index = -1;</div>
<div class="line"><span class="lineno">  567</span> </div>
<div class="line"><span class="lineno">  568</span>            <span class="comment">// Iterate through all nodes of the mesh to find the closest one</span></div>
<div class="line"><span class="lineno">  569</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> lf::mesh::Entity *node : mesh.Entities(2)) {</div>
<div class="line"><span class="lineno">  570</span>                <span class="keyword">auto</span> possible_point = node-&gt;Geometry()-&gt;Global(node-&gt;RefEl().NodeCoords());</div>
<div class="line"><span class="lineno">  571</span>                <span class="keywordtype">double</span> new_distance = (possible_point - current_point).norm();</div>
<div class="line"><span class="lineno">  572</span>                <span class="keywordflow">if</span> (new_distance &lt; closest_distance) {</div>
<div class="line"><span class="lineno">  573</span>                    closest_distance = new_distance;</div>
<div class="line"><span class="lineno">  574</span>                    closest_point = possible_point;</div>
<div class="line"><span class="lineno">  575</span>                    current_index = dofh.GlobalDofIndices(*node)[0];</div>
<div class="line"><span class="lineno">  576</span>                }</div>
<div class="line"><span class="lineno">  577</span>            }</div>
<div class="line"><span class="lineno">  578</span>            mesh_points.block&lt;2, 1&gt;(i / 3 * 2, i % 3) = closest_point;</div>
<div class="line"><span class="lineno">  579</span>            mesh_indices(i / 3, i % 3) = current_index;</div>
<div class="line"><span class="lineno">  580</span>        }</div>
<div class="line"><span class="lineno">  581</span>        mesh_poly_points.push_back(mesh_points);</div>
<div class="line"><span class="lineno">  582</span>        mesh_node_indices.push_back(mesh_indices);</div>
<div class="line"><span class="lineno">  583</span>    }</div>
<div class="line"><span class="lineno">  584</span>    <span class="keywordflow">return</span> {mesh_poly_points, mesh_node_indices};</div>
<div class="line"><span class="lineno">  585</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af3907a12bfc1caa034e08aab62040864" name="af3907a12bfc1caa034e08aab62040864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3907a12bfc1caa034e08aab62040864">&#9670;&#160;</a></span>getNNTrainingParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_n_training_params.html">NNTrainingParams</a> GraphMesh::getNNTrainingParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part_graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets training parameters for neural network. </p>
<p>The included training parameters are detailed in <a class="el" href="struct_n_n_training_params.html">NNTrainingParams</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_graph</td><td>Graph of mesh parts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Training parameter ranges </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  678</span>                                                                           {</div>
<div class="line"><span class="lineno">  679</span>    <span class="keyword">auto</span> params_vector = <a class="code hl_function" href="#ae2cf9af0db6518e7c6f896a1cb6a0a2e">getGeometryParametrizations</a>(part_graph);</div>
<div class="line"><span class="lineno">  680</span>    <span class="keywordtype">double</span> min_length = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line"><span class="lineno">  681</span>    <span class="keywordtype">double</span> max_length = 0;</div>
<div class="line"><span class="lineno">  682</span>    <span class="keywordtype">double</span> min_width = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line"><span class="lineno">  683</span>    <span class="keywordtype">double</span> max_width = 0;</div>
<div class="line"><span class="lineno">  684</span>    <span class="keywordtype">double</span> min_width_diff = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line"><span class="lineno">  685</span>    <span class="keywordtype">double</span> max_width_diff = 0;</div>
<div class="line"><span class="lineno">  686</span>    <span class="keywordtype">double</span> min_angle_diff = std::numeric_limits&lt;double&gt;::max();</div>
<div class="line"><span class="lineno">  687</span>    <span class="keywordtype">double</span> max_angle_diff = 0;</div>
<div class="line"><span class="lineno">  688</span> </div>
<div class="line"><span class="lineno">  689</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> param : params_vector) {</div>
<div class="line"><span class="lineno">  690</span>        <span class="keywordtype">double</span> approx_length;</div>
<div class="line"><span class="lineno">  691</span>        Eigen::Vector2d zeros = Eigen::Vector2d::Zero();</div>
<div class="line"><span class="lineno">  692</span>        <span class="keywordflow">if</span> (param.numBranches == 1) {</div>
<div class="line"><span class="lineno">  693</span>            approx_length = (param.terminals.block&lt;2 ,1&gt;(0, 1) -</div>
<div class="line"><span class="lineno">  694</span>                    param.terminals.block&lt;2 ,1&gt;(0, 0)).norm() +</div>
<div class="line"><span class="lineno">  695</span>                    (param.terminals.block&lt;2 ,1&gt;(0, 2) -</div>
<div class="line"><span class="lineno">  696</span>                   param.terminals.block&lt;2 ,1&gt;(0, 1)).norm();</div>
<div class="line"><span class="lineno">  697</span> </div>
<div class="line"><span class="lineno">  698</span>            <span class="keywordflow">if</span> (approx_length &gt; max_length) max_length = approx_length;</div>
<div class="line"><span class="lineno">  699</span>            <span class="keywordflow">if</span> (approx_length &lt; min_length) min_length = approx_length;</div>
<div class="line"><span class="lineno">  700</span> </div>
<div class="line"><span class="lineno">  701</span>            min_width_diff = std::min(std::min(std::abs(param.widths(0, 0) / param.widths(0, 1) - 1),</div>
<div class="line"><span class="lineno">  702</span>                std::abs(param.widths(0, 1) / param.widths(0, 2) - 1)),</div>
<div class="line"><span class="lineno">  703</span>                std::min(std::abs(param.widths(0, 0) / param.widths(0, 2) - 1), min_width_diff));</div>
<div class="line"><span class="lineno">  704</span>            max_width_diff = std::max(std::max(std::abs(param.widths(0, 0) / param.widths(0, 1) - 1),</div>
<div class="line"><span class="lineno">  705</span>                std::abs(param.widths(0, 1) / param.widths(0, 2) - 1)),</div>
<div class="line"><span class="lineno">  706</span>                std::max(std::abs(param.widths(0, 0) / param.widths(0, 2) - 1), max_width_diff));</div>
<div class="line"><span class="lineno">  707</span> </div>
<div class="line"><span class="lineno">  708</span>            <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> vectors0_and_1(zeros, param.vectors.col(0), zeros, param.vectors.col(1));</div>
<div class="line"><span class="lineno">  709</span>            <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> vectors1_and_2(zeros, param.vectors.col(1), zeros, param.vectors.col(2));</div>
<div class="line"><span class="lineno">  710</span>            <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> vectors0_and_2(zeros, param.vectors.col(0), zeros, param.vectors.col(2));</div>
<div class="line"><span class="lineno">  711</span> </div>
<div class="line"><span class="lineno">  712</span>            min_angle_diff = std::min(std::min(vectors0_and_1.angleBetweenLines(), vectors1_and_2.angleBetweenLines()),</div>
<div class="line"><span class="lineno">  713</span>                std::min(vectors0_and_2.angleBetweenLines(), min_angle_diff));</div>
<div class="line"><span class="lineno">  714</span>            max_angle_diff = std::max(std::max(vectors0_and_1.angleBetweenLines(), vectors1_and_2.angleBetweenLines()),</div>
<div class="line"><span class="lineno">  715</span>                std::max(vectors0_and_2.angleBetweenLines(), max_angle_diff));</div>
<div class="line"><span class="lineno">  716</span>        }</div>
<div class="line"><span class="lineno">  717</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  718</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; param.numBranches; ++i) {</div>
<div class="line"><span class="lineno">  719</span>                approx_length = (param.terminals.block&lt;2 ,1&gt;(2 * i, 1) -</div>
<div class="line"><span class="lineno">  720</span>                    param.terminals.block&lt;2 ,1&gt;(2 * i, 0)).norm() +</div>
<div class="line"><span class="lineno">  721</span>                    (param.terminals.block&lt;2 ,1&gt;(2 * i, 2) -</div>
<div class="line"><span class="lineno">  722</span>                    param.terminals.block&lt;2 ,1&gt;(2 * i, 1)).norm();</div>
<div class="line"><span class="lineno">  723</span> </div>
<div class="line"><span class="lineno">  724</span>                <span class="keywordflow">if</span> (approx_length &gt; max_length) max_length = approx_length;</div>
<div class="line"><span class="lineno">  725</span>                <span class="keywordflow">if</span> (approx_length &lt; min_length) min_length = approx_length;</div>
<div class="line"><span class="lineno">  726</span> </div>
<div class="line"><span class="lineno">  727</span>                min_width_diff = std::min(std::min(std::abs(param.widths(i, 0) / param.widths(i, 1) - 1),</div>
<div class="line"><span class="lineno">  728</span>                std::abs(param.widths(i, 1) / param.widths(i, 2) - 1)),</div>
<div class="line"><span class="lineno">  729</span>                std::min(std::abs(param.widths(i, 0) / param.widths(i, 2) - 1), min_width_diff));</div>
<div class="line"><span class="lineno">  730</span>                max_width_diff = std::max(std::max(std::abs(param.widths(i, 0) / param.widths(i, 1) - 1),</div>
<div class="line"><span class="lineno">  731</span>                    std::abs(param.widths(i, 1) / param.widths(i, 2) - 1)),</div>
<div class="line"><span class="lineno">  732</span>                    std::max(std::abs(param.widths(i, 0) / param.widths(i, 2) - 1), max_width_diff));</div>
<div class="line"><span class="lineno">  733</span> </div>
<div class="line"><span class="lineno">  734</span>                <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> vectors0_and_1(zeros, param.vectors.block&lt;2, 1&gt;(2 * i, 0),</div>
<div class="line"><span class="lineno">  735</span>                    zeros, param.vectors.block&lt;2, 1&gt;(2 * i, 1));</div>
<div class="line"><span class="lineno">  736</span>                <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> vectors1_and_2(zeros, param.vectors.block&lt;2, 1&gt;(2 * i, 1),</div>
<div class="line"><span class="lineno">  737</span>                    zeros, param.vectors.block&lt;2, 1&gt;(2 * i, 2));</div>
<div class="line"><span class="lineno">  738</span>                <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> vectors0_and_2(zeros, param.vectors.block&lt;2, 1&gt;(2 * i, 0),</div>
<div class="line"><span class="lineno">  739</span>                    zeros, param.vectors.block&lt;2, 1&gt;(2 * i, 2));</div>
<div class="line"><span class="lineno">  740</span> </div>
<div class="line"><span class="lineno">  741</span>                min_angle_diff = std::min(std::min(vectors0_and_1.angleBetweenLines(), vectors1_and_2.angleBetweenLines()),</div>
<div class="line"><span class="lineno">  742</span>                    std::min(vectors0_and_2.angleBetweenLines(), min_angle_diff));</div>
<div class="line"><span class="lineno">  743</span>                max_angle_diff = std::max(std::max(vectors0_and_1.angleBetweenLines(), vectors1_and_2.angleBetweenLines()),</div>
<div class="line"><span class="lineno">  744</span>                    std::max(vectors0_and_2.angleBetweenLines(), max_angle_diff));</div>
<div class="line"><span class="lineno">  745</span>            }</div>
<div class="line"><span class="lineno">  746</span>        }</div>
<div class="line"><span class="lineno">  747</span> </div>
<div class="line"><span class="lineno">  748</span>        <span class="keywordtype">double</span> min_width_param = param.widths.minCoeff();</div>
<div class="line"><span class="lineno">  749</span>        <span class="keywordtype">double</span> max_width_param = param.widths.maxCoeff();</div>
<div class="line"><span class="lineno">  750</span> </div>
<div class="line"><span class="lineno">  751</span>        <span class="keywordflow">if</span> (min_width_param &lt; min_width) min_width = min_width_param;</div>
<div class="line"><span class="lineno">  752</span>        <span class="keywordflow">if</span> (max_width_param &gt; max_width) max_width = max_width_param;</div>
<div class="line"><span class="lineno">  753</span>    }</div>
<div class="line"><span class="lineno">  754</span>    <span class="keywordflow">return</span> {{min_length, max_length}, {min_width, max_width},</div>
<div class="line"><span class="lineno">  755</span>        {min_width_diff, max_width_diff}, {min_angle_diff, max_angle_diff}};</div>
<div class="line"><span class="lineno">  756</span>}</div>
<div class="ttc" id="aclass_graph_mesh_html_ae2cf9af0db6518e7c6f896a1cb6a0a2e"><div class="ttname"><a href="#ae2cf9af0db6518e7c6f896a1cb6a0a2e">GraphMesh::getGeometryParametrizations</a></div><div class="ttdeci">std::vector&lt; MeshParametrizationData &gt; getGeometryParametrizations(const PartGraph &amp;part_graph)</div><div class="ttdoc">Gets parametrizations for the geometry.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:590</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a01f158e83e65920b9dbbf85e6b03bfb7" name="a01f158e83e65920b9dbbf85e6b03bfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f158e83e65920b9dbbf85e6b03bfb7">&#9670;&#160;</a></span>getNodeBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; GraphMesh::getNodeBoundary </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nodeId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets boundary tags for a node. </p>
<p>Uses <a class="el" href="class_graph_mesh.html">GraphMesh</a> fields to obtain the node boundary tags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>Node identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of boundary tags </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1263</span>                                                    {</div>
<div class="line"><span class="lineno"> 1264</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>[nodeId].boundaryTags;</div>
<div class="line"><span class="lineno"> 1265</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afbfdf95067ee7e8a951aebad8ccbb666" name="afbfdf95067ee7e8a951aebad8ccbb666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfdf95067ee7e8a951aebad8ccbb666">&#9670;&#160;</a></span>getNodesOfEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; GraphMesh::getNodesOfEdge </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>edgeId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets nodes connected to an edge. </p>
<p>Uses <a class="el" href="class_graph_mesh.html">GraphMesh</a> fields to obtain the connected nodes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeId</td><td>Edge identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of connected node IDs </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1244</span>                                                   {</div>
<div class="line"><span class="lineno"> 1245</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[edgeId].connectedNodes;</div>
<div class="line"><span class="lineno"> 1246</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9cb23f58e6049d4358dad7534b6fb64b" name="a9cb23f58e6049d4358dad7534b6fb64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb23f58e6049d4358dad7534b6fb64b">&#9670;&#160;</a></span>getNodeSurfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; GraphMesh::getNodeSurfaces </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nodeId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets surface tags for a node. </p>
<p>Uses <a class="el" href="class_graph_mesh.html">GraphMesh</a> fields to obtain the node surface tags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>Node identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of surface tags </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1259</span>                                                    {</div>
<div class="line"><span class="lineno"> 1260</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>[nodeId].surfaceTags;</div>
<div class="line"><span class="lineno"> 1261</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a27e1a725acf060f5a522e92843454134" name="a27e1a725acf060f5a522e92843454134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e1a725acf060f5a522e92843454134">&#9670;&#160;</a></span>getPartGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd GraphMesh::getPartGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_mesh_part.html">MeshPart</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets geometry for a mesh part. </p>
<p>Uses the stored curve tags along with the respective portions to query the curve and obtain the points </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>Mesh part to analyze </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of geometric points </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1127</span>                                                             {</div>
<div class="line"><span class="lineno"> 1128</span>    std::vector&lt;std::vector&lt;double&gt;&gt; geometry;</div>
<div class="line"><span class="lineno"> 1129</span> </div>
<div class="line"><span class="lineno"> 1130</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Debug: Starting getPartGeometry for part type: &quot;</span> &lt;&lt; (part.<a class="code hl_variable" href="struct_mesh_part.html#ac2e2df82f1c9a6898bea7a6ad0f11a3a">type</a> == <a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a> ? <span class="stringliteral">&quot;NODE&quot;</span> : <span class="stringliteral">&quot;EDGE&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1131</span> </div>
<div class="line"><span class="lineno"> 1132</span>    <span class="comment">// iterate through the curveTags of this part in order to acquire points along the curve</span></div>
<div class="line"><span class="lineno"> 1133</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [curveTag, orientation, portions] : part.<a class="code hl_variable" href="struct_mesh_part.html#aa0c6cb80b5239276c9e28460bc611cfa">curveTags</a>) {</div>
<div class="line"><span class="lineno"> 1134</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Debug: Processing curveTag: &quot;</span> &lt;&lt; curveTag &lt;&lt; <span class="stringliteral">&quot; with orientation: &quot;</span> &lt;&lt; orientation</div>
<div class="line"><span class="lineno"> 1135</span>        &lt;&lt; <span class="stringliteral">&quot; and portions: [&quot;</span> &lt;&lt; portions.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; portions.second &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1136</span> </div>
<div class="line"><span class="lineno"> 1137</span>        std::vector&lt;double&gt; tMin, tMax;</div>
<div class="line"><span class="lineno"> 1138</span>        gmsh::model::getParametrizationBounds(1, curveTag, tMin, tMax);</div>
<div class="line"><span class="lineno"> 1139</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Debug: Parametrization bounds: tMin = &quot;</span> &lt;&lt; tMin[0] &lt;&lt; <span class="stringliteral">&quot;, tMax = &quot;</span> &lt;&lt; tMax[0] &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1140</span> </div>
<div class="line"><span class="lineno"> 1141</span>        <span class="keywordtype">double</span> startPortion = portions.first;</div>
<div class="line"><span class="lineno"> 1142</span>        <span class="keywordtype">double</span> endPortion = portions.second;</div>
<div class="line"><span class="lineno"> 1143</span> </div>
<div class="line"><span class="lineno"> 1144</span>        <span class="comment">// Adjust tMin and tMax based on the portion and orientation</span></div>
<div class="line"><span class="lineno"> 1145</span>        <span class="keywordtype">double</span> tStart, tEnd;</div>
<div class="line"><span class="lineno"> 1146</span>        <span class="keywordflow">if</span> (orientation == 1) {</div>
<div class="line"><span class="lineno"> 1147</span>            tStart = tMin[0] + startPortion * (tMax[0] - tMin[0]);</div>
<div class="line"><span class="lineno"> 1148</span>            tEnd = tMin[0] + endPortion * (tMax[0] - tMin[0]);</div>
<div class="line"><span class="lineno"> 1149</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1150</span>            tStart = tMax[0] - startPortion * (tMax[0] - tMin[0]);</div>
<div class="line"><span class="lineno"> 1151</span>            tEnd =  tMax[0] - endPortion * (tMax[0] - tMin[0]);</div>
<div class="line"><span class="lineno"> 1152</span>        }</div>
<div class="line"><span class="lineno"> 1153</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Debug: Adjusted t values: tStart = &quot;</span> &lt;&lt; tStart &lt;&lt; <span class="stringliteral">&quot;, tEnd = &quot;</span> &lt;&lt; tEnd &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1154</span> </div>
<div class="line"><span class="lineno"> 1155</span>        <span class="comment">// Get start point</span></div>
<div class="line"><span class="lineno"> 1156</span>        std::vector&lt;double&gt; startPoint;</div>
<div class="line"><span class="lineno"> 1157</span>        gmsh::model::getValue(1, curveTag, {tStart}, startPoint);</div>
<div class="line"><span class="lineno"> 1158</span>        geometry.push_back(startPoint);</div>
<div class="line"><span class="lineno"> 1159</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Debug: Start point: (&quot;</span> &lt;&lt; startPoint[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; startPoint[1] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; startPoint[2] &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1160</span> </div>
<div class="line"><span class="lineno"> 1161</span>        <span class="comment">// Get middle point</span></div>
<div class="line"><span class="lineno"> 1162</span>        std::vector&lt;double&gt; midPoint;</div>
<div class="line"><span class="lineno"> 1163</span>        gmsh::model::getValue(1, curveTag, {(tStart + tEnd) / 2}, midPoint);</div>
<div class="line"><span class="lineno"> 1164</span>        geometry.push_back(midPoint);</div>
<div class="line"><span class="lineno"> 1165</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Debug: Middle point: (&quot;</span> &lt;&lt; midPoint[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; midPoint[1] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; midPoint[2] &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1166</span> </div>
<div class="line"><span class="lineno"> 1167</span>        <span class="comment">// Get end point</span></div>
<div class="line"><span class="lineno"> 1168</span>        std::vector&lt;double&gt; endPoint;</div>
<div class="line"><span class="lineno"> 1169</span>        gmsh::model::getValue(1, curveTag, {tEnd}, endPoint);</div>
<div class="line"><span class="lineno"> 1170</span>        geometry.push_back(endPoint);</div>
<div class="line"><span class="lineno"> 1171</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Debug: End point: (&quot;</span> &lt;&lt; endPoint[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; endPoint[1] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; endPoint[2] &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1172</span>    }</div>
<div class="line"><span class="lineno"> 1173</span> </div>
<div class="line"><span class="lineno"> 1174</span>    Eigen::MatrixXd poly_points(geometry.size() / 3 * 2, 3);</div>
<div class="line"><span class="lineno"> 1175</span> </div>
<div class="line"><span class="lineno"> 1176</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; geometry.size() / 3; ++i) {</div>
<div class="line"><span class="lineno"> 1177</span>        poly_points(2 * i, 0) = geometry[3 * i][0];</div>
<div class="line"><span class="lineno"> 1178</span>        poly_points(2 * i + 1, 0) = geometry[3 * i][1];</div>
<div class="line"><span class="lineno"> 1179</span>        poly_points(2 * i, 1) = geometry[3 * i + 1][0];</div>
<div class="line"><span class="lineno"> 1180</span>        poly_points(2 * i + 1, 1) = geometry[3 * i + 1][1];</div>
<div class="line"><span class="lineno"> 1181</span>        poly_points(2 * i, 2) = geometry[3 * i + 2][0];</div>
<div class="line"><span class="lineno"> 1182</span>        poly_points(2 * i + 1, 2) = geometry[3 * i + 2][1];</div>
<div class="line"><span class="lineno"> 1183</span>    }</div>
<div class="line"><span class="lineno"> 1184</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Debug: Finished getPartGeometry. Returned &quot;</span> &lt;&lt; geometry.size() &lt;&lt; <span class="stringliteral">&quot; points.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1185</span> </div>
<div class="line"><span class="lineno"> 1186</span>    <span class="keywordflow">return</span> poly_points;</div>
<div class="line"><span class="lineno"> 1187</span>}</div>
<div class="ttc" id="astruct_mesh_part_html_aa0c6cb80b5239276c9e28460bc611cfa"><div class="ttname"><a href="struct_mesh_part.html#aa0c6cb80b5239276c9e28460bc611cfa">MeshPart::curveTags</a></div><div class="ttdeci">std::vector&lt; std::tuple&lt; int, int, std::pair&lt; double, double &gt; &gt; &gt; curveTags</div><div class="ttdoc">Curve tag, orientation (1 or -1), and portion.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:169</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d3d464459cf4822c9b8b13b966e6cf3" name="a3d3d464459cf4822c9b8b13b966e6cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3d464459cf4822c9b8b13b966e6cf3">&#9670;&#160;</a></span>isBC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GraphMesh::isBC </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if name represents a boundary condition. </p>
<p>A physical group being labeled "BC#" would identify a boundary condition </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if name is a BC identifier </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   42</span>                                          {</div>
<div class="line"><span class="lineno">   43</span>    <span class="keywordflow">return</span> name[0] == <span class="charliteral">&#39;B&#39;</span> and name[1] == <span class="charliteral">&#39;C&#39;</span>;</div>
<div class="line"><span class="lineno">   44</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1859c71201ea19368e6d0958849cfd87" name="a1859c71201ea19368e6d0958849cfd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1859c71201ea19368e6d0958849cfd87">&#9670;&#160;</a></span>isEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GraphMesh::isEdge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if name represents an edge. </p>
<p>A physical group being labeled "E#" would identify an edge </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if name is an edge identifier </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   54</span>                                            {</div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordflow">return</span> name[0] == <span class="charliteral">&#39;E&#39;</span> and name[1] != <span class="charliteral">&#39;B&#39;</span>;</div>
<div class="line"><span class="lineno">   56</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a78e0be86a3fbb160365bddb63396e8e8" name="a78e0be86a3fbb160365bddb63396e8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e0be86a3fbb160365bddb63396e8e8">&#9670;&#160;</a></span>isEdgeBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GraphMesh::isEdgeBoundary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if name represents an edge boundary. </p>
<p>A physical group being labeled "EB#" would identify an edge boundary </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if name is an edge boundary identifier </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   58</span>                                                    {</div>
<div class="line"><span class="lineno">   59</span>    <span class="keywordflow">return</span> name.substr(0, 2) == <span class="stringliteral">&quot;EB&quot;</span>;</div>
<div class="line"><span class="lineno">   60</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a683fc6b2538ac42600716c7f66f32e33" name="a683fc6b2538ac42600716c7f66f32e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683fc6b2538ac42600716c7f66f32e33">&#9670;&#160;</a></span>isNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GraphMesh::isNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if name represents a node. </p>
<p>A physical group being labeled "N#" would identify a node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if name is a node identifier </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   46</span>                                            {</div>
<div class="line"><span class="lineno">   47</span>    <span class="keywordflow">return</span> name[0] == <span class="charliteral">&#39;N&#39;</span> and name[1] != <span class="charliteral">&#39;B&#39;</span>;</div>
<div class="line"><span class="lineno">   48</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a218e4502de90e51bacd6d2cdda8ef559" name="a218e4502de90e51bacd6d2cdda8ef559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218e4502de90e51bacd6d2cdda8ef559">&#9670;&#160;</a></span>isNodeBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GraphMesh::isNodeBoundary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if name represents a node boundary. </p>
<p>A physical group being labeled "NB#" would identify a node boundary </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if name is a node boundary identifier </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   50</span>                                                    {</div>
<div class="line"><span class="lineno">   51</span>    <span class="keywordflow">return</span> name.substr(0, 2) == <span class="stringliteral">&quot;NB&quot;</span>;</div>
<div class="line"><span class="lineno">   52</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a136067707a44e48d8311772675a8d70f" name="a136067707a44e48d8311772675a8d70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136067707a44e48d8311772675a8d70f">&#9670;&#160;</a></span>loadMeshFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::loadMeshFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads mesh from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to mesh file (must include the .geo extension) </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   73</span>                                                          {</div>
<div class="line"><span class="lineno">   74</span>    <span class="keywordflow">try</span> {</div>
<div class="line"><span class="lineno">   75</span>        <span class="keyword">const</span> std::filesystem::path here = __FILE__;</div>
<div class="line"><span class="lineno">   76</span>        <span class="keyword">auto</span> working_dir = here.parent_path().parent_path();</div>
<div class="line"><span class="lineno">   77</span>        gmsh::open(working_dir / <span class="stringliteral">&quot;meshes&quot;</span> / filename);</div>
<div class="line"><span class="lineno">   78</span>        <span class="comment">//gmsh::model::setCurrent(&quot;testNE2&quot;);  // Use the name without .msh extension</span></div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span>        <span class="comment">// Get all surfaces in the model</span></div>
<div class="line"><span class="lineno">   81</span>        std::vector&lt;std::pair&lt;int, int&gt;&gt; surfaces;</div>
<div class="line"><span class="lineno">   82</span>        gmsh::model::getEntities(surfaces, 2);  <span class="comment">// 2 is for surfaces</span></div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Number of surfaces found: &quot;</span> &lt;&lt; surfaces.size() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">   85</span> </div>
<div class="line"><span class="lineno">   86</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; surface : surfaces) {</div>
<div class="line"><span class="lineno">   87</span>            <span class="keywordtype">int</span> surfaceTag = surface.second;</div>
<div class="line"><span class="lineno">   88</span>            std::vector&lt;std::pair&lt;int, int&gt;&gt; bounds;</div>
<div class="line"><span class="lineno">   89</span>            gmsh::model::getBoundary({{2, surfaceTag}}, bounds, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">   90</span> </div>
<div class="line"><span class="lineno">   91</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;Surface &quot;</span> &lt;&lt; surfaceTag &lt;&lt; <span class="stringliteral">&quot; has &quot;</span> &lt;&lt; bounds.size() &lt;&lt; <span class="stringliteral">&quot; boundary entities:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">   92</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; bound : bounds) {</div>
<div class="line"><span class="lineno">   93</span>                std::cout &lt;&lt; <span class="stringliteral">&quot;  Dimension: &quot;</span> &lt;&lt; bound.first &lt;&lt; <span class="stringliteral">&quot;, Tag: &quot;</span> &lt;&lt; bound.second &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">   94</span>            }</div>
<div class="line"><span class="lineno">   95</span>        }</div>
<div class="line"><span class="lineno">   96</span>    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; e) {</div>
<div class="line"><span class="lineno">   97</span>        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error loading mesh file: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">   98</span>        <span class="keywordflow">throw</span>;</div>
<div class="line"><span class="lineno">   99</span>    }</div>
<div class="line"><span class="lineno">  100</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a510e83220cddb19293e4b3adb20e2a51" name="a510e83220cddb19293e4b3adb20e2a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510e83220cddb19293e4b3adb20e2a51">&#9670;&#160;</a></span>meshDisplacementVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; Eigen::MatrixXd &gt; &gt; GraphMesh::meshDisplacementVectors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part_graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, Eigen::Vector4d &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fixed_displacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalculation_params.html">calculationParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>calc_params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes displacement vectors for each mesh parametrizations. </p>
<p>Uses the result from <a class="el" href="#aa5efe6a6d1322ffafd44e5d227d0b027">meshFEMCalculation</a> to return all the displacement vectors for each parametrization sent to the neural network, in the same order as in the <a class="el" href="struct_part_graph.html" title="Graph representation of subdivided mesh.">PartGraph</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_graph</td><td>Graph of mesh parts </td></tr>
    <tr><td class="paramname">mesh_file_name</td><td>Mesh file path </td></tr>
    <tr><td class="paramname">fixed_displacements</td><td>Fixed displacement conditions </td></tr>
    <tr><td class="paramname">calc_params</td><td>Calculation parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of vectors, the first represents the displacement vectors, the second the equivalent parametrization </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1062</span>                                                                                {</div>
<div class="line"><span class="lineno"> 1063</span> </div>
<div class="line"><span class="lineno"> 1064</span>    std::vector&lt;Eigen::MatrixXd&gt; true_displacements;</div>
<div class="line"><span class="lineno"> 1065</span>    <span class="keyword">auto</span> [points_vector, indices_vector] = <a class="code hl_function" href="#a164162900d8e97ee8e2cafb8baa90363">getMeshPolynomialPoints</a>(part_graph, mesh_file_name, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a>);</div>
<div class="line"><span class="lineno"> 1066</span>    <span class="keyword">auto</span> [displacements, energy] = <a class="code hl_function" href="#aa5efe6a6d1322ffafd44e5d227d0b027">meshFEMCalculation</a>(mesh_file_name, fixed_displacements, calc_params);</div>
<div class="line"><span class="lineno"> 1067</span> </div>
<div class="line"><span class="lineno"> 1068</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;indices : indices_vector) {</div>
<div class="line"><span class="lineno"> 1069</span>        <span class="keywordtype">int</span> num_branches = indices.rows() / 2;</div>
<div class="line"><span class="lineno"> 1070</span> </div>
<div class="line"><span class="lineno"> 1071</span>        <span class="comment">// If this is a single branch parametrization, the displacements are from the left and right sides</span></div>
<div class="line"><span class="lineno"> 1072</span>        <span class="keywordflow">if</span> (num_branches == 1) {</div>
<div class="line"><span class="lineno"> 1073</span>            Eigen::MatrixXd node_displacements(4, 2);</div>
<div class="line"><span class="lineno"> 1074</span>            node_displacements(0, 0) = displacements[2 * indices(0, 0)];</div>
<div class="line"><span class="lineno"> 1075</span>            node_displacements(1, 0) = displacements[2 * indices(0, 0) + 1];</div>
<div class="line"><span class="lineno"> 1076</span>            node_displacements(0, 1) = displacements[2 * indices(0, 2)];</div>
<div class="line"><span class="lineno"> 1077</span>            node_displacements(1, 1) = displacements[2 * indices(0, 2) + 1];</div>
<div class="line"><span class="lineno"> 1078</span>            node_displacements(2, 0) = displacements[2 * indices(1, 0)];</div>
<div class="line"><span class="lineno"> 1079</span>            node_displacements(3, 0) = displacements[2 * indices(1, 0) + 1];</div>
<div class="line"><span class="lineno"> 1080</span>            node_displacements(2, 1) = displacements[2 * indices(1, 2) ];</div>
<div class="line"><span class="lineno"> 1081</span>            node_displacements(3, 1) = displacements[2 * indices(1, 2) + 1];</div>
<div class="line"><span class="lineno"> 1082</span>            true_displacements.push_back(node_displacements);</div>
<div class="line"><span class="lineno"> 1083</span>        }</div>
<div class="line"><span class="lineno"> 1084</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1085</span>            Eigen::MatrixXd node_displacements(num_branches * 4, 1);</div>
<div class="line"><span class="lineno"> 1086</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_branches; ++i) {</div>
<div class="line"><span class="lineno"> 1087</span>                node_displacements(i * 4) = displacements[2 * indices(2 * i, 2)];</div>
<div class="line"><span class="lineno"> 1088</span>                node_displacements(i * 4 + 1) = displacements[2 * indices(2 * i, 2) + 1];</div>
<div class="line"><span class="lineno"> 1089</span>                node_displacements(i * 4 + 2) = displacements[2 * indices(2 * i + 1, 2)];</div>
<div class="line"><span class="lineno"> 1090</span>                node_displacements(i * 4 + 3) = displacements[2 * indices(2 * i + 1, 2) + 1];</div>
<div class="line"><span class="lineno"> 1091</span>            }</div>
<div class="line"><span class="lineno"> 1092</span>            true_displacements.push_back(node_displacements);</div>
<div class="line"><span class="lineno"> 1093</span>        }</div>
<div class="line"><span class="lineno"> 1094</span>    }</div>
<div class="line"><span class="lineno"> 1095</span>    <span class="keywordflow">return</span> std::make_pair(points_vector, true_displacements);</div>
<div class="line"><span class="lineno"> 1096</span>}</div>
<div class="ttc" id="aclass_graph_mesh_html_aa5efe6a6d1322ffafd44e5d227d0b027"><div class="ttname"><a href="#aa5efe6a6d1322ffafd44e5d227d0b027">GraphMesh::meshFEMCalculation</a></div><div class="ttdeci">std::pair&lt; Eigen::VectorXd, double &gt; meshFEMCalculation(const std::string &amp;mesh_file_name, const std::vector&lt; std::pair&lt; int, Eigen::Vector4d &gt; &gt; &amp;displacements, const calculationParams &amp;calc_params)</div><div class="ttdoc">Performs FEM calculation on a larger mesh.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:915</div></div>
<div class="ttc" id="astructcalculation_params_html_a9839ec496ba2e56a9c539506f6a1f2c1"><div class="ttname"><a href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">calculationParams::order</a></div><div class="ttdeci">int order</div><div class="ttdoc">Finite element order (1 or 2)</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:40</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a727062f2e085cd97ad2007346ad5eccf" name="a727062f2e085cd97ad2007346ad5eccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727062f2e085cd97ad2007346ad5eccf">&#9670;&#160;</a></span>meshEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; double &gt; &gt; GraphMesh::meshEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>part_graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, Eigen::Vector4d &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fixed_displacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalculation_params.html">calculationParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>calc_params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes energy change for each mesh parametrization individually according to displacement vectors. </p>
<p>Uses the result from <a class="el" href="#a510e83220cddb19293e4b3adb20e2a51">meshDisplacementVectors</a> to compute the energy change associated with the displacement vectors for each parametrization. Note that due to the non-interactions between adjacent parts, the overall energy will be higher </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_graph</td><td>Graph of mesh parts </td></tr>
    <tr><td class="paramname">mesh_file_name</td><td>Mesh file path </td></tr>
    <tr><td class="paramname">fixed_displacements</td><td>Fixed displacement conditions </td></tr>
    <tr><td class="paramname">calc_params</td><td>Calculation parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of displacement vectors, parametrization points, and energy changes </dd></dl>
<div class="fragment"><div class="line"><span class="lineno"> 1103</span>                                                                                                                 {</div>
<div class="line"><span class="lineno"> 1104</span> </div>
<div class="line"><span class="lineno"> 1105</span>    std::vector&lt;double&gt; true_energies;</div>
<div class="line"><span class="lineno"> 1106</span>    <span class="keyword">auto</span> [points_vector, true_displacements] = <a class="code hl_function" href="#a510e83220cddb19293e4b3adb20e2a51">meshDisplacementVectors</a>(</div>
<div class="line"><span class="lineno"> 1107</span>        part_graph, mesh_file_name, fixed_displacements, calc_params);</div>
<div class="line"><span class="lineno"> 1108</span> </div>
<div class="line"><span class="lineno"> 1109</span>    <span class="comment">// Before running our calculations, we make sure to close the file we&#39;ve already opened so that new meshes</span></div>
<div class="line"><span class="lineno"> 1110</span>    <span class="comment">// don&#39;t interfere</span></div>
<div class="line"><span class="lineno"> 1111</span>    <a class="code hl_function" href="#aae89bff77790a2b075b81fbb930c8daf">closeMesh</a>();</div>
<div class="line"><span class="lineno"> 1112</span> </div>
<div class="line"><span class="lineno"> 1113</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; points_vector.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1114</span>        <span class="keyword">auto</span> param = <a class="code hl_function" href="namespace_mesh_parametrization.html#a30780085192c00fff5bcb5e554dccff5">MeshParametrization::pointToParametrization</a>(points_vector[i]);</div>
<div class="line"><span class="lineno"> 1115</span>        <span class="keyword">auto</span> [linear_elastic, energy] = <a class="code hl_function" href="namespace_mesh_parametrization.html#a22ca202a06e1981f1b7f2ff7a6e532e3">MeshParametrization::displacementEnergy</a>(</div>
<div class="line"><span class="lineno"> 1116</span>            param, true_displacements[i], calc_params);</div>
<div class="line"><span class="lineno"> 1117</span>        true_energies.push_back(energy);</div>
<div class="line"><span class="lineno"> 1118</span>    }</div>
<div class="line"><span class="lineno"> 1119</span> </div>
<div class="line"><span class="lineno"> 1120</span>    <span class="keywordflow">return</span> {points_vector, true_displacements, true_energies};</div>
<div class="line"><span class="lineno"> 1121</span>}</div>
<div class="ttc" id="aclass_graph_mesh_html_a510e83220cddb19293e4b3adb20e2a51"><div class="ttname"><a href="#a510e83220cddb19293e4b3adb20e2a51">GraphMesh::meshDisplacementVectors</a></div><div class="ttdeci">std::pair&lt; std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; Eigen::MatrixXd &gt; &gt; meshDisplacementVectors(const PartGraph &amp;part_graph, const std::string &amp;mesh_file_name, const std::vector&lt; std::pair&lt; int, Eigen::Vector4d &gt; &gt; &amp;fixed_displacements, const calculationParams &amp;calc_params)</div><div class="ttdoc">Computes displacement vectors for each mesh parametrizations.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:1060</div></div>
<div class="ttc" id="aclass_graph_mesh_html_aae89bff77790a2b075b81fbb930c8daf"><div class="ttname"><a href="#aae89bff77790a2b075b81fbb930c8daf">GraphMesh::closeMesh</a></div><div class="ttdeci">void closeMesh()</div><div class="ttdoc">Finalizes mesh construction.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:102</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a22ca202a06e1981f1b7f2ff7a6e532e3"><div class="ttname"><a href="namespace_mesh_parametrization.html#a22ca202a06e1981f1b7f2ff7a6e532e3">MeshParametrization::displacementEnergy</a></div><div class="ttdeci">std::pair&lt; bool, double &gt; displacementEnergy(MeshParametrizationData &amp;param, Eigen::MatrixXd &amp;displacement, const calculationParams &amp;calc_params)</div><div class="ttdoc">Calculates displacement energy and checks if in the linear elastic region.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:745</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5efe6a6d1322ffafd44e5d227d0b027" name="aa5efe6a6d1322ffafd44e5d227d0b027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5efe6a6d1322ffafd44e5d227d0b027">&#9670;&#160;</a></span>meshFEMCalculation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::VectorXd, double &gt; GraphMesh::meshFEMCalculation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, Eigen::Vector4d &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>displacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcalculation_params.html">calculationParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>calc_params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs FEM calculation on a larger mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_file_name</td><td>Mesh file path </td></tr>
    <tr><td class="paramname">displacements</td><td>Vector of displacement specifications </td></tr>
    <tr><td class="paramname">calc_params</td><td>Calculation parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of displacement vector solution and total energy energy </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  916</span>                                                                                                           {</div>
<div class="line"><span class="lineno">  917</span> </div>
<div class="line"><span class="lineno">  918</span>    <span class="comment">// Initialize the necessary objects from LehrFEM++ to run the calculation</span></div>
<div class="line"><span class="lineno">  919</span>    <span class="keyword">auto</span> factory = std::make_unique&lt;lf::mesh::hybrid2d::MeshFactory&gt;(2);</div>
<div class="line"><span class="lineno">  920</span>    <span class="keyword">const</span> std::filesystem::path here = __FILE__;</div>
<div class="line"><span class="lineno">  921</span>    <span class="keyword">auto</span> working_dir = here.parent_path().parent_path();</div>
<div class="line"><span class="lineno">  922</span>    <span class="keyword">auto</span> mesh_full_path = working_dir / <span class="stringliteral">&quot;meshes&quot;</span> / mesh_file_name;</div>
<div class="line"><span class="lineno">  923</span> </div>
<div class="line"><span class="lineno">  924</span>    lf::io::GmshReader reader(std::move(factory), mesh_full_path);</div>
<div class="line"><span class="lineno">  925</span>    <span class="keyword">const</span> std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh_ptr = reader.mesh();</div>
<div class="line"><span class="lineno">  926</span> </div>
<div class="line"><span class="lineno">  927</span>    std::shared_ptr&lt;lf::uscalfe::UniformScalarFESpace&lt;double&gt;&gt; fe_space;</div>
<div class="line"><span class="lineno">  928</span>    <span class="keywordflow">if</span> (calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a> == 1){</div>
<div class="line"><span class="lineno">  929</span>        fe_space = std::make_shared&lt;lf::uscalfe::FeSpaceLagrangeO1&lt;double&gt;&gt;(mesh_ptr);</div>
<div class="line"><span class="lineno">  930</span>    }</div>
<div class="line"><span class="lineno">  931</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  932</span>        fe_space = std::make_shared&lt;lf::uscalfe::FeSpaceLagrangeO2&lt;double&gt;&gt;(mesh_ptr);</div>
<div class="line"><span class="lineno">  933</span>    }</div>
<div class="line"><span class="lineno">  934</span> </div>
<div class="line"><span class="lineno">  935</span>    <span class="keyword">const</span> lf::assemble::DofHandler &amp;dofh {fe_space-&gt;LocGlobMap()};</div>
<div class="line"><span class="lineno">  936</span>    <span class="keyword">const</span> lf::uscalfe::size_type N_dofs {dofh.NumDofs()};</div>
<div class="line"><span class="lineno">  937</span>    <span class="keyword">const</span> lf::mesh::Mesh &amp;mesh {*mesh_ptr};</div>
<div class="line"><span class="lineno">  938</span> </div>
<div class="line"><span class="lineno">  939</span>    <span class="comment">// Initialize our boundary conditions to 0 everywhere to start out</span></div>
<div class="line"><span class="lineno">  940</span>    lf::mesh::utils::CodimMeshDataSet bd_flags{mesh_ptr, 2, <span class="keyword">false</span>};</div>
<div class="line"><span class="lineno">  941</span>    std::vector&lt;std::pair&lt;bool, Eigen::Vector2d&gt;&gt; displacementBCs(N_dofs);</div>
<div class="line"><span class="lineno">  942</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; bc : displacementBCs) {</div>
<div class="line"><span class="lineno">  943</span>        bc.first = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  944</span>        bc.second = Eigen::Vector2d::Zero();</div>
<div class="line"><span class="lineno">  945</span>    }</div>
<div class="line"><span class="lineno">  946</span> </div>
<div class="line"><span class="lineno">  947</span>    <span class="comment">// Line up the displacement boundary conditions with the boundaries so they have the same indices the tuple</span></div>
<div class="line"><span class="lineno">  948</span>    <span class="comment">// contains (id, physical tag, index in displacements)</span></div>
<div class="line"><span class="lineno">  949</span>    std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; physical_boundary_tags (displacements.size());</div>
<div class="line"><span class="lineno">  950</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; displacements.size(); i++) {</div>
<div class="line"><span class="lineno">  951</span>        physical_boundary_tags.emplace_back(displacements[i].first, <a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[displacements[i].first].physicalTag, i);</div>
<div class="line"><span class="lineno">  952</span>    }</div>
<div class="line"><span class="lineno">  953</span> </div>
<div class="line"><span class="lineno">  954</span>    <span class="comment">// Iterate through all edges to find valid displacement BCs</span></div>
<div class="line"><span class="lineno">  955</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> lf::mesh::Entity *edge: mesh.Entities((1))) {</div>
<div class="line"><span class="lineno">  956</span>        <span class="keywordtype">int</span> <span class="keywordtype">id</span> = -1;</div>
<div class="line"><span class="lineno">  957</span>        <span class="keywordtype">int</span> index;</div>
<div class="line"><span class="lineno">  958</span>        <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  959</span> </div>
<div class="line"><span class="lineno">  960</span>        <span class="comment">// Find if the edge has one of the physical tags we&#39;re interested in</span></div>
<div class="line"><span class="lineno">  961</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; reader.PhysicalEntityNr(*edge).size(); ++i) {</div>
<div class="line"><span class="lineno">  962</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; physical_boundary_tags.size(); j++) {</div>
<div class="line"><span class="lineno">  963</span>                <span class="keywordflow">if</span> (reader.PhysicalEntityNr(*edge)[i] == std::get&lt;1&gt;(physical_boundary_tags[j])) {</div>
<div class="line"><span class="lineno">  964</span>                    <span class="keywordtype">id</span> = std::get&lt;0&gt;(physical_boundary_tags[j]);</div>
<div class="line"><span class="lineno">  965</span>                    index = std::get&lt;2&gt;(physical_boundary_tags[j]);</div>
<div class="line"><span class="lineno">  966</span>                    found = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  967</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  968</span>                }</div>
<div class="line"><span class="lineno">  969</span>            }</div>
<div class="line"><span class="lineno">  970</span>            <span class="keywordflow">if</span> (found) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  971</span>        }</div>
<div class="line"><span class="lineno">  972</span> </div>
<div class="line"><span class="lineno">  973</span>        <span class="comment">// If id is not -1, our edge is a part of a displacement BC</span></div>
<div class="line"><span class="lineno">  974</span>        <span class="keywordflow">if</span> (<span class="keywordtype">id</span> != -1) {</div>
<div class="line"><span class="lineno">  975</span> </div>
<div class="line"><span class="lineno">  976</span>            <span class="comment">// Iterate through the nodes on this edge, and prescribe a displacement BC if we haven&#39;t done so already</span></div>
<div class="line"><span class="lineno">  977</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span> node : edge-&gt;SubEntities(1)) {</div>
<div class="line"><span class="lineno">  978</span>                <span class="keywordflow">if</span> (!bd_flags(*node)) {</div>
<div class="line"><span class="lineno">  979</span>                    bd_flags(*node) = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  980</span> </div>
<div class="line"><span class="lineno">  981</span>                    <a class="code hl_class" href="class_line_mapping.html">LineMapping</a> my_lines (<a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[<span class="keywordtype">id</span>].points.first, <a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[<span class="keywordtype">id</span>].points.second,</div>
<div class="line"><span class="lineno">  982</span>                    <a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[<span class="keywordtype">id</span>].points.first + displacements[index].second.block&lt;2, 1&gt;(0, 0),</div>
<div class="line"><span class="lineno">  983</span>                    <a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>[<span class="keywordtype">id</span>].points.second + displacements[index].second.block&lt;2, 1&gt;(2, 0));</div>
<div class="line"><span class="lineno">  984</span> </div>
<div class="line"><span class="lineno">  985</span>                    <span class="keyword">auto</span> my_point = node-&gt;Geometry()-&gt;Global(node-&gt;Geometry()-&gt;RefEl().NodeCoords());</div>
<div class="line"><span class="lineno">  986</span> </div>
<div class="line"><span class="lineno">  987</span>                    Eigen::Vector2d BC = my_lines.mapPoint(my_point) - my_point;</div>
<div class="line"><span class="lineno">  988</span> </div>
<div class="line"><span class="lineno">  989</span>                    displacementBCs[mesh.Index(*node)] = {<span class="keyword">true</span>, BC};</div>
<div class="line"><span class="lineno">  990</span>                }</div>
<div class="line"><span class="lineno">  991</span>            }</div>
<div class="line"><span class="lineno">  992</span>        }</div>
<div class="line"><span class="lineno">  993</span>    }</div>
<div class="line"><span class="lineno">  994</span> </div>
<div class="line"><span class="lineno">  995</span>    <span class="comment">// Declare matrices and vector that will hold our solution, phi doesn&#39;t need to be changed for now</span></div>
<div class="line"><span class="lineno">  996</span>    lf::assemble::COOMatrix&lt;double&gt; A(N_dofs*2, N_dofs*2);</div>
<div class="line"><span class="lineno">  997</span>    Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt; phi(N_dofs*2);</div>
<div class="line"><span class="lineno">  998</span>    phi.setZero();</div>
<div class="line"><span class="lineno">  999</span> </div>
<div class="line"><span class="lineno"> 1000</span>    <span class="comment">// Build the stiffness matrix</span></div>
<div class="line"><span class="lineno"> 1001</span>    <span class="comment">// TODO: double check whether this is a planeStrain calculation (it is if this is set to true)</span></div>
<div class="line"><span class="lineno"> 1002</span>    <span class="keywordflow">if</span> (calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a> == 1) {</div>
<div class="line"><span class="lineno"> 1003</span>        <a class="code hl_class" href="class_linear_matrix_computation_1_1_linear_f_e_element_matrix.html">LinearMatrixComputation::LinearFEElementMatrix</a> assemble{calc_params.<a class="code hl_variable" href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">youngsModulus</a>,</div>
<div class="line"><span class="lineno"> 1004</span>            calc_params.<a class="code hl_variable" href="structcalculation_params.html#a474cb6b7c18758b753f1eda8d423604e">poissonRatio</a>, <span class="keyword">true</span>};</div>
<div class="line"><span class="lineno"> 1005</span>        <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#adbfe31593abe48a26e05aa1f964cdc70">LinearElasticityAssembler::AssembleMatrixLocally</a>(0, dofh, dofh, assemble, A);</div>
<div class="line"><span class="lineno"> 1006</span>    }</div>
<div class="line"><span class="lineno"> 1007</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1008</span>        <a class="code hl_class" href="class_parametric_matrix_computation_1_1_parametric_f_e_element_matrix.html">ParametricMatrixComputation::ParametricFEElementMatrix</a> assemble{calc_params.<a class="code hl_variable" href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">youngsModulus</a>,</div>
<div class="line"><span class="lineno"> 1009</span>            calc_params.<a class="code hl_variable" href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">youngsModulus</a>, <span class="keyword">true</span>};</div>
<div class="line"><span class="lineno"> 1010</span>        <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#adbfe31593abe48a26e05aa1f964cdc70">LinearElasticityAssembler::AssembleMatrixLocally</a>(0, dofh, dofh, assemble, A);</div>
<div class="line"><span class="lineno"> 1011</span>    }</div>
<div class="line"><span class="lineno"> 1012</span> </div>
<div class="line"><span class="lineno"> 1013</span>    <span class="comment">// Send to fixFlaggedSolutionsComponents to fit to the shape mentioned in NUMPDE 2.7.6.15</span></div>
<div class="line"><span class="lineno"> 1014</span>    <a class="code hl_function" href="namespace_mesh_parametrization.html#acd41b6a7ce9251b59725b4d6a93f631f">MeshParametrization::fixFlaggedSolutionComponentsLE</a>(displacementBCs, A, phi);</div>
<div class="line"><span class="lineno"> 1015</span> </div>
<div class="line"><span class="lineno"> 1016</span>    <span class="comment">// Solve the liner system and return the resulting displacement vector</span></div>
<div class="line"><span class="lineno"> 1017</span>    Eigen::SparseMatrix A_crs = A.makeSparse();</div>
<div class="line"><span class="lineno"> 1018</span>    Eigen::SparseLU&lt;Eigen::SparseMatrix&lt;double&gt;&gt; solver;</div>
<div class="line"><span class="lineno"> 1019</span>    solver.compute(A_crs);</div>
<div class="line"><span class="lineno"> 1020</span>    Eigen::VectorXd sol_vec = solver.solve(phi);</div>
<div class="line"><span class="lineno"> 1021</span> </div>
<div class="line"><span class="lineno"> 1022</span>    <span class="keywordtype">bool</span> linear_elastic;</div>
<div class="line"><span class="lineno"> 1023</span>    <span class="keywordtype">double</span> energy = 0;</div>
<div class="line"><span class="lineno"> 1024</span> </div>
<div class="line"><span class="lineno"> 1025</span>    <span class="comment">// Calculate the stress and strains to check if we are still in the linear elastic region, and calculate the energy</span></div>
<div class="line"><span class="lineno"> 1026</span>    <span class="keywordflow">if</span> (calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a> == 1){</div>
<div class="line"><span class="lineno"> 1027</span>        <a class="code hl_class" href="class_linear_matrix_computation_1_1_linear_f_e_element_matrix.html">LinearMatrixComputation::LinearFEElementMatrix</a> assemble{calc_params.<a class="code hl_variable" href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">youngsModulus</a>,</div>
<div class="line"><span class="lineno"> 1028</span>            calc_params.<a class="code hl_variable" href="structcalculation_params.html#a474cb6b7c18758b753f1eda8d423604e">poissonRatio</a>, <span class="keyword">true</span>};</div>
<div class="line"><span class="lineno"> 1029</span>        <span class="keyword">auto</span> stresses_strains = <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#a2b01541015c753760235905552a2225b">LinearElasticityAssembler::stressStrainLoader</a>(</div>
<div class="line"><span class="lineno"> 1030</span>            mesh_ptr, sol_vec, assemble, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a>);</div>
<div class="line"><span class="lineno"> 1031</span>        energy = <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#aa59969ea728ac197847183f3a73760ed">LinearElasticityAssembler::energyCalculator</a>(mesh_ptr, sol_vec, assemble, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a>);</div>
<div class="line"><span class="lineno"> 1032</span>        linear_elastic = <a class="code hl_function" href="namespace_mesh_parametrization.html#a40b958aa901405b1ce4db0bcfd7b8d6d">MeshParametrization::elasticRegion</a>(</div>
<div class="line"><span class="lineno"> 1033</span>            std::get&lt;2&gt;(stresses_strains), calc_params.<a class="code hl_variable" href="structcalculation_params.html#ace9b6fd27b86d83388100ac6ec85ce68">yieldStrength</a>);</div>
<div class="line"><span class="lineno"> 1034</span>    }</div>
<div class="line"><span class="lineno"> 1035</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1036</span>        <a class="code hl_class" href="class_parametric_matrix_computation_1_1_parametric_f_e_element_matrix.html">ParametricMatrixComputation::ParametricFEElementMatrix</a> assemble{calc_params.<a class="code hl_variable" href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">youngsModulus</a>,</div>
<div class="line"><span class="lineno"> 1037</span>            calc_params.<a class="code hl_variable" href="structcalculation_params.html#a474cb6b7c18758b753f1eda8d423604e">poissonRatio</a>, <span class="keyword">true</span>};</div>
<div class="line"><span class="lineno"> 1038</span>        <span class="keyword">auto</span> stresses_strains = <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#a2b01541015c753760235905552a2225b">LinearElasticityAssembler::stressStrainLoader</a>(</div>
<div class="line"><span class="lineno"> 1039</span>            mesh_ptr, sol_vec, assemble, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a>);</div>
<div class="line"><span class="lineno"> 1040</span>        energy = <a class="code hl_function" href="namespace_linear_elasticity_assembler.html#aa59969ea728ac197847183f3a73760ed">LinearElasticityAssembler::energyCalculator</a>(mesh_ptr, sol_vec, assemble, calc_params.<a class="code hl_variable" href="structcalculation_params.html#a9839ec496ba2e56a9c539506f6a1f2c1">order</a>);</div>
<div class="line"><span class="lineno"> 1041</span>        linear_elastic = <a class="code hl_function" href="namespace_mesh_parametrization.html#a40b958aa901405b1ce4db0bcfd7b8d6d">MeshParametrization::elasticRegion</a>(</div>
<div class="line"><span class="lineno"> 1042</span>            std::get&lt;2&gt;(stresses_strains), calc_params.<a class="code hl_variable" href="structcalculation_params.html#ace9b6fd27b86d83388100ac6ec85ce68">yieldStrength</a>);</div>
<div class="line"><span class="lineno"> 1043</span>    }</div>
<div class="line"><span class="lineno"> 1044</span> </div>
<div class="line"><span class="lineno"> 1045</span>    <span class="keywordflow">if</span> (linear_elastic) {</div>
<div class="line"><span class="lineno"> 1046</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;The provided displacement boundaries still allows for the shape to be in the linear elastic &quot;</span></div>
<div class="line"><span class="lineno"> 1047</span>                     <span class="stringliteral">&quot;region, with the energy being &quot;</span> &lt;&lt; energy &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1048</span>    }</div>
<div class="line"><span class="lineno"> 1049</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1050</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;WARNING: The provided displacement boundary conditions are outside of the linear elastic region &quot;</span></div>
<div class="line"><span class="lineno"> 1051</span>                     <span class="stringliteral">&quot;of the material, this may lead to incorrect results in the NN, with the energy being &quot;</span> &lt;&lt; energy</div>
<div class="line"><span class="lineno"> 1052</span>                    &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1053</span>    }</div>
<div class="line"><span class="lineno"> 1054</span>    <span class="keywordflow">return</span> {sol_vec, energy};</div>
<div class="line"><span class="lineno"> 1055</span>}</div>
<div class="ttc" id="aclass_linear_matrix_computation_1_1_linear_f_e_element_matrix_html"><div class="ttname"><a href="class_linear_matrix_computation_1_1_linear_f_e_element_matrix.html">LinearMatrixComputation::LinearFEElementMatrix</a></div><div class="ttdoc">Class for computing linear finite element stiffness matrices.</div><div class="ttdef"><b>Definition</b> linear_matrix_computation.h:20</div></div>
<div class="ttc" id="aclass_parametric_matrix_computation_1_1_parametric_f_e_element_matrix_html"><div class="ttname"><a href="class_parametric_matrix_computation_1_1_parametric_f_e_element_matrix.html">ParametricMatrixComputation::ParametricFEElementMatrix</a></div><div class="ttdoc">Class for computing parametric finite element stiffness matrices.</div><div class="ttdef"><b>Definition</b> parametric_matrix_computation.h:27</div></div>
<div class="ttc" id="anamespace_linear_elasticity_assembler_html_a2b01541015c753760235905552a2225b"><div class="ttname"><a href="namespace_linear_elasticity_assembler.html#a2b01541015c753760235905552a2225b">LinearElasticityAssembler::stressStrainLoader</a></div><div class="ttdeci">std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt; stressStrainLoader(const std::shared_ptr&lt; lf::mesh::Mesh &gt; &amp;mesh_ptr, Eigen::VectorXd &amp;disp_vec, ENTITY_MATRIX_PROVIDER &amp;assembler, int degree)</div><div class="ttdoc">Computes stress and strain fields from displacement solution.</div><div class="ttdef"><b>Definition</b> linear_elasticity_assembler.h:156</div></div>
<div class="ttc" id="anamespace_linear_elasticity_assembler_html_aa59969ea728ac197847183f3a73760ed"><div class="ttname"><a href="namespace_linear_elasticity_assembler.html#aa59969ea728ac197847183f3a73760ed">LinearElasticityAssembler::energyCalculator</a></div><div class="ttdeci">double energyCalculator(const std::shared_ptr&lt; lf::mesh::Mesh &gt; &amp;mesh_ptr, Eigen::VectorXd &amp;disp_vec, ENTITY_MATRIX_PROVIDER &amp;assembler, int degree)</div><div class="ttdoc">Calculates total strain energy of the system.</div><div class="ttdef"><b>Definition</b> linear_elasticity_assembler.h:244</div></div>
<div class="ttc" id="anamespace_linear_elasticity_assembler_html_adbfe31593abe48a26e05aa1f964cdc70"><div class="ttname"><a href="namespace_linear_elasticity_assembler.html#adbfe31593abe48a26e05aa1f964cdc70">LinearElasticityAssembler::AssembleMatrixLocally</a></div><div class="ttdeci">void AssembleMatrixLocally(lf::base::dim_t codim, const lf::assemble::DofHandler &amp;dof_handler_trial, const lf::assemble::DofHandler &amp;dof_handler_test, ENTITY_MATRIX_PROVIDER &amp;entity_matrix_provider, TMPMATRIX &amp;matrix)</div><div class="ttdoc">Assembles global stiffness matrix from local contributions.</div><div class="ttdef"><b>Definition</b> linear_elasticity_assembler.h:30</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_a40b958aa901405b1ce4db0bcfd7b8d6d"><div class="ttname"><a href="namespace_mesh_parametrization.html#a40b958aa901405b1ce4db0bcfd7b8d6d">MeshParametrization::elasticRegion</a></div><div class="ttdeci">bool elasticRegion(const Eigen::MatrixXd &amp;stresses, double yieldStrength)</div><div class="ttdoc">Checks if stress state is within elastic region of the material.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:721</div></div>
<div class="ttc" id="anamespace_mesh_parametrization_html_acd41b6a7ce9251b59725b4d6a93f631f"><div class="ttname"><a href="namespace_mesh_parametrization.html#acd41b6a7ce9251b59725b4d6a93f631f">MeshParametrization::fixFlaggedSolutionComponentsLE</a></div><div class="ttdeci">void fixFlaggedSolutionComponentsLE(std::vector&lt; std::pair&lt; bool, Eigen::Vector2d &gt; &gt; &amp;select_vals, lf::assemble::COOMatrix&lt; double &gt; &amp;A, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;phi)</div><div class="ttdoc">Fixes matrix to format 2.7.6.15 of NUMPDE lecture document.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.cc:669</div></div>
<div class="ttc" id="astructcalculation_params_html_a474cb6b7c18758b753f1eda8d423604e"><div class="ttname"><a href="structcalculation_params.html#a474cb6b7c18758b753f1eda8d423604e">calculationParams::poissonRatio</a></div><div class="ttdeci">double poissonRatio</div><div class="ttdoc">Poisson's ratio (ν)</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:38</div></div>
<div class="ttc" id="astructcalculation_params_html_ace9b6fd27b86d83388100ac6ec85ce68"><div class="ttname"><a href="structcalculation_params.html#ace9b6fd27b86d83388100ac6ec85ce68">calculationParams::yieldStrength</a></div><div class="ttdeci">double yieldStrength</div><div class="ttdoc">Material yield strength.</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:36</div></div>
<div class="ttc" id="astructcalculation_params_html_ae54bfa79920c9d530abaae7bc3faa4ed"><div class="ttname"><a href="structcalculation_params.html#ae54bfa79920c9d530abaae7bc3faa4ed">calculationParams::youngsModulus</a></div><div class="ttdeci">double youngsModulus</div><div class="ttdoc">Young's modulus (E)</div><div class="ttdef"><b>Definition</b> mesh_parametrization.h:37</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a52a5fdb888382c672b3a16d076562b24" name="a52a5fdb888382c672b3a16d076562b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a5fdb888382c672b3a16d076562b24">&#9670;&#160;</a></span>printCompatibilityConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printCompatibilityConditions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_compatibility_condition.html">CompatibilityCondition</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>conditions</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1447</span>                                                                                                {</div>
<div class="line"><span class="lineno"> 1448</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Compatibility Conditions:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1449</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; conditions.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1450</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; condition = conditions[i];</div>
<div class="line"><span class="lineno"> 1451</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Condition &quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1452</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Indices:         [&quot;</span> &lt;&lt; condition.indices.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; condition.indices.second &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1453</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  First Location:  [Branch: &quot;</span> &lt;&lt; condition.firstLocation.first</div>
<div class="line"><span class="lineno"> 1454</span>                  &lt;&lt; <span class="stringliteral">&quot;, Side: &quot;</span> &lt;&lt; condition.firstLocation.second &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1455</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Second Location: [Branch: &quot;</span> &lt;&lt; condition.secondLocation.first</div>
<div class="line"><span class="lineno"> 1456</span>                  &lt;&lt; <span class="stringliteral">&quot;, Side: &quot;</span> &lt;&lt; condition.secondLocation.second &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1457</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1458</span>    }</div>
<div class="line"><span class="lineno"> 1459</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acdd5933f4767a5b96e37868710b36c04" name="acdd5933f4767a5b96e37868710b36c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd5933f4767a5b96e37868710b36c04">&#9670;&#160;</a></span>printFixedDisplacementConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printFixedDisplacementConditions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_fixed_displacement_condition.html">FixedDisplacementCondition</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>conditions</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1638</span>                                                                                                        {</div>
<div class="line"><span class="lineno"> 1639</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; conditions.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1640</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; condition = conditions[i];</div>
<div class="line"><span class="lineno"> 1641</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Condition &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1642</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Indices: (&quot;</span> &lt;&lt; condition.indices.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; condition.indices.second &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1643</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Displacements: [&quot;</span></div>
<div class="line"><span class="lineno"> 1644</span>                  &lt;&lt; condition.displacements[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div>
<div class="line"><span class="lineno"> 1645</span>                  &lt;&lt; condition.displacements[1] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div>
<div class="line"><span class="lineno"> 1646</span>                  &lt;&lt; condition.displacements[2] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div>
<div class="line"><span class="lineno"> 1647</span>                  &lt;&lt; condition.displacements[3] &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1648</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1649</span>    }</div>
<div class="line"><span class="lineno"> 1650</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a36de5dd2ec6798d3163ffaf049247f20" name="a36de5dd2ec6798d3163ffaf049247f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36de5dd2ec6798d3163ffaf049247f20">&#9670;&#160;</a></span>printGraphState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printGraphState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1389</span>                                {</div>
<div class="line"><span class="lineno"> 1390</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Nodes:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1391</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [nodeId, node] : <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>) {</div>
<div class="line"><span class="lineno"> 1392</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Node &quot;</span> &lt;&lt; nodeId &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1393</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;    Surface Tags: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1394</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tag : node.surfaceTags) std::cout &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1395</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n    Boundary Tags: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1396</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tag : node.boundaryTags) std::cout &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1397</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n    Connected Edges: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1398</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edge : node.connectedEdges) std::cout &lt;&lt; edge &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1399</span>        std::cout &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1400</span>    }</div>
<div class="line"><span class="lineno"> 1401</span> </div>
<div class="line"><span class="lineno"> 1402</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\nEdges:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1403</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [edgeId, edge] : <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>) {</div>
<div class="line"><span class="lineno"> 1404</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Edge &quot;</span> &lt;&lt; edgeId &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1405</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;    Surface Tags: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1406</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tag : edge.surfaceTags) std::cout &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1407</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n    Boundary Tags: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1408</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tag : edge.boundaryTags) std::cout &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1409</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n    Connected Nodes: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1410</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node : edge.connectedNodes) std::cout &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1411</span>        std::cout &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1412</span>    }</div>
<div class="line"><span class="lineno"> 1413</span> </div>
<div class="line"><span class="lineno"> 1414</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Boundaries:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1415</span>    std::cout &lt;&lt; std::setfill(<span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::setw(30) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1416</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [boundaryID, boundary] : <a class="code hl_variable" href="#ad5cec0dcae353a95b3692a871ecf4cd1">boundaries</a>) {</div>
<div class="line"><span class="lineno"> 1417</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Boundary &quot;</span> &lt;&lt; boundaryID &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1418</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Physical Tag: &quot;</span> &lt;&lt; boundary.physicalTag &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1419</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Curve Tag: &quot;</span> &lt;&lt; boundary.curveTag &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1420</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Start and End Points: (&quot;</span> &lt;&lt;  boundary.points.first.transpose() &lt;&lt; <span class="stringliteral">&quot;), (&quot;</span></div>
<div class="line"><span class="lineno"> 1421</span>            &lt;&lt; boundary.points.second.transpose() &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1422</span>        std::cout &lt;&lt; std::setfill(<span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::setw(30) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1423</span>    }</div>
<div class="line"><span class="lineno"> 1424</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a87c4a6bf9b71266ad65a5e0274a70390" name="a87c4a6bf9b71266ad65a5e0274a70390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c4a6bf9b71266ad65a5e0274a70390">&#9670;&#160;</a></span>printMatrixComparison()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printMatrixComparison </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1530</span>                                                                                      {</div>
<div class="line"><span class="lineno"> 1531</span>    <span class="keywordtype">int</span> width = 15;</div>
<div class="line"><span class="lineno"> 1532</span>    <span class="keywordtype">int</span> precision = 6;</div>
<div class="line"><span class="lineno"> 1533</span>    <span class="comment">// Print column headers</span></div>
<div class="line"><span class="lineno"> 1534</span>    std::cout &lt;&lt; std::string(m1.cols() * width, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="stringliteral">&quot; | &quot;</span> &lt;&lt; std::string(m2.cols() * width, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1535</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m1.rows(); ++i) {</div>
<div class="line"><span class="lineno"> 1536</span>        <span class="comment">// Print row of first matrix</span></div>
<div class="line"><span class="lineno"> 1537</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m1.cols(); ++j) {</div>
<div class="line"><span class="lineno"> 1538</span>            std::cout &lt;&lt; std::setw(width) &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision) &lt;&lt; m1(i, j);</div>
<div class="line"><span class="lineno"> 1539</span>        }</div>
<div class="line"><span class="lineno"> 1540</span>        std::cout &lt;&lt; <span class="stringliteral">&quot; | &quot;</span>;</div>
<div class="line"><span class="lineno"> 1541</span>        <span class="comment">// Print row of second matrix</span></div>
<div class="line"><span class="lineno"> 1542</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m2.cols(); ++j) {</div>
<div class="line"><span class="lineno"> 1543</span>            std::cout &lt;&lt; std::setw(width) &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision) &lt;&lt; m2(i, j);</div>
<div class="line"><span class="lineno"> 1544</span>        }</div>
<div class="line"><span class="lineno"> 1545</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1546</span>    }</div>
<div class="line"><span class="lineno"> 1547</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1548</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a28a39ebda16edb97cde0f770192a6d00" name="a28a39ebda16edb97cde0f770192a6d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a39ebda16edb97cde0f770192a6d00">&#9670;&#160;</a></span>printMeshData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printMeshData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>geom_poly_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_poly_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXi &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_node_indices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1472</span>                                                           {</div>
<div class="line"><span class="lineno"> 1473</span> </div>
<div class="line"><span class="lineno"> 1474</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; geom_poly_points.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1475</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Matrix &quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1476</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; geom_points = geom_poly_points[i];</div>
<div class="line"><span class="lineno"> 1477</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; mesh_points = mesh_poly_points[i];</div>
<div class="line"><span class="lineno"> 1478</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; indices = mesh_node_indices[i];</div>
<div class="line"><span class="lineno"> 1479</span> </div>
<div class="line"><span class="lineno"> 1480</span>        std::cout &lt;&lt; std::setw(15) &lt;&lt; <span class="stringliteral">&quot;Geom X&quot;</span> &lt;&lt; std::setw(15) &lt;&lt; <span class="stringliteral">&quot;Geom Y&quot;</span></div>
<div class="line"><span class="lineno"> 1481</span>                  &lt;&lt; std::setw(15) &lt;&lt; <span class="stringliteral">&quot;Mesh X&quot;</span> &lt;&lt; std::setw(15) &lt;&lt; <span class="stringliteral">&quot;Mesh Y&quot;</span></div>
<div class="line"><span class="lineno"> 1482</span>                  &lt;&lt; std::setw(15) &lt;&lt; <span class="stringliteral">&quot;Index&quot;</span> &lt;&lt; std::setw(15) &lt;&lt; <span class="stringliteral">&quot;Distance&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1483</span> </div>
<div class="line"><span class="lineno"> 1484</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row = 0; row &lt; indices.rows(); ++row) {</div>
<div class="line"><span class="lineno"> 1485</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> col = 0; col &lt; indices.cols(); ++col) {</div>
<div class="line"><span class="lineno"> 1486</span>                <span class="keywordtype">double</span> geom_x = geom_points(2*row, col);</div>
<div class="line"><span class="lineno"> 1487</span>                <span class="keywordtype">double</span> geom_y = geom_points(2*row+1, col);</div>
<div class="line"><span class="lineno"> 1488</span>                <span class="keywordtype">double</span> mesh_x = mesh_points(2*row, col);</div>
<div class="line"><span class="lineno"> 1489</span>                <span class="keywordtype">double</span> mesh_y = mesh_points(2*row+1, col);</div>
<div class="line"><span class="lineno"> 1490</span> </div>
<div class="line"><span class="lineno"> 1491</span>                <span class="keywordtype">double</span> distance = std::sqrt(std::pow(geom_x - mesh_x, 2) + std::pow(geom_y - mesh_y, 2));</div>
<div class="line"><span class="lineno"> 1492</span> </div>
<div class="line"><span class="lineno"> 1493</span>                std::cout &lt;&lt; std::setw(15) &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; geom_x</div>
<div class="line"><span class="lineno"> 1494</span>                          &lt;&lt; std::setw(15) &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; geom_y</div>
<div class="line"><span class="lineno"> 1495</span>                          &lt;&lt; std::setw(15) &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; mesh_x</div>
<div class="line"><span class="lineno"> 1496</span>                          &lt;&lt; std::setw(15) &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; mesh_y</div>
<div class="line"><span class="lineno"> 1497</span>                          &lt;&lt; std::setw(15) &lt;&lt; indices(row, col)</div>
<div class="line"><span class="lineno"> 1498</span>                          &lt;&lt; std::setw(15) &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; distance &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1499</span>            }</div>
<div class="line"><span class="lineno"> 1500</span>        }</div>
<div class="line"><span class="lineno"> 1501</span>        std::cout &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1502</span>    }</div>
<div class="line"><span class="lineno"> 1503</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa0dde2184587428524c7eeb0c97b98c1" name="aa0dde2184587428524c7eeb0c97b98c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0dde2184587428524c7eeb0c97b98c1">&#9670;&#160;</a></span>printMeshGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printMeshGeometry </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1276</span>                                  {</div>
<div class="line"><span class="lineno"> 1277</span>    std::cout &lt;&lt; std::setfill(<span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::setw(50) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1278</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh Geometry:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1279</span>    std::cout &lt;&lt; std::setfill(<span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::setw(50) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1280</span> </div>
<div class="line"><span class="lineno"> 1281</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Nodes:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1282</span>    std::cout &lt;&lt; std::setfill(<span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::setw(30) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1283</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [nodeId, node] : <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>) {</div>
<div class="line"><span class="lineno"> 1284</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Node &quot;</span> &lt;&lt; nodeId &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1285</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Surfaces: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1286</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tag : node.surfaceTags) std::cout &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1287</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n  Boundary: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1288</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tag : node.boundaryTags) std::cout &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1289</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n  Connected Edges: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1290</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edge : node.connectedEdges) std::cout &lt;&lt; edge &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1291</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1292</span>        std::cout &lt;&lt; std::setfill(<span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::setw(30) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1293</span>    }</div>
<div class="line"><span class="lineno"> 1294</span> </div>
<div class="line"><span class="lineno"> 1295</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Edges:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1296</span>    std::cout &lt;&lt; std::setfill(<span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::setw(30) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1297</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [edgeId, edge] : <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>) {</div>
<div class="line"><span class="lineno"> 1298</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Edge &quot;</span> &lt;&lt; edgeId &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1299</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Surfaces: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1300</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tag : edge.surfaceTags) std::cout &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1301</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n  Boundary: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1302</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tag : edge.boundaryTags) std::cout &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1303</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n  Connected Nodes: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1304</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> node : edge.connectedNodes) std::cout &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1305</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1306</span>        std::cout &lt;&lt; std::setfill(<span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::setw(30) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1307</span>    }</div>
<div class="line"><span class="lineno"> 1308</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae35fc86c81fd0b9c6de2058ea0e8c238" name="ae35fc86c81fd0b9c6de2058ea0e8c238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35fc86c81fd0b9c6de2058ea0e8c238">&#9670;&#160;</a></span>printMeshMatricesAndDisplacements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printMeshMatricesAndDisplacements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>displacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>NN_energies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>true_energies</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1624</span>                                                                                                              {</div>
<div class="line"><span class="lineno"> 1625</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; mesh_points.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1626</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1627</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Parametrization Points:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1628</span> </div>
<div class="line"><span class="lineno"> 1629</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  points:\n&quot;</span> &lt;&lt; mesh_points[i] &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1630</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding Displacement Matrix:\n&quot;</span> &lt;&lt; displacements[i] &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1631</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding NN energy: &quot;</span> &lt;&lt; NN_energies[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1632</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding true energy: &quot;</span> &lt;&lt; true_energies[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1633</span> </div>
<div class="line"><span class="lineno"> 1634</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1635</span>    }</div>
<div class="line"><span class="lineno"> 1636</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1070a4b42b2eb53989fb9ca29133bdab" name="a1070a4b42b2eb53989fb9ca29133bdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1070a4b42b2eb53989fb9ca29133bdab">&#9670;&#160;</a></span>printMeshParamsAndDisplacements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printMeshParamsAndDisplacements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>displacements</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1551</span>                                                                                       {</div>
<div class="line"><span class="lineno"> 1552</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; mesh_params.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1553</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1554</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;MeshParametrizationData:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1555</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  numBranches: &quot;</span> &lt;&lt; mesh_params[i].numBranches &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1556</span> </div>
<div class="line"><span class="lineno"> 1557</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  widths:\n&quot;</span> &lt;&lt; mesh_params[i].widths &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1558</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  terminals:\n&quot;</span> &lt;&lt; mesh_params[i].terminals &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1559</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  vectors:\n&quot;</span> &lt;&lt; mesh_params[i].vectors &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1560</span> </div>
<div class="line"><span class="lineno"> 1561</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding Displacement Matrix:\n&quot;</span> &lt;&lt; displacements[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1562</span> </div>
<div class="line"><span class="lineno"> 1563</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1564</span>    }</div>
<div class="line"><span class="lineno"> 1565</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a61a23fd61bbd36d181a43f5b82a304" name="a4a61a23fd61bbd36d181a43f5b82a304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a61a23fd61bbd36d181a43f5b82a304">&#9670;&#160;</a></span>printMeshParamsAndDisplacementsAndEnergies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printMeshParamsAndDisplacementsAndEnergies </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>displacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>energies</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1569</span>                                                                           {</div>
<div class="line"><span class="lineno"> 1570</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; mesh_params.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1571</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1572</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;MeshParametrizationData:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1573</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  numBranches: &quot;</span> &lt;&lt; mesh_params[i].numBranches &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1574</span> </div>
<div class="line"><span class="lineno"> 1575</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  widths:\n&quot;</span> &lt;&lt; mesh_params[i].widths &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1576</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  terminals:\n&quot;</span> &lt;&lt; mesh_params[i].terminals &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1577</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  vectors:\n&quot;</span> &lt;&lt; mesh_params[i].vectors &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1578</span> </div>
<div class="line"><span class="lineno"> 1579</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding Displacement Matrix:\n&quot;</span> &lt;&lt; displacements[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1580</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding Energy: \n&quot;</span> &lt;&lt; energies[i] &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1581</span> </div>
<div class="line"><span class="lineno"> 1582</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1583</span>    }</div>
<div class="line"><span class="lineno"> 1584</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a130452deb2febae1092d4a0cbe0a8d7b" name="a130452deb2febae1092d4a0cbe0a8d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130452deb2febae1092d4a0cbe0a8d7b">&#9670;&#160;</a></span>printMeshParamsAndDisplacementsAndTrueEnergies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printMeshParamsAndDisplacementsAndTrueEnergies </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_mesh_parametrization_data.html">MeshParametrizationData</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>displacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>NN_energies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>true_energies</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1588</span>                                                                                                             {</div>
<div class="line"><span class="lineno"> 1589</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; mesh_params.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1590</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1591</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;MeshParametrizationData:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1592</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  numBranches: &quot;</span> &lt;&lt; mesh_params[i].numBranches &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1593</span> </div>
<div class="line"><span class="lineno"> 1594</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  widths:\n&quot;</span> &lt;&lt; mesh_params[i].widths &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1595</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  terminals:\n&quot;</span> &lt;&lt; mesh_params[i].terminals &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1596</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  vectors:\n&quot;</span> &lt;&lt; mesh_params[i].vectors &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1597</span> </div>
<div class="line"><span class="lineno"> 1598</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding Displacement Matrix:\n&quot;</span> &lt;&lt; displacements[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1599</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding NN Energy: \n&quot;</span> &lt;&lt; NN_energies[i] &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1600</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding true Energy: \n&quot;</span> &lt;&lt; true_energies[i] &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1601</span> </div>
<div class="line"><span class="lineno"> 1602</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1603</span>    }</div>
<div class="line"><span class="lineno"> 1604</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9d81c07ff9ade4b9186aad4b14ea9f0a" name="a9d81c07ff9ade4b9186aad4b14ea9f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d81c07ff9ade4b9186aad4b14ea9f0a">&#9670;&#160;</a></span>printMeshParamsAndEnergies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printMeshParamsAndEnergies </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; Eigen::MatrixXd &gt;, std::vector&lt; double &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1654</span>                                                                           {</div>
<div class="line"><span class="lineno"> 1655</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; [point_vector, displacement_vector, energy_vector] = data;</div>
<div class="line"><span class="lineno"> 1656</span>    <span class="keywordtype">double</span> total_energy = 0;</div>
<div class="line"><span class="lineno"> 1657</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Values of the inidividual param calculations: &quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1658</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; point_vector.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1659</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Point Matrix &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; point_vector[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1660</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Displacement BC &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; displacement_vector[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1661</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Energy: &quot;</span> &lt;&lt; energy_vector[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1662</span>        total_energy += energy_vector[i];</div>
<div class="line"><span class="lineno"> 1663</span>    }</div>
<div class="line"><span class="lineno"> 1664</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\nTotal Energy: &quot;</span> &lt;&lt; total_energy &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1665</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a02d843d6c74fc0db8c2c544c0081c6b0" name="a02d843d6c74fc0db8c2c544c0081c6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d843d6c74fc0db8c2c544c0081c6b0">&#9670;&#160;</a></span>printMeshPointsAndDisplacements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printMeshPointsAndDisplacements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_parametrization_points.html">ParametrizationPoints</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>displacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>energies</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1608</span>                                                                   {</div>
<div class="line"><span class="lineno"> 1609</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; mesh_points.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1610</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1611</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Parametrization Points:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1612</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  numBranches: &quot;</span> &lt;&lt; mesh_points[i].numBranches &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1613</span> </div>
<div class="line"><span class="lineno"> 1614</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  points:\n&quot;</span> &lt;&lt; mesh_points[i].points &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1615</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding Displacement Matrix:\n&quot;</span> &lt;&lt; displacements[i] &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1616</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Corresponding Energy: &quot;</span> &lt;&lt; energies[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1617</span> </div>
<div class="line"><span class="lineno"> 1618</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------------\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1619</span>    }</div>
<div class="line"><span class="lineno"> 1620</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3a6bc452bb6da7e0331305c58e186397" name="a3a6bc452bb6da7e0331305c58e186397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6bc452bb6da7e0331305c58e186397">&#9670;&#160;</a></span>printPartGraphState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printPartGraphState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_part_graph.html">PartGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>partGraph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1426</span>                                                              {</div>
<div class="line"><span class="lineno"> 1427</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1428</span>        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; part = partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>[i];</div>
<div class="line"><span class="lineno"> 1429</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Part &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; - Type: &quot;</span> &lt;&lt; (part.type == <a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a> ? <span class="stringliteral">&quot;Node&quot;</span> : <span class="stringliteral">&quot;Edge&quot;</span>)</div>
<div class="line"><span class="lineno"> 1430</span>                  &lt;&lt; <span class="stringliteral">&quot;, ID: &quot;</span> &lt;&lt; part.id &lt;&lt; <span class="stringliteral">&quot;, SubID: &quot;</span> &lt;&lt; part.subId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1431</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Surface Tags: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1432</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tag : part.surfaceTags) std::cout &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1433</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n  Boundary Tags: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1434</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tag : part.boundaryTags) std::cout &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1435</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n  Connected Edges: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1436</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [edgeId, portion] : part.connectedEdges)</div>
<div class="line"><span class="lineno"> 1437</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; edgeId &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; portion.first &lt;&lt; <span class="stringliteral">&quot;-&quot;</span> &lt;&lt; portion.second &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;</div>
<div class="line"><span class="lineno"> 1438</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n  Curve Tags: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1439</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [tag, orientation, portions] : part.curveTags)</div>
<div class="line"><span class="lineno"> 1440</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; tag &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; orientation &lt;&lt; <span class="stringliteral">&quot;, (&quot;</span> &lt;&lt; portions.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; portions.second &lt;&lt; <span class="stringliteral">&quot;)) &quot;</span>;</div>
<div class="line"><span class="lineno"> 1441</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\n  Adjacent Parts: &quot;</span>;</div>
<div class="line"><span class="lineno"> 1442</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> adj : partGraph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[i]) std::cout &lt;&lt; adj &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1443</span>        std::cout &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1444</span>    }</div>
<div class="line"><span class="lineno"> 1445</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a23e7c3fc81e733eaa764b31be4f6df16" name="a23e7c3fc81e733eaa764b31be4f6df16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e7c3fc81e733eaa764b31be4f6df16">&#9670;&#160;</a></span>printTrainingParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphMesh::printTrainingParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_n_training_params.html">NNTrainingParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1461</span>                                                                   {</div>
<div class="line"><span class="lineno"> 1462</span>    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(6);</div>
<div class="line"><span class="lineno"> 1463</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;NNTrainingParams:\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1464</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;  Length range:     [&quot;</span> &lt;&lt; params.<a class="code hl_variable" href="struct_n_n_training_params.html#acf82fd5c3bb9ac7fb49078cec5339a64">minMaxLength</a>.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; params.<a class="code hl_variable" href="struct_n_n_training_params.html#acf82fd5c3bb9ac7fb49078cec5339a64">minMaxLength</a>.second &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1465</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;  Width range:      [&quot;</span> &lt;&lt; params.<a class="code hl_variable" href="struct_n_n_training_params.html#aea3b24edf5275a63fb49f1ec09efaec6">minMaxWidth</a>.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; params.<a class="code hl_variable" href="struct_n_n_training_params.html#aea3b24edf5275a63fb49f1ec09efaec6">minMaxWidth</a>.second &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1466</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;  Width diff range: [&quot;</span> &lt;&lt; params.<a class="code hl_variable" href="struct_n_n_training_params.html#ae40dba74e8e4a3b6acebe8f29ab32317">minMaxWidthDiff</a>.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; params.<a class="code hl_variable" href="struct_n_n_training_params.html#ae40dba74e8e4a3b6acebe8f29ab32317">minMaxWidthDiff</a>.second &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1467</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;  Angle diff range: [&quot;</span> &lt;&lt; params.<a class="code hl_variable" href="struct_n_n_training_params.html#af4ca2d78eec7c24314627ac3633c3429">minMaxAngleDiff</a>.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; params.<a class="code hl_variable" href="struct_n_n_training_params.html#af4ca2d78eec7c24314627ac3633c3429">minMaxAngleDiff</a>.second &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 1468</span>}</div>
<div class="ttc" id="astruct_n_n_training_params_html_acf82fd5c3bb9ac7fb49078cec5339a64"><div class="ttname"><a href="struct_n_n_training_params.html#acf82fd5c3bb9ac7fb49078cec5339a64">NNTrainingParams::minMaxLength</a></div><div class="ttdeci">std::pair&lt; double, double &gt; minMaxLength</div><div class="ttdoc">Min/max length range.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:100</div></div>
<div class="ttc" id="astruct_n_n_training_params_html_ae40dba74e8e4a3b6acebe8f29ab32317"><div class="ttname"><a href="struct_n_n_training_params.html#ae40dba74e8e4a3b6acebe8f29ab32317">NNTrainingParams::minMaxWidthDiff</a></div><div class="ttdeci">std::pair&lt; double, double &gt; minMaxWidthDiff</div><div class="ttdoc">Min/max width difference range.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:102</div></div>
<div class="ttc" id="astruct_n_n_training_params_html_aea3b24edf5275a63fb49f1ec09efaec6"><div class="ttname"><a href="struct_n_n_training_params.html#aea3b24edf5275a63fb49f1ec09efaec6">NNTrainingParams::minMaxWidth</a></div><div class="ttdeci">std::pair&lt; double, double &gt; minMaxWidth</div><div class="ttdoc">Min/max width range.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:101</div></div>
<div class="ttc" id="astruct_n_n_training_params_html_af4ca2d78eec7c24314627ac3633c3429"><div class="ttname"><a href="struct_n_n_training_params.html#af4ca2d78eec7c24314627ac3633c3429">NNTrainingParams::minMaxAngleDiff</a></div><div class="ttdeci">std::pair&lt; double, double &gt; minMaxAngleDiff</div><div class="ttdoc">Min/max angle difference range.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:103</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a457d2958e23b465070fa1e32b82c15b7" name="a457d2958e23b465070fa1e32b82c15b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457d2958e23b465070fa1e32b82c15b7">&#9670;&#160;</a></span>splitMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_part_graph.html">PartGraph</a> GraphMesh::splitMesh </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>targetPartSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>nodeEdgePortion</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits mesh into parts. </p>
<p>The algorithm begins from the nodes and initializes those parts first according to the provided nodeEdgePortion, which must be under 0.5. Afterwards, the remaining edge parts are initialized according to the provided targetPartSize </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetPartSize</td><td>Target size for parts (in units of length) </td></tr>
    <tr><td class="paramname">nodeEdgePortion</td><td>Portion (percentage) of edges connected to this node to include </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph of mesh parts </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  242</span>                                                                                  {</div>
<div class="line"><span class="lineno">  243</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Starting splitMesh function with targetPartSize: &quot;</span> &lt;&lt; targetPartSize &lt;&lt; <span class="stringliteral">&quot; and nodeEdgePortion: &quot;</span> &lt;&lt; nodeEdgePortion &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  244</span> </div>
<div class="line"><span class="lineno">  245</span>    <span class="comment">// partGraph will contain all the meshParts and their respective connectivity</span></div>
<div class="line"><span class="lineno">  246</span>    <span class="comment">// partIndices is a mapping (Edge v Node type, ID, subID) -&gt; index in the partGraph for easy access</span></div>
<div class="line"><span class="lineno">  247</span>    <span class="comment">// throughout this function</span></div>
<div class="line"><span class="lineno">  248</span>    <a class="code hl_struct" href="struct_part_graph.html">PartGraph</a> partGraph;</div>
<div class="line"><span class="lineno">  249</span>    std::map&lt;std::tuple&lt;MeshPart::Type, int, int&gt;, <span class="keywordtype">size_t</span>&gt; partIndices;</div>
<div class="line"><span class="lineno">  250</span> </div>
<div class="line"><span class="lineno">  251</span>    <span class="comment">// TODO: Maybe make sure targetPartSize is somehow less than the overall edge length</span></div>
<div class="line"><span class="lineno">  252</span> </div>
<div class="line"><span class="lineno">  253</span>    <span class="comment">// Iterate through all nodes to create their respective parts</span></div>
<div class="line"><span class="lineno">  254</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Processing nodes...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  255</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [nodeId, node] : <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>) {</div>
<div class="line"><span class="lineno">  256</span>        <span class="comment">// Initialize what we can of our meshPart, connectedEdges, connectedEdgeTags, and curveTags remain</span></div>
<div class="line"><span class="lineno">  257</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Processing node &quot;</span> &lt;&lt; nodeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  258</span>        <a class="code hl_struct" href="struct_mesh_part.html">MeshPart</a> part;</div>
<div class="line"><span class="lineno">  259</span>        part.<a class="code hl_variable" href="struct_mesh_part.html#ac2e2df82f1c9a6898bea7a6ad0f11a3a">type</a> = <a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a>;</div>
<div class="line"><span class="lineno">  260</span>        part.<a class="code hl_variable" href="struct_mesh_part.html#a5e1f7ab7eae3db3a56db6f0b10330b2a">id</a> = nodeId;</div>
<div class="line"><span class="lineno">  261</span>        part.<a class="code hl_variable" href="struct_mesh_part.html#a15042c0e341914adb421b20083021581">subId</a> = 0; <span class="comment">// subId is only relevant for edge parts</span></div>
<div class="line"><span class="lineno">  262</span>        part.<a class="code hl_variable" href="struct_mesh_part.html#a4d5ecb98bb14ec056d0d76d5fc19791c">surfaceTags</a> = node.surfaceTags;</div>
<div class="line"><span class="lineno">  263</span>        part.<a class="code hl_variable" href="struct_mesh_part.html#ac0421bafeb7f7a3f7cc7d53e9c883ef0">boundaryTags</a> = node.boundaryTags;</div>
<div class="line"><span class="lineno">  264</span> </div>
<div class="line"><span class="lineno">  265</span>        <span class="comment">// Store the tags of connected edges to update the connectedEdgeTags since this is a node part,</span></div>
<div class="line"><span class="lineno">  266</span>        <span class="comment">// also store the part or portion of each edge belonging to this node part</span></div>
<div class="line"><span class="lineno">  267</span>        std::vector&lt;int&gt; connectedEdgeTags;</div>
<div class="line"><span class="lineno">  268</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edgeId : node.connectedEdges) {</div>
<div class="line"><span class="lineno">  269</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;    Processing connected edge &quot;</span> &lt;&lt; edgeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  270</span> </div>
<div class="line"><span class="lineno">  271</span>            <span class="comment">// We determine what portion of the connected edge we want depending on if it is the first node,</span></div>
<div class="line"><span class="lineno">  272</span>            <span class="comment">// making sure, for later connection reasons, that we go from the node outwards</span></div>
<div class="line"><span class="lineno">  273</span>            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge = <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[edgeId];</div>
<div class="line"><span class="lineno">  274</span>            <span class="keywordtype">bool</span> isFirstNode = (edge.connectedNodes[0] == nodeId);</div>
<div class="line"><span class="lineno">  275</span>            <span class="keywordtype">double</span> startPortion = isFirstNode ? 0.0 : 1.0;</div>
<div class="line"><span class="lineno">  276</span>            <span class="keywordtype">double</span> endPortion = isFirstNode ? nodeEdgePortion : (1.0 - nodeEdgePortion);</div>
<div class="line"><span class="lineno">  277</span>            part.<a class="code hl_variable" href="struct_mesh_part.html#a4f9192c1108599f8002dd34083b91579">connectedEdges</a>.emplace_back(edgeId,std::make_pair(startPortion, endPortion));</div>
<div class="line"><span class="lineno">  278</span>            connectedEdgeTags.push_back(edgeId);</div>
<div class="line"><span class="lineno">  279</span> </div>
<div class="line"><span class="lineno">  280</span>            <span class="comment">// Find the spline curves for this connected edge</span></div>
<div class="line"><span class="lineno">  281</span>            std::vector&lt;int&gt; splineTags = <a class="code hl_function" href="#aec778de2b75006ca9dfd067d6fe78f01">findSplineCurves</a>(edge.boundaryTags);</div>
<div class="line"><span class="lineno">  282</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;    Found &quot;</span> &lt;&lt; splineTags.size() &lt;&lt; <span class="stringliteral">&quot; spline tags for edge &quot;</span> &lt;&lt; edgeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  283</span>            LF_ASSERT_MSG(splineTags.size() == 2, <span class="stringliteral">&quot;The spline tags returned for edge with id &quot;</span> &lt;&lt; edgeId &lt;&lt;</div>
<div class="line"><span class="lineno">  284</span>                <span class="stringliteral">&quot; returned &quot;</span> &lt;&lt; splineTags.size() &lt;&lt; <span class="stringliteral">&quot; splines, when it should return 2&quot;</span>);</div>
<div class="line"><span class="lineno">  285</span> </div>
<div class="line"><span class="lineno">  286</span>            <span class="comment">// For the splines we want to interpolate from, we add the tag, their orientation, and portion to curveTags</span></div>
<div class="line"><span class="lineno">  287</span>            <span class="keywordflow">if</span> (splineTags.size() == 2) {</div>
<div class="line"><span class="lineno">  288</span>                <span class="keywordtype">int</span> sharedLineTag = <a class="code hl_function" href="#ae6d37ebae2f4bee3913773d9951aed6d">findSharedLine</a>(node.boundaryTags, edge.boundaryTags);</div>
<div class="line"><span class="lineno">  289</span>                std::cout &lt;&lt; <span class="stringliteral">&quot;    Shared line tag: &quot;</span> &lt;&lt; sharedLineTag &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  290</span> </div>
<div class="line"><span class="lineno">  291</span>                <span class="comment">// Once we have determined the shared line, we can obtain the orientation of both splines on this edge</span></div>
<div class="line"><span class="lineno">  292</span>                <span class="keywordflow">if</span> (sharedLineTag != -1) {</div>
<div class="line"><span class="lineno">  293</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> splineTag : splineTags) {</div>
<div class="line"><span class="lineno">  294</span>                        <span class="keywordtype">int</span> orientation = <a class="code hl_function" href="#ad522efd135fa5daecba00eeeaffcb940">determineSplineOrientation</a>(splineTag, sharedLineTag);</div>
<div class="line"><span class="lineno">  295</span>                        <span class="keywordflow">if</span> (isFirstNode) {</div>
<div class="line"><span class="lineno">  296</span>                            std::cout &lt;&lt; <span class="stringliteral">&quot;    Spline tag: &quot;</span> &lt;&lt; splineTag &lt;&lt; <span class="stringliteral">&quot;, Orientation: &quot;</span> &lt;&lt; orientation &lt;&lt; <span class="stringliteral">&quot; , startPortion: &quot;</span> &lt;&lt; startPortion &lt;&lt; <span class="stringliteral">&quot;, endPortion: &quot;</span> &lt;&lt; endPortion &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  297</span>                            part.<a class="code hl_variable" href="struct_mesh_part.html#aa0c6cb80b5239276c9e28460bc611cfa">curveTags</a>.emplace_back(splineTag, orientation, std::make_pair(startPortion, endPortion));</div>
<div class="line"><span class="lineno">  298</span>                        }</div>
<div class="line"><span class="lineno">  299</span>                        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  300</span>                            std::cout &lt;&lt; <span class="stringliteral">&quot;    Spline tag: &quot;</span> &lt;&lt; splineTag &lt;&lt; <span class="stringliteral">&quot;, Orientation (switched): &quot;</span> &lt;&lt; -orientation &lt;&lt; <span class="stringliteral">&quot; , startPortion: &quot;</span> &lt;&lt; startPortion &lt;&lt; <span class="stringliteral">&quot;, endPortion: &quot;</span> &lt;&lt; endPortion &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  301</span>                            part.<a class="code hl_variable" href="struct_mesh_part.html#aa0c6cb80b5239276c9e28460bc611cfa">curveTags</a>.emplace_back(splineTag, -orientation, std::make_pair(startPortion, endPortion));</div>
<div class="line"><span class="lineno">  302</span>                        }</div>
<div class="line"><span class="lineno">  303</span>                    }</div>
<div class="line"><span class="lineno">  304</span>                }</div>
<div class="line"><span class="lineno">  305</span>            }</div>
<div class="line"><span class="lineno">  306</span>        }</div>
<div class="line"><span class="lineno">  307</span>        part.<a class="code hl_variable" href="struct_mesh_part.html#a505deab73f81e7501ec5f97f9ce18082">connectedEdgeTags</a> = connectedEdgeTags;</div>
<div class="line"><span class="lineno">  308</span> </div>
<div class="line"><span class="lineno">  309</span>        <span class="comment">// Update the partIndices mapping to easily update the adjacency list later</span></div>
<div class="line"><span class="lineno">  310</span>        partIndices[std::make_tuple(<a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a>, nodeId, 0)] = partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.size();</div>
<div class="line"><span class="lineno">  311</span>        partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.push_back(std::move(part));</div>
<div class="line"><span class="lineno">  312</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Finished processing node &quot;</span> &lt;&lt; nodeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  313</span>    }</div>
<div class="line"><span class="lineno">  314</span> </div>
<div class="line"><span class="lineno">  315</span>    <span class="comment">// Iterate through all edges, where the plan is to divide up each portion that is not part of a node</span></div>
<div class="line"><span class="lineno">  316</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Processing edges...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  317</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [edgeId, edge] : <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>) {</div>
<div class="line"><span class="lineno">  318</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Processing edge &quot;</span> &lt;&lt; edgeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  319</span>        <span class="keywordtype">double</span> edgeLength = <a class="code hl_function" href="#abc53123269ec018b2484e359590ca186">getEdgeLength</a>(edgeId);</div>
<div class="line"><span class="lineno">  320</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Edge length: &quot;</span> &lt;&lt; edgeLength &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  321</span> </div>
<div class="line"><span class="lineno">  322</span>        <span class="comment">// Adjust the number of divisions based on whether the edge is connected to one or two nodes</span></div>
<div class="line"><span class="lineno">  323</span>        <span class="keywordtype">double</span> effectiveLength = edge.connectedNodes.size() == 1 ? edgeLength * (1 - nodeEdgePortion) : edgeLength * (1 - 2 * nodeEdgePortion);</div>
<div class="line"><span class="lineno">  324</span>        <span class="keywordtype">int</span> edgeDivisions = std::max(1, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(std::round(effectiveLength / targetPartSize)));</div>
<div class="line"><span class="lineno">  325</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Effective length: &quot;</span> &lt;&lt; effectiveLength &lt;&lt; <span class="stringliteral">&quot;, Edge divisions: &quot;</span> &lt;&lt; edgeDivisions &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  326</span> </div>
<div class="line"><span class="lineno">  327</span>        <span class="comment">// Depending on whether this edge is connected to 1 or 2 nodes we initialize the portion we&#39;re splitting</span></div>
<div class="line"><span class="lineno">  328</span>        <span class="keywordtype">double</span> startPortion = nodeEdgePortion;</div>
<div class="line"><span class="lineno">  329</span>        <span class="keywordtype">double</span> endPortion = edge.connectedNodes.size() == 1 ? 1.0 : 1.0 - nodeEdgePortion;</div>
<div class="line"><span class="lineno">  330</span>        <span class="keywordtype">double</span> step = (endPortion - startPortion) / edgeDivisions;</div>
<div class="line"><span class="lineno">  331</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Start portion: &quot;</span> &lt;&lt; startPortion &lt;&lt; <span class="stringliteral">&quot;, End portion: &quot;</span> &lt;&lt; endPortion &lt;&lt; <span class="stringliteral">&quot;, Step: &quot;</span> &lt;&lt; step &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  332</span> </div>
<div class="line"><span class="lineno">  333</span>        <span class="comment">// Obtain splines for which we will interpolate from later</span></div>
<div class="line"><span class="lineno">  334</span>        std::vector&lt;int&gt; splineTags = <a class="code hl_function" href="#aec778de2b75006ca9dfd067d6fe78f01">findSplineCurves</a>(edge.boundaryTags);</div>
<div class="line"><span class="lineno">  335</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Found &quot;</span> &lt;&lt; splineTags.size() &lt;&lt; <span class="stringliteral">&quot; spline tags for edge &quot;</span> &lt;&lt; edgeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  336</span> </div>
<div class="line"><span class="lineno">  337</span>        std::vector&lt;int&gt; splineOrientations(2);</div>
<div class="line"><span class="lineno">  338</span>        <span class="comment">// We check if it&#39;s empty, though it shouldn&#39;t be assuming correct naming</span></div>
<div class="line"><span class="lineno">  339</span>        <span class="keywordflow">if</span> (!edge.connectedNodes.empty()) {</div>
<div class="line"><span class="lineno">  340</span> </div>
<div class="line"><span class="lineno">  341</span>            <span class="comment">// We find the shared line tag in order to determine spline orientations</span></div>
<div class="line"><span class="lineno">  342</span>            <span class="keywordtype">int</span> sharedLineTag = <a class="code hl_function" href="#ae6d37ebae2f4bee3913773d9951aed6d">findSharedLine</a>(<a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>[edge.connectedNodes[0]].boundaryTags, edge.boundaryTags);</div>
<div class="line"><span class="lineno">  343</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;  Shared line tag: &quot;</span> &lt;&lt; sharedLineTag &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  345</span>            <span class="comment">// sharedLineTag is equal to -1 if a shared line wasn&#39;t found in the first place, shouldn&#39;t happen</span></div>
<div class="line"><span class="lineno">  346</span>            <span class="keywordflow">if</span> (sharedLineTag != -1) {</div>
<div class="line"><span class="lineno">  347</span>                splineOrientations[0] = <a class="code hl_function" href="#ad522efd135fa5daecba00eeeaffcb940">determineSplineOrientation</a>(splineTags[0], sharedLineTag);</div>
<div class="line"><span class="lineno">  348</span>                splineOrientations[1] = <a class="code hl_function" href="#ad522efd135fa5daecba00eeeaffcb940">determineSplineOrientation</a>(splineTags[1], sharedLineTag);</div>
<div class="line"><span class="lineno">  349</span>                std::cout &lt;&lt; <span class="stringliteral">&quot;  Spline orientations: &quot;</span> &lt;&lt; splineOrientations[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; splineOrientations[1] &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  350</span>            }</div>
<div class="line"><span class="lineno">  351</span>        }</div>
<div class="line"><span class="lineno">  352</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  353</span>            LF_ASSERT_MSG(<span class="keyword">false</span>, <span class="stringliteral">&quot;Edge does not have a connected node in splitMesh&quot;</span>);</div>
<div class="line"><span class="lineno">  354</span>        }</div>
<div class="line"><span class="lineno">  355</span> </div>
<div class="line"><span class="lineno">  356</span>        <span class="comment">// We now add these edge parts along with their corresponding portions</span></div>
<div class="line"><span class="lineno">  357</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; edgeDivisions; ++i) {</div>
<div class="line"><span class="lineno">  358</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;    Creating edge part &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; for edge &quot;</span> &lt;&lt; edgeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  359</span>            <a class="code hl_struct" href="struct_mesh_part.html">MeshPart</a> part;</div>
<div class="line"><span class="lineno">  360</span>            part.<a class="code hl_variable" href="struct_mesh_part.html#ac2e2df82f1c9a6898bea7a6ad0f11a3a">type</a> = <a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea72387ca6280f8711f81167ccbda14a29">MeshPart::EDGE</a>;</div>
<div class="line"><span class="lineno">  361</span>            part.<a class="code hl_variable" href="struct_mesh_part.html#a5e1f7ab7eae3db3a56db6f0b10330b2a">id</a> = edgeId;</div>
<div class="line"><span class="lineno">  362</span>            part.<a class="code hl_variable" href="struct_mesh_part.html#a15042c0e341914adb421b20083021581">subId</a> = i;</div>
<div class="line"><span class="lineno">  363</span>            part.<a class="code hl_variable" href="struct_mesh_part.html#a4d5ecb98bb14ec056d0d76d5fc19791c">surfaceTags</a> = edge.surfaceTags;</div>
<div class="line"><span class="lineno">  364</span>            part.<a class="code hl_variable" href="struct_mesh_part.html#ac0421bafeb7f7a3f7cc7d53e9c883ef0">boundaryTags</a> = edge.boundaryTags;</div>
<div class="line"><span class="lineno">  365</span> </div>
<div class="line"><span class="lineno">  366</span>            <span class="comment">// Add the portion for this edge, that we calculated above</span></div>
<div class="line"><span class="lineno">  367</span>            <span class="keywordtype">double</span> partStart = startPortion + i * step;</div>
<div class="line"><span class="lineno">  368</span>            <span class="keywordtype">double</span> partEnd = partStart + step;</div>
<div class="line"><span class="lineno">  369</span>            part.<a class="code hl_variable" href="struct_mesh_part.html#a4f9192c1108599f8002dd34083b91579">connectedEdges</a>.emplace_back(edgeId, std::make_pair(partStart, partEnd));</div>
<div class="line"><span class="lineno">  370</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;    Part range: &quot;</span> &lt;&lt; partStart &lt;&lt; <span class="stringliteral">&quot; to &quot;</span> &lt;&lt; partEnd &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  371</span> </div>
<div class="line"><span class="lineno">  372</span>            <span class="comment">// Add the orientations we just found above for this edge</span></div>
<div class="line"><span class="lineno">  373</span>            part.<a class="code hl_variable" href="struct_mesh_part.html#aa0c6cb80b5239276c9e28460bc611cfa">curveTags</a>.emplace_back(splineTags[0], splineOrientations[0], std::make_pair(partStart, partEnd));</div>
<div class="line"><span class="lineno">  374</span>            part.<a class="code hl_variable" href="struct_mesh_part.html#aa0c6cb80b5239276c9e28460bc611cfa">curveTags</a>.emplace_back(splineTags[1], splineOrientations[1], std::make_pair(partStart, partEnd));</div>
<div class="line"><span class="lineno">  375</span> </div>
<div class="line"><span class="lineno">  376</span>            <span class="comment">// Add this part to our mapping for easy access later regarding the adjacency list</span></div>
<div class="line"><span class="lineno">  377</span>            partIndices[std::make_tuple(<a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea72387ca6280f8711f81167ccbda14a29">MeshPart::EDGE</a>, edgeId, i)] = partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.size();</div>
<div class="line"><span class="lineno">  378</span>            partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.push_back(std::move(part));</div>
<div class="line"><span class="lineno">  379</span>        }</div>
<div class="line"><span class="lineno">  380</span>    }</div>
<div class="line"><span class="lineno">  381</span> </div>
<div class="line"><span class="lineno">  382</span>    <span class="comment">// Build adjacency list to correct size now that all parts have been initialized</span></div>
<div class="line"><span class="lineno">  383</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Building adjacency list...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  384</span>    partGraph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>.resize(partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.size());</div>
<div class="line"><span class="lineno">  385</span> </div>
<div class="line"><span class="lineno">  386</span>    <span class="comment">// Now that all edge parts are defined, we see which edge parts are connected to which node</span></div>
<div class="line"><span class="lineno">  387</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Connecting nodes to edge parts...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  388</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [nodeId, node] : <a class="code hl_variable" href="#aa3f6281813689df21df1e3da33988b97">nodes</a>) {</div>
<div class="line"><span class="lineno">  389</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Processing node &quot;</span> &lt;&lt; nodeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  390</span> </div>
<div class="line"><span class="lineno">  391</span>        <span class="comment">// Obtain the index for this node part in adjacencyList</span></div>
<div class="line"><span class="lineno">  392</span>        <span class="keywordtype">size_t</span> nodePartIndex = partIndices[std::make_tuple(<a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea6bced315504908f4eb50dba34c44191a">MeshPart::NODE</a>, nodeId, 0)];</div>
<div class="line"><span class="lineno">  393</span> </div>
<div class="line"><span class="lineno">  394</span>        <span class="comment">// Iterate through this node&#39;s connectedEdges</span></div>
<div class="line"><span class="lineno">  395</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edgeId : node.connectedEdges) {</div>
<div class="line"><span class="lineno">  396</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;    Processing connected edge &quot;</span> &lt;&lt; edgeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  397</span>            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge = <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>[edgeId];</div>
<div class="line"><span class="lineno">  398</span> </div>
<div class="line"><span class="lineno">  399</span>            <span class="comment">// Determine which side of the edge to connect to this node</span></div>
<div class="line"><span class="lineno">  400</span>            <span class="keywordtype">bool</span> isFirstNode = (edge.connectedNodes[0] == nodeId);</div>
<div class="line"><span class="lineno">  401</span>            <span class="keywordtype">int</span> sideIndex = isFirstNode ? 0 : 1;</div>
<div class="line"><span class="lineno">  402</span> </div>
<div class="line"><span class="lineno">  403</span>            <span class="comment">// Find the first and last edge parts on this side, there should always be at least 2</span></div>
<div class="line"><span class="lineno">  404</span>            <span class="keywordtype">size_t</span> firstEdgePartIndex = partIndices[std::make_tuple(<a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea72387ca6280f8711f81167ccbda14a29">MeshPart::EDGE</a>, edgeId, 0)];</div>
<div class="line"><span class="lineno">  405</span>            <span class="keywordtype">size_t</span> lastEdgePartIndex = partIndices[std::make_tuple(<a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea72387ca6280f8711f81167ccbda14a29">MeshPart::EDGE</a>, edgeId,</div>
<div class="line"><span class="lineno">  406</span>                                                                   std::count_if(partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.begin(), partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.end(),</div>
<div class="line"><span class="lineno">  407</span>                                                                                 [edgeId](<span class="keyword">const</span> <a class="code hl_struct" href="struct_mesh_part.html">MeshPart</a>&amp; part) { return part.type == MeshPart::EDGE &amp;&amp; part.id == edgeId; }) - 1)];</div>
<div class="line"><span class="lineno">  408</span> </div>
<div class="line"><span class="lineno">  409</span>            <span class="comment">// Connect the node to the appropriate edge parts, and the edge part to the appropriate node</span></div>
<div class="line"><span class="lineno">  410</span>            <span class="keywordflow">if</span> (sideIndex == 0) {</div>
<div class="line"><span class="lineno">  411</span>                std::cout &lt;&lt; <span class="stringliteral">&quot;    Connecting node &quot;</span> &lt;&lt; nodeId &lt;&lt; <span class="stringliteral">&quot; to first edge part of edge &quot;</span> &lt;&lt; edgeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  412</span>                partGraph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[nodePartIndex].push_back(firstEdgePartIndex);</div>
<div class="line"><span class="lineno">  413</span>                partGraph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[firstEdgePartIndex].push_back(nodePartIndex);</div>
<div class="line"><span class="lineno">  414</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  415</span>                std::cout &lt;&lt; <span class="stringliteral">&quot;    Connecting node &quot;</span> &lt;&lt; nodeId &lt;&lt; <span class="stringliteral">&quot; to last edge part of edge &quot;</span> &lt;&lt; edgeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  416</span>                partGraph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[nodePartIndex].push_back(lastEdgePartIndex);</div>
<div class="line"><span class="lineno">  417</span>                partGraph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[lastEdgePartIndex].push_back(nodePartIndex);</div>
<div class="line"><span class="lineno">  418</span>            }</div>
<div class="line"><span class="lineno">  419</span>        }</div>
<div class="line"><span class="lineno">  420</span>    }</div>
<div class="line"><span class="lineno">  421</span> </div>
<div class="line"><span class="lineno">  422</span>    <span class="comment">// Iterate through all Edges to connect adjacent edgeParts</span></div>
<div class="line"><span class="lineno">  423</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Connecting adjacent edge parts...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  424</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : <a class="code hl_variable" href="#a08fddd298e36dc790c25f569828df0e1">edges</a>) {</div>
<div class="line"><span class="lineno">  425</span>        <span class="keywordtype">int</span> edgeId = pair.first;</div>
<div class="line"><span class="lineno">  426</span>        <a class="code hl_struct" href="struct_edge2_d.html">Edge2D</a> edge = pair.second;</div>
<div class="line"><span class="lineno">  427</span> </div>
<div class="line"><span class="lineno">  428</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Processing edge &quot;</span> &lt;&lt; edgeId &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  429</span>        <span class="comment">// This returns the number of parts making up the sub-divisions of the edge</span></div>
<div class="line"><span class="lineno">  430</span>        <span class="keywordtype">int</span> edgeDivisions = std::count_if(partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.begin(), partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.end(),</div>
<div class="line"><span class="lineno">  431</span>                                          [edgeId](<span class="keyword">const</span> <a class="code hl_struct" href="struct_mesh_part.html">MeshPart</a>&amp; part) { return part.type == MeshPart::EDGE &amp;&amp; part.id == edgeId; });</div>
<div class="line"><span class="lineno">  432</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  Edge divisions: &quot;</span> &lt;&lt; edgeDivisions &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  433</span> </div>
<div class="line"><span class="lineno">  434</span>        <span class="comment">// Loop through almost all edge Divisions</span></div>
<div class="line"><span class="lineno">  435</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; edgeDivisions - 1; ++i) {</div>
<div class="line"><span class="lineno">  436</span> </div>
<div class="line"><span class="lineno">  437</span>            <span class="comment">// Correctly update the adjacency list of these divisions</span></div>
<div class="line"><span class="lineno">  438</span>            <span class="keywordtype">size_t</span> currentPartIndex = partIndices[std::make_tuple(<a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea72387ca6280f8711f81167ccbda14a29">MeshPart::EDGE</a>, edgeId, i)];</div>
<div class="line"><span class="lineno">  439</span>            <span class="keywordtype">size_t</span> nextPartIndex = partIndices[std::make_tuple(<a class="code hl_enumvalue" href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea72387ca6280f8711f81167ccbda14a29">MeshPart::EDGE</a>, edgeId, i + 1)];</div>
<div class="line"><span class="lineno">  440</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;    Connecting edge part &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; to edge part &quot;</span> &lt;&lt; (i+1) &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  441</span>            partGraph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[currentPartIndex].push_back(nextPartIndex);</div>
<div class="line"><span class="lineno">  442</span>            partGraph.<a class="code hl_variable" href="struct_part_graph.html#a5f328f00e2022805dfc1eb80ae8ef3f4">adjacencyList</a>[nextPartIndex].push_back(currentPartIndex);</div>
<div class="line"><span class="lineno">  443</span>        }</div>
<div class="line"><span class="lineno">  444</span>    }</div>
<div class="line"><span class="lineno">  445</span> </div>
<div class="line"><span class="lineno">  446</span>    std::cout &lt;&lt; <span class="stringliteral">&quot;splitMesh function completed. Total parts created: &quot;</span> &lt;&lt; partGraph.<a class="code hl_variable" href="struct_part_graph.html#a97283d22bde3230f8cb4b56f053e9510">parts</a>.size() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  447</span>    <span class="keywordflow">return</span> partGraph;</div>
<div class="line"><span class="lineno">  448</span>}</div>
<div class="ttc" id="aclass_graph_mesh_html_abc53123269ec018b2484e359590ca186"><div class="ttname"><a href="#abc53123269ec018b2484e359590ca186">GraphMesh::getEdgeLength</a></div><div class="ttdeci">double getEdgeLength(int edgeId)</div><div class="ttdoc">Gets length of an edge.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:1189</div></div>
<div class="ttc" id="aclass_graph_mesh_html_ad522efd135fa5daecba00eeeaffcb940"><div class="ttname"><a href="#ad522efd135fa5daecba00eeeaffcb940">GraphMesh::determineSplineOrientation</a></div><div class="ttdeci">int determineSplineOrientation(int splineTag, int sharedLineTag)</div><div class="ttdoc">Determines spline orientation relative to node.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:488</div></div>
<div class="ttc" id="aclass_graph_mesh_html_ae6d37ebae2f4bee3913773d9951aed6d"><div class="ttname"><a href="#ae6d37ebae2f4bee3913773d9951aed6d">GraphMesh::findSharedLine</a></div><div class="ttdeci">int findSharedLine(const std::vector&lt; int &gt; &amp;nodeBoundaryTags, const std::vector&lt; int &gt; &amp;edgeBoundaryTags)</div><div class="ttdoc">Finds shared boundary line between an edge an a node.</div><div class="ttdef"><b>Definition</b> graph_mesh.cc:451</div></div>
<div class="ttc" id="astruct_edge2_d_html"><div class="ttname"><a href="struct_edge2_d.html">Edge2D</a></div><div class="ttdoc">2D edge in mesh graph</div><div class="ttdef"><b>Definition</b> graph_mesh.h:137</div></div>
<div class="ttc" id="astruct_mesh_part_html_a15042c0e341914adb421b20083021581"><div class="ttname"><a href="struct_mesh_part.html#a15042c0e341914adb421b20083021581">MeshPart::subId</a></div><div class="ttdeci">int subId</div><div class="ttdoc">Subdivision identifier (used for multiple edge parts on the same edge)</div><div class="ttdef"><b>Definition</b> graph_mesh.h:164</div></div>
<div class="ttc" id="astruct_mesh_part_html_a4317bcc3eaf4de407f7599aa254c3a3ea72387ca6280f8711f81167ccbda14a29"><div class="ttname"><a href="struct_mesh_part.html#a4317bcc3eaf4de407f7599aa254c3a3ea72387ca6280f8711f81167ccbda14a29">MeshPart::EDGE</a></div><div class="ttdeci">@ EDGE</div><div class="ttdef"><b>Definition</b> graph_mesh.h:162</div></div>
<div class="ttc" id="astruct_mesh_part_html_a4d5ecb98bb14ec056d0d76d5fc19791c"><div class="ttname"><a href="struct_mesh_part.html#a4d5ecb98bb14ec056d0d76d5fc19791c">MeshPart::surfaceTags</a></div><div class="ttdeci">std::vector&lt; int &gt; surfaceTags</div><div class="ttdoc">Associated surface tags.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:165</div></div>
<div class="ttc" id="astruct_mesh_part_html_a4f9192c1108599f8002dd34083b91579"><div class="ttname"><a href="struct_mesh_part.html#a4f9192c1108599f8002dd34083b91579">MeshPart::connectedEdges</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; int, std::pair&lt; double, double &gt; &gt; &gt; connectedEdges</div><div class="ttdoc">Edge ID, (start, end) portions.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:167</div></div>
<div class="ttc" id="astruct_mesh_part_html_a505deab73f81e7501ec5f97f9ce18082"><div class="ttname"><a href="struct_mesh_part.html#a505deab73f81e7501ec5f97f9ce18082">MeshPart::connectedEdgeTags</a></div><div class="ttdeci">std::vector&lt; int &gt; connectedEdgeTags</div><div class="ttdoc">Edge tags (for NODE type only)</div><div class="ttdef"><b>Definition</b> graph_mesh.h:168</div></div>
<div class="ttc" id="astruct_mesh_part_html_a5e1f7ab7eae3db3a56db6f0b10330b2a"><div class="ttname"><a href="struct_mesh_part.html#a5e1f7ab7eae3db3a56db6f0b10330b2a">MeshPart::id</a></div><div class="ttdeci">int id</div><div class="ttdoc">Primary identifier (Node or Edge ID)</div><div class="ttdef"><b>Definition</b> graph_mesh.h:163</div></div>
<div class="ttc" id="astruct_mesh_part_html_ac0421bafeb7f7a3f7cc7d53e9c883ef0"><div class="ttname"><a href="struct_mesh_part.html#ac0421bafeb7f7a3f7cc7d53e9c883ef0">MeshPart::boundaryTags</a></div><div class="ttdeci">std::vector&lt; int &gt; boundaryTags</div><div class="ttdoc">Associated boundary tags.</div><div class="ttdef"><b>Definition</b> graph_mesh.h:166</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad5cec0dcae353a95b3692a871ecf4cd1" name="ad5cec0dcae353a95b3692a871ecf4cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cec0dcae353a95b3692a871ecf4cd1">&#9670;&#160;</a></span>boundaries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, <a class="el" href="struct_boundary_line.html">BoundaryLine</a>&gt; GraphMesh::boundaries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map of boundary IDs to boundary lines. </p>

</div>
</div>
<a id="a08fddd298e36dc790c25f569828df0e1" name="a08fddd298e36dc790c25f569828df0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fddd298e36dc790c25f569828df0e1">&#9670;&#160;</a></span>edges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, <a class="el" href="struct_edge2_d.html">Edge2D</a>&gt; GraphMesh::edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map of edge IDs to edges. </p>

</div>
</div>
<a id="aa3f6281813689df21df1e3da33988b97" name="aa3f6281813689df21df1e3da33988b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f6281813689df21df1e3da33988b97">&#9670;&#160;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, <a class="el" href="struct_node2_d.html">Node2D</a>&gt; GraphMesh::nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map of node IDs to nodes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="graph__mesh_8h_source.html">graph_mesh.h</a></li>
<li>src/<a class="el" href="graph__mesh_8cc.html">graph_mesh.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
