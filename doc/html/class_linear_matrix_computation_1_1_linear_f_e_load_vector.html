<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Semester Project Liam Curtis: LinearMatrixComputation::LinearFELoadVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Semester Project Liam Curtis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_linear_matrix_computation.html">LinearMatrixComputation</a></li><li class="navelem"><a class="el" href="class_linear_matrix_computation_1_1_linear_f_e_load_vector.html">LinearFELoadVector</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_linear_matrix_computation_1_1_linear_f_e_load_vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LinearMatrixComputation::LinearFELoadVector Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for computing linear finite element load vectors.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="linear__matrix__computation_8h_source.html">linear_matrix_computation.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b015479f5ae7bac7c9d07878fbb2bf8" id="r_a4b015479f5ae7bac7c9d07878fbb2bf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b015479f5ae7bac7c9d07878fbb2bf8">LinearFELoadVector</a> ()=delete</td></tr>
<tr class="memdesc:a4b015479f5ae7bac7c9d07878fbb2bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor disabled - boundary flags required.  <br /></td></tr>
<tr class="separator:a4b015479f5ae7bac7c9d07878fbb2bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc27e0ec455f3082cf928acf9df195a" id="r_aadc27e0ec455f3082cf928acf9df195a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadc27e0ec455f3082cf928acf9df195a">LinearFELoadVector</a> (lf::mesh::utils::CodimMeshDataSet&lt; bool &gt; <a class="el" href="#ac92c596904e88db8e8b51d660de8e36e">bd_flags</a>)</td></tr>
<tr class="memdesc:aadc27e0ec455f3082cf928acf9df195a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs with boundary flags only (zero loads)  <br /></td></tr>
<tr class="separator:aadc27e0ec455f3082cf928acf9df195a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283e9b79ea8b06b52d509dd8173b8610" id="r_a283e9b79ea8b06b52d509dd8173b8610"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a283e9b79ea8b06b52d509dd8173b8610">LinearFELoadVector</a> (lf::mesh::utils::CodimMeshDataSet&lt; bool &gt; <a class="el" href="#ac92c596904e88db8e8b51d660de8e36e">bd_flags</a>, std::function&lt; Eigen::Vector2d(const Eigen::Vector2d &amp;)&gt; traction)</td></tr>
<tr class="memdesc:a283e9b79ea8b06b52d509dd8173b8610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs with boundary flags and surface traction.  <br /></td></tr>
<tr class="separator:a283e9b79ea8b06b52d509dd8173b8610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9915e9eb659ef42e060f3e02a26855ef" id="r_a9915e9eb659ef42e060f3e02a26855ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9915e9eb659ef42e060f3e02a26855ef">LinearFELoadVector</a> (lf::mesh::utils::CodimMeshDataSet&lt; bool &gt; <a class="el" href="#ac92c596904e88db8e8b51d660de8e36e">bd_flags</a>, std::function&lt; Eigen::Vector2d(const Eigen::Vector2d &amp;)&gt; traction, std::function&lt; Eigen::Vector2d(const Eigen::Vector2d &amp;)&gt; body)</td></tr>
<tr class="memdesc:a9915e9eb659ef42e060f3e02a26855ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs with boundary flags, surface traction, and body forces.  <br /></td></tr>
<tr class="separator:a9915e9eb659ef42e060f3e02a26855ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028590f9f71664c3c23faee964bb90b4" id="r_a028590f9f71664c3c23faee964bb90b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028590f9f71664c3c23faee964bb90b4">isActive</a> (const lf::mesh::Entity &amp;entity)</td></tr>
<tr class="memdesc:a028590f9f71664c3c23faee964bb90b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if entity should be processed.  <br /></td></tr>
<tr class="separator:a028590f9f71664c3c23faee964bb90b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011475d7744e97bc4040ccc10faf5381" id="r_a011475d7744e97bc4040ccc10faf5381"><td class="memItemLeft" align="right" valign="top">Eigen::Vector&lt; double, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a011475d7744e97bc4040ccc10faf5381">Eval</a> (const lf::mesh::Entity &amp;entity)</td></tr>
<tr class="memdesc:a011475d7744e97bc4040ccc10faf5381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes load vector contribution for entity.  <br /></td></tr>
<tr class="separator:a011475d7744e97bc4040ccc10faf5381"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac92c596904e88db8e8b51d660de8e36e" id="r_ac92c596904e88db8e8b51d660de8e36e"><td class="memItemLeft" align="right" valign="top">lf::mesh::utils::CodimMeshDataSet&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac92c596904e88db8e8b51d660de8e36e">bd_flags</a></td></tr>
<tr class="memdesc:ac92c596904e88db8e8b51d660de8e36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boundary flags.  <br /></td></tr>
<tr class="separator:ac92c596904e88db8e8b51d660de8e36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9c8850fd94c5d643394baacafefd2d" id="r_abb9c8850fd94c5d643394baacafefd2d"><td class="memItemLeft" align="right" valign="top">std::function&lt; Eigen::Vector2d(const Eigen::Vector2d &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb9c8850fd94c5d643394baacafefd2d">traction_</a></td></tr>
<tr class="memdesc:abb9c8850fd94c5d643394baacafefd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface traction function.  <br /></td></tr>
<tr class="separator:abb9c8850fd94c5d643394baacafefd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6ef7c20f938fb667089b7b4f8df2df" id="r_a7c6ef7c20f938fb667089b7b4f8df2df"><td class="memItemLeft" align="right" valign="top">std::function&lt; Eigen::Vector2d(const Eigen::Vector2d &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c6ef7c20f938fb667089b7b4f8df2df">body_f</a></td></tr>
<tr class="memdesc:a7c6ef7c20f938fb667089b7b4f8df2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Body force function.  <br /></td></tr>
<tr class="separator:a7c6ef7c20f938fb667089b7b4f8df2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for computing linear finite element load vectors. </p>
<p>Handles computation of load vectors including body forces and surface tractions. This was added for completeness in the case that traction and body forces were to be implemented, but is not used within the implementation </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b015479f5ae7bac7c9d07878fbb2bf8" name="a4b015479f5ae7bac7c9d07878fbb2bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b015479f5ae7bac7c9d07878fbb2bf8">&#9670;&#160;</a></span>LinearFELoadVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LinearMatrixComputation::LinearFELoadVector::LinearFELoadVector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor disabled - boundary flags required. </p>

</div>
</div>
<a id="aadc27e0ec455f3082cf928acf9df195a" name="aadc27e0ec455f3082cf928acf9df195a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc27e0ec455f3082cf928acf9df195a">&#9670;&#160;</a></span>LinearFELoadVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LinearMatrixComputation::LinearFELoadVector::LinearFELoadVector </td>
          <td>(</td>
          <td class="paramtype">lf::mesh::utils::CodimMeshDataSet&lt; bool &gt;</td>          <td class="paramname"><span class="paramname"><em>bd_flags</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs with boundary flags only (zero loads) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_flags</td><td>Boundary condition flags </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  127</span>        : <a class="code hl_variable" href="#ac92c596904e88db8e8b51d660de8e36e">bd_flags</a>(std::move(<a class="code hl_variable" href="#ac92c596904e88db8e8b51d660de8e36e">bd_flags</a>)), <a class="code hl_variable" href="#abb9c8850fd94c5d643394baacafefd2d">traction_</a>{}, <a class="code hl_variable" href="#a7c6ef7c20f938fb667089b7b4f8df2df">body_f</a>{} {}</div>
<div class="ttc" id="aclass_linear_matrix_computation_1_1_linear_f_e_load_vector_html_a7c6ef7c20f938fb667089b7b4f8df2df"><div class="ttname"><a href="#a7c6ef7c20f938fb667089b7b4f8df2df">LinearMatrixComputation::LinearFELoadVector::body_f</a></div><div class="ttdeci">std::function&lt; Eigen::Vector2d(const Eigen::Vector2d &amp;)&gt; body_f</div><div class="ttdoc">Body force function.</div><div class="ttdef"><b>Definition</b> linear_matrix_computation.h:113</div></div>
<div class="ttc" id="aclass_linear_matrix_computation_1_1_linear_f_e_load_vector_html_abb9c8850fd94c5d643394baacafefd2d"><div class="ttname"><a href="#abb9c8850fd94c5d643394baacafefd2d">LinearMatrixComputation::LinearFELoadVector::traction_</a></div><div class="ttdeci">std::function&lt; Eigen::Vector2d(const Eigen::Vector2d &amp;)&gt; traction_</div><div class="ttdoc">Surface traction function.</div><div class="ttdef"><b>Definition</b> linear_matrix_computation.h:112</div></div>
<div class="ttc" id="aclass_linear_matrix_computation_1_1_linear_f_e_load_vector_html_ac92c596904e88db8e8b51d660de8e36e"><div class="ttname"><a href="#ac92c596904e88db8e8b51d660de8e36e">LinearMatrixComputation::LinearFELoadVector::bd_flags</a></div><div class="ttdeci">lf::mesh::utils::CodimMeshDataSet&lt; bool &gt; bd_flags</div><div class="ttdoc">Boundary flags.</div><div class="ttdef"><b>Definition</b> linear_matrix_computation.h:111</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a283e9b79ea8b06b52d509dd8173b8610" name="a283e9b79ea8b06b52d509dd8173b8610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283e9b79ea8b06b52d509dd8173b8610">&#9670;&#160;</a></span>LinearFELoadVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LinearMatrixComputation::LinearFELoadVector::LinearFELoadVector </td>
          <td>(</td>
          <td class="paramtype">lf::mesh::utils::CodimMeshDataSet&lt; bool &gt;</td>          <td class="paramname"><span class="paramname"><em>bd_flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Vector2d(const Eigen::Vector2d &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>traction</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs with boundary flags and surface traction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_flags</td><td>Boundary condition flags </td></tr>
    <tr><td class="paramname">traction</td><td>Surface traction function </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  136</span>        : <a class="code hl_variable" href="#ac92c596904e88db8e8b51d660de8e36e">bd_flags</a>(std::move(<a class="code hl_variable" href="#ac92c596904e88db8e8b51d660de8e36e">bd_flags</a>)), <a class="code hl_variable" href="#abb9c8850fd94c5d643394baacafefd2d">traction_</a>(std::move(traction)), <a class="code hl_variable" href="#a7c6ef7c20f938fb667089b7b4f8df2df">body_f</a>{} {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9915e9eb659ef42e060f3e02a26855ef" name="a9915e9eb659ef42e060f3e02a26855ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9915e9eb659ef42e060f3e02a26855ef">&#9670;&#160;</a></span>LinearFELoadVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LinearMatrixComputation::LinearFELoadVector::LinearFELoadVector </td>
          <td>(</td>
          <td class="paramtype">lf::mesh::utils::CodimMeshDataSet&lt; bool &gt;</td>          <td class="paramname"><span class="paramname"><em>bd_flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Vector2d(const Eigen::Vector2d &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>traction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Vector2d(const Eigen::Vector2d &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs with boundary flags, surface traction, and body forces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_flags</td><td>Boundary condition flags </td></tr>
    <tr><td class="paramname">traction</td><td>Surface traction function </td></tr>
    <tr><td class="paramname">body</td><td>Body force function </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  147</span>        : <a class="code hl_variable" href="#ac92c596904e88db8e8b51d660de8e36e">bd_flags</a>(std::move(<a class="code hl_variable" href="#ac92c596904e88db8e8b51d660de8e36e">bd_flags</a>)), <a class="code hl_variable" href="#abb9c8850fd94c5d643394baacafefd2d">traction_</a>(std::move(traction)), <a class="code hl_variable" href="#a7c6ef7c20f938fb667089b7b4f8df2df">body_f</a>(std::move(body)) {}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a011475d7744e97bc4040ccc10faf5381" name="a011475d7744e97bc4040ccc10faf5381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011475d7744e97bc4040ccc10faf5381">&#9670;&#160;</a></span>Eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector&lt; double, 8 &gt; LinearMatrixComputation::LinearFELoadVector::Eval </td>
          <td>(</td>
          <td class="paramtype">const lf::mesh::Entity &amp;</td>          <td class="paramname"><span class="paramname"><em>entity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes load vector contribution for entity. </p>
<p>Similar to the Eval function for <a class="el" href="class_linear_matrix_computation_1_1_linear_f_e_element_matrix.html">LinearFEElementMatrix</a>, the vector is of size 8 for quadrilateral elements. For trianglular cells, the last 2 entries will simply be zero </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Mesh entity (element or edge) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>8-dimensional local load vector </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  102</span>                                                                              {</div>
<div class="line"><span class="lineno">  103</span> </div>
<div class="line"><span class="lineno">  104</span>        <span class="keyword">const</span> lf::base::RefEl ref_el {entity.RefEl()};</div>
<div class="line"><span class="lineno">  105</span>        <span class="keyword">const</span> lf::geometry::Geometry *geo_ptr {entity.Geometry()};</div>
<div class="line"><span class="lineno">  106</span>        <span class="comment">//auto vertices {geo_ptr-&gt;Global(ref_el.NodeCoords())};</span></div>
<div class="line"><span class="lineno">  107</span>        Eigen::Vector&lt;double, 8&gt; elem_vec;</div>
<div class="line"><span class="lineno">  108</span>        elem_vec.setZero();</div>
<div class="line"><span class="lineno">  109</span> </div>
<div class="line"><span class="lineno">  110</span>        <span class="comment">//Due to the implementation of isActive, we know that if the entity is a triangle or quadrilateral, that body_f</span></div>
<div class="line"><span class="lineno">  111</span>        <span class="comment">//is implemented, so we can safely use the function</span></div>
<div class="line"><span class="lineno">  112</span> </div>
<div class="line"><span class="lineno">  113</span>        <span class="comment">//If the entity is an edge, since isActive allowed us to use this Eval, we assume traction_ is well implemented</span></div>
<div class="line"><span class="lineno">  114</span> </div>
<div class="line"><span class="lineno">  115</span>        <span class="comment">//If there were no traction in our problem, we expect bd_flags to always return false, hence Eval not to be used</span></div>
<div class="line"><span class="lineno">  116</span>        <span class="comment">//with an invalid traction_ function</span></div>
<div class="line"><span class="lineno">  117</span> </div>
<div class="line"><span class="lineno">  118</span>        <span class="keywordflow">switch</span>(ref_el) {</div>
<div class="line"><span class="lineno">  119</span>            <span class="comment">//For a segment, I only need to evaluate the traction integral, where I approximate the traction function numerically</span></div>
<div class="line"><span class="lineno">  120</span>            <span class="keywordflow">case</span> lf::base::RefEl::kSegment(): {</div>
<div class="line"><span class="lineno">  121</span> </div>
<div class="line"><span class="lineno">  122</span>                <span class="keyword">auto</span> nodes_of_edge = entity.SubEntities(1);</div>
<div class="line"><span class="lineno">  123</span>                <span class="keyword">auto</span> n0_xy = nodes_of_edge[0]-&gt;Geometry()-&gt;Global(nodes_of_edge[0]-&gt;RefEl().NodeCoords());</div>
<div class="line"><span class="lineno">  124</span>                <span class="keyword">auto</span> n1_xy = nodes_of_edge[1]-&gt;Geometry()-&gt;Global(nodes_of_edge[1]-&gt;RefEl().NodeCoords());</div>
<div class="line"><span class="lineno">  125</span>                <span class="keywordtype">double</span> edge_length = std::sqrt((n0_xy(0) - n1_xy(0)) * (n0_xy(0) - n1_xy(0)) +</div>
<div class="line"><span class="lineno">  126</span>                        (n0_xy(1) - n1_xy(1)) * (n0_xy(1) - n1_xy(1)));</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span>                Eigen::Vector2d t0_xy = traction_(n0_xy);</div>
<div class="line"><span class="lineno">  129</span>                Eigen::Vector2d t1_xy = traction_(n1_xy);</div>
<div class="line"><span class="lineno">  130</span> </div>
<div class="line"><span class="lineno">  131</span>                elem_vec(0) += (edge_length / 6) * (2 * t0_xy(0) + t1_xy(0));</div>
<div class="line"><span class="lineno">  132</span>                elem_vec(1) += (edge_length / 6) * (2 * t0_xy(1) + t1_xy(1));</div>
<div class="line"><span class="lineno">  133</span>                elem_vec(2) += (edge_length / 6) * (t0_xy(0) + 2 * t1_xy(0));</div>
<div class="line"><span class="lineno">  134</span>                elem_vec(3) += (edge_length / 6) * (t0_xy(1) + 2 * t1_xy(1));</div>
<div class="line"><span class="lineno">  135</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  136</span>            }</div>
<div class="line"><span class="lineno">  137</span> </div>
<div class="line"><span class="lineno">  138</span>            <span class="comment">//For a triangle, I need to evaluate the body force integral, which I approximate by a linear function in the fe_space</span></div>
<div class="line"><span class="lineno">  139</span>            <span class="comment">//with values equal to the function at the nodes of the cell</span></div>
<div class="line"><span class="lineno">  140</span>            <span class="keywordflow">case</span> lf::base::RefEl::kTria(): {</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span>                <span class="keyword">const</span> <span class="keywordtype">double</span> area = lf::geometry::Volume(*(entity.Geometry()));</div>
<div class="line"><span class="lineno">  143</span>                <span class="keyword">auto</span> nodes_of_tri = entity.SubEntities(2);</div>
<div class="line"><span class="lineno">  144</span>                <span class="keyword">auto</span> n0_xy = nodes_of_tri[0]-&gt;Geometry()-&gt;Global(nodes_of_tri[0]-&gt;RefEl().NodeCoords());</div>
<div class="line"><span class="lineno">  145</span>                <span class="keyword">auto</span> n1_xy = nodes_of_tri[1]-&gt;Geometry()-&gt;Global(nodes_of_tri[1]-&gt;RefEl().NodeCoords());</div>
<div class="line"><span class="lineno">  146</span>                <span class="keyword">auto</span> n2_xy = nodes_of_tri[2]-&gt;Geometry()-&gt;Global(nodes_of_tri[2]-&gt;RefEl().NodeCoords());</div>
<div class="line"><span class="lineno">  147</span> </div>
<div class="line"><span class="lineno">  148</span>                Eigen::Vector2d b0_xy = body_f(n0_xy);</div>
<div class="line"><span class="lineno">  149</span>                Eigen::Vector2d b1_xy = body_f(n1_xy);</div>
<div class="line"><span class="lineno">  150</span>                Eigen::Vector2d b2_xy = body_f(n2_xy);</div>
<div class="line"><span class="lineno">  151</span> </div>
<div class="line"><span class="lineno">  152</span>                elem_vec(0) += (area / 12) * (2 * b0_xy(0) + b1_xy(0) + b2_xy(0));</div>
<div class="line"><span class="lineno">  153</span>                elem_vec(1) += (area / 12) * (2 * b0_xy(1) + b1_xy(1) + b2_xy(1));</div>
<div class="line"><span class="lineno">  154</span>                elem_vec(2) += (area / 12) * (b0_xy(0) + 2 * b1_xy(0) + b2_xy(0));</div>
<div class="line"><span class="lineno">  155</span>                elem_vec(3) += (area / 12) * (b0_xy(1) + 2 * b1_xy(1) + b2_xy(1));</div>
<div class="line"><span class="lineno">  156</span>                elem_vec(4) += (area / 12) * (b0_xy(0) + b1_xy(0) + 2 * b2_xy(0));</div>
<div class="line"><span class="lineno">  157</span>                elem_vec(5) += (area / 12) * (b0_xy(1) + b1_xy(1) + 2 * b2_xy(1));</div>
<div class="line"><span class="lineno">  158</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  159</span>            }</div>
<div class="line"><span class="lineno">  160</span> </div>
<div class="line"><span class="lineno">  161</span>            <span class="comment">//For a quadrilateral, I use the same method where I approximate the body force using the values at the nodes</span></div>
<div class="line"><span class="lineno">  162</span>            <span class="keywordflow">case</span> lf::base::RefEl::kQuad(): {</div>
<div class="line"><span class="lineno">  163</span> </div>
<div class="line"><span class="lineno">  164</span>                lf::uscalfe::FeLagrangeO1Quad&lt;double&gt; element;</div>
<div class="line"><span class="lineno">  165</span>                <span class="comment">//lf::quad::QuadRule qr = lf::quad::make_QuadQR_P4O2();</span></div>
<div class="line"><span class="lineno">  166</span>                lf::quad::QuadRule qr = lf::quad::make_QuadQR_P4O4();</div>
<div class="line"><span class="lineno">  167</span> </div>
<div class="line"><span class="lineno">  168</span>                <span class="comment">//Integration elements will give the 4 determinants of the Jacobian, one for each quadrature point</span></div>
<div class="line"><span class="lineno">  169</span>                <span class="keyword">auto</span> determinants = geo_ptr-&gt;IntegrationElement(qr.Points());</div>
<div class="line"><span class="lineno">  170</span> </div>
<div class="line"><span class="lineno">  171</span>                <span class="comment">//This vector will hold the values of the basis functions at the quadrature points in the loop</span></div>
<div class="line"><span class="lineno">  172</span>                <span class="comment">//It should have shape 4x4 (for 4 shape functions and 4 points to evaluate them)</span></div>
<div class="line"><span class="lineno">  173</span>                <span class="keyword">auto</span> refVals = element.EvalReferenceShapeFunctions(qr.Points());</div>
<div class="line"><span class="lineno">  174</span> </div>
<div class="line"><span class="lineno">  175</span>                <span class="comment">//This vector will be reinitialized at every quadrature point, and is used to &quot;reshape&quot; refVals</span></div>
<div class="line"><span class="lineno">  176</span>                Eigen::Vector&lt;double, 8&gt; basis;</div>
<div class="line"><span class="lineno">  177</span>                <span class="keyword">auto</span> global_coords = geo_ptr-&gt;Global(qr.Points());</div>
<div class="line"><span class="lineno">  178</span> </div>
<div class="line"><span class="lineno">  179</span>                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; qr.NumPoints(); ++i) {</div>
<div class="line"><span class="lineno">  180</span> </div>
<div class="line"><span class="lineno">  181</span>                    <span class="comment">//Calculate the value of the body force at this quadrature point, using global coordinates</span></div>
<div class="line"><span class="lineno">  182</span>                    Eigen::Vector2d vec = body_f(global_coords.block&lt;2, 1&gt;(0,i));</div>
<div class="line"><span class="lineno">  183</span> </div>
<div class="line"><span class="lineno">  184</span>                    <span class="comment">//Initialize the value of the basis vector times the body force, staggered</span></div>
<div class="line"><span class="lineno">  185</span>                    basis &lt;&lt; vec(0) * refVals(i, 0), vec(1) * refVals(i, 0),</div>
<div class="line"><span class="lineno">  186</span>                     vec(0) * refVals(i, 1), vec(1) * refVals(i, 1),</div>
<div class="line"><span class="lineno">  187</span>                    vec(0) * refVals(i, 2), vec(1) * refVals(i, 2),</div>
<div class="line"><span class="lineno">  188</span>                    vec(0) * refVals(i, 3), vec(1) * refVals(i, 3);</div>
<div class="line"><span class="lineno">  189</span> </div>
<div class="line"><span class="lineno">  190</span>                    <span class="comment">//Add values to elem_vec for this quadrature point</span></div>
<div class="line"><span class="lineno">  191</span>                    elem_vec += qr.Weights()[i] * determinants[i] * basis;</div>
<div class="line"><span class="lineno">  192</span>                }</div>
<div class="line"><span class="lineno">  193</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  194</span>            }</div>
<div class="line"><span class="lineno">  195</span>            <span class="keywordflow">default</span>: {</div>
<div class="line"><span class="lineno">  196</span>                LF_ASSERT_MSG(<span class="keyword">false</span>, <span class="stringliteral">&quot;Illegal cell type sent to LinearFELoadVector&quot;</span>);</div>
<div class="line"><span class="lineno">  197</span>            }</div>
<div class="line"><span class="lineno">  198</span>        }</div>
<div class="line"><span class="lineno">  199</span>        <span class="keywordflow">return</span> elem_vec;</div>
<div class="line"><span class="lineno">  200</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a028590f9f71664c3c23faee964bb90b4" name="a028590f9f71664c3c23faee964bb90b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028590f9f71664c3c23faee964bb90b4">&#9670;&#160;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LinearMatrixComputation::LinearFELoadVector::isActive </td>
          <td>(</td>
          <td class="paramtype">const lf::mesh::Entity &amp;</td>          <td class="paramname"><span class="paramname"><em>entity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if entity should be processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Mesh entity to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if entity should be included in computation </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">LFException</td><td>for invalid entity types </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  156</span>                                                   {</div>
<div class="line"><span class="lineno">  157</span>            <span class="keyword">const</span> lf::base::RefEl ref_el (entity.RefEl());</div>
<div class="line"><span class="lineno">  158</span>            <span class="keywordflow">switch</span> (ref_el) {</div>
<div class="line"><span class="lineno">  159</span>                <span class="keywordflow">case</span> lf::base::RefEl::kSegment(): {</div>
<div class="line"><span class="lineno">  160</span>                    <span class="keywordflow">return</span> bd_flags(entity);</div>
<div class="line"><span class="lineno">  161</span>                }</div>
<div class="line"><span class="lineno">  162</span>                <span class="keywordflow">case</span> lf::base::RefEl::kTria(): case lf::base::RefEl::kQuad(): {</div>
<div class="line"><span class="lineno">  163</span>                    <span class="keywordflow">if</span> (!body_f) {</div>
<div class="line"><span class="lineno">  164</span>                        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  165</span>                    }</div>
<div class="line"><span class="lineno">  166</span>                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  167</span>                }</div>
<div class="line"><span class="lineno">  168</span>                <span class="keywordflow">default</span>: {</div>
<div class="line"><span class="lineno">  169</span>                    LF_ASSERT_MSG(<span class="keyword">false</span>, <span class="stringliteral">&quot;Illegal cell type sent to isActive LinearFELoadVector&quot;</span>);</div>
<div class="line"><span class="lineno">  170</span>                }</div>
<div class="line"><span class="lineno">  171</span>            }</div>
<div class="line"><span class="lineno">  172</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac92c596904e88db8e8b51d660de8e36e" name="ac92c596904e88db8e8b51d660de8e36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92c596904e88db8e8b51d660de8e36e">&#9670;&#160;</a></span>bd_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lf::mesh::utils::CodimMeshDataSet&lt;bool&gt; LinearMatrixComputation::LinearFELoadVector::bd_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boundary flags. </p>

</div>
</div>
<a id="a7c6ef7c20f938fb667089b7b4f8df2df" name="a7c6ef7c20f938fb667089b7b4f8df2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6ef7c20f938fb667089b7b4f8df2df">&#9670;&#160;</a></span>body_f</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;Eigen::Vector2d (const Eigen::Vector2d &amp;)&gt; LinearMatrixComputation::LinearFELoadVector::body_f</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Body force function. </p>

</div>
</div>
<a id="abb9c8850fd94c5d643394baacafefd2d" name="abb9c8850fd94c5d643394baacafefd2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9c8850fd94c5d643394baacafefd2d">&#9670;&#160;</a></span>traction_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;Eigen::Vector2d (const Eigen::Vector2d &amp;)&gt; LinearMatrixComputation::LinearFELoadVector::traction_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Surface traction function. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="linear__matrix__computation_8h_source.html">linear_matrix_computation.h</a></li>
<li>src/<a class="el" href="linear__matrix__computation_8cc.html">linear_matrix_computation.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
