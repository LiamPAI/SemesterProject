<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Semester Project Liam Curtis: LinearElasticityAssembler Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Semester Project Liam Curtis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LinearElasticityAssembler Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for linear elasticity assembly operations.  
<a href="namespaceLinearElasticityAssembler.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adbfe31593abe48a26e05aa1f964cdc70"><td class="memTemplParams" colspan="2">template&lt;typename TMPMATRIX , lf::assemble::EntityMatrixProvider ENTITY_MATRIX_PROVIDER&gt; </td></tr>
<tr class="memitem:adbfe31593abe48a26e05aa1f964cdc70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLinearElasticityAssembler.html#adbfe31593abe48a26e05aa1f964cdc70">AssembleMatrixLocally</a> (lf::base::dim_t codim, const lf::assemble::DofHandler &amp;dof_handler_trial, const lf::assemble::DofHandler &amp;dof_handler_test, ENTITY_MATRIX_PROVIDER &amp;entity_matrix_provider, TMPMATRIX &amp;matrix)</td></tr>
<tr class="memdesc:adbfe31593abe48a26e05aa1f964cdc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembles global stiffness matrix from local contributions.  <a href="namespaceLinearElasticityAssembler.html#adbfe31593abe48a26e05aa1f964cdc70">More...</a><br /></td></tr>
<tr class="separator:adbfe31593abe48a26e05aa1f964cdc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb264acfd6a564d3adffebfe6e74e790"><td class="memTemplParams" colspan="2">template&lt;typename VECTOR , lf::assemble::EntityVectorProvider ENTITY_VECTOR_PROVIDER&gt; </td></tr>
<tr class="memitem:adb264acfd6a564d3adffebfe6e74e790"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLinearElasticityAssembler.html#adb264acfd6a564d3adffebfe6e74e790">AssembleVectorLocally</a> (lf::base::dim_t codim, const lf::assemble::DofHandler &amp;dof_handler, ENTITY_VECTOR_PROVIDER &amp;entity_vector_provider, VECTOR &amp;resultvector)</td></tr>
<tr class="memdesc:adb264acfd6a564d3adffebfe6e74e790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembles global load vector from local contributions.  <a href="namespaceLinearElasticityAssembler.html#adb264acfd6a564d3adffebfe6e74e790">More...</a><br /></td></tr>
<tr class="separator:adb264acfd6a564d3adffebfe6e74e790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2794b9828d5b86a2b6545568e9f10a5"><td class="memTemplParams" colspan="2">template&lt;lf::assemble::EntityMatrixProvider ENTITY_MATRIX_PROVIDER&gt; </td></tr>
<tr class="memitem:ad2794b9828d5b86a2b6545568e9f10a5"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLinearElasticityAssembler.html#ad2794b9828d5b86a2b6545568e9f10a5">stressStrainLoader</a> (const std::shared_ptr&lt; lf::mesh::Mesh &gt; &amp;mesh_ptr, Eigen::VectorXd &amp;disp_vec, ENTITY_MATRIX_PROVIDER &amp;assembler, int degree)</td></tr>
<tr class="memdesc:ad2794b9828d5b86a2b6545568e9f10a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes stress and strain fields from displacement solution.  <a href="namespaceLinearElasticityAssembler.html#ad2794b9828d5b86a2b6545568e9f10a5">More...</a><br /></td></tr>
<tr class="separator:ad2794b9828d5b86a2b6545568e9f10a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59969ea728ac197847183f3a73760ed"><td class="memTemplParams" colspan="2">template&lt;lf::assemble::EntityMatrixProvider ENTITY_MATRIX_PROVIDER&gt; </td></tr>
<tr class="memitem:aa59969ea728ac197847183f3a73760ed"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLinearElasticityAssembler.html#aa59969ea728ac197847183f3a73760ed">energyCalculator</a> (const std::shared_ptr&lt; lf::mesh::Mesh &gt; &amp;mesh_ptr, Eigen::VectorXd &amp;disp_vec, ENTITY_MATRIX_PROVIDER &amp;assembler, int degree)</td></tr>
<tr class="memdesc:aa59969ea728ac197847183f3a73760ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates total strain energy of the system.  <a href="namespaceLinearElasticityAssembler.html#aa59969ea728ac197847183f3a73760ed">More...</a><br /></td></tr>
<tr class="separator:aa59969ea728ac197847183f3a73760ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for linear elasticity assembly operations. </p>
<p>Provides functions for assembling global Galerkin matrices and vectors for the linear elasticity problem </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="adbfe31593abe48a26e05aa1f964cdc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfe31593abe48a26e05aa1f964cdc70">&#9670;&nbsp;</a></span>AssembleMatrixLocally()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMPMATRIX , lf::assemble::EntityMatrixProvider ENTITY_MATRIX_PROVIDER&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LinearElasticityAssembler::AssembleMatrixLocally </td>
          <td>(</td>
          <td class="paramtype">lf::base::dim_t&#160;</td>
          <td class="paramname"><em>codim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lf::assemble::DofHandler &amp;&#160;</td>
          <td class="paramname"><em>dof_handler_trial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lf::assemble::DofHandler &amp;&#160;</td>
          <td class="paramname"><em>dof_handler_test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ENTITY_MATRIX_PROVIDER &amp;&#160;</td>
          <td class="paramname"><em>entity_matrix_provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMPMATRIX &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assembles global stiffness matrix from local contributions. </p>
<p>This uses the Eval functions of the <a class="el" href="">LinearFEElementMatrix</a> or <a class="el" href="">ParametricFEElementMatrix</a> and uses the local ordering of the shape functions to add to the global Galerkin matrix </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMPMATRIX</td><td>Matrix type for assembly </td></tr>
    <tr><td class="paramname">ENTITY_MATRIX_PROVIDER</td><td>Provider of element matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codim</td><td>Codimension of entities to process </td></tr>
    <tr><td class="paramname">dof_handler_trial</td><td>Trial space DOF handler </td></tr>
    <tr><td class="paramname">dof_handler_test</td><td>Test space DOF handler </td></tr>
    <tr><td class="paramname">entity_matrix_provider</td><td>Provider of element matrices </td></tr>
    <tr><td class="paramname">matrix</td><td>Global matrix to assemble into </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                                   {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160; </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="comment">//Get pointer to underlying mesh</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <span class="keyword">auto</span> mesh = dof_handler_trial.Mesh();</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        LF_ASSERT_MSG(mesh == dof_handler_test.Mesh(), <span class="stringliteral">&quot;Trial and test space must be defined on the same mesh&quot;</span>);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="comment">//Loop over all the entities of the specified codimension</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> lf::mesh::Entity *entity : mesh-&gt;Entities(codim)) {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            <span class="comment">//Only calculate for active cells (should include all cells)</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            <span class="keywordflow">if</span>(entity_matrix_provider.isActive(*entity)) {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                <span class="comment">//Obtain size of element matrix, multiply by 2 due to displacements in x and y</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                <span class="keyword">const</span> lf::assemble::size_type nrows_local = dof_handler_test.NumLocalDofs(*entity) * 2;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                <span class="keyword">const</span> lf::assemble::size_type ncols_local = dof_handler_trial.NumLocalDofs(*entity) * 2;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160; </div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                <span class="comment">//Obtain row and column indices for contributions to global matrix</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                std::span&lt;const lf::assemble::gdof_idx_t&gt; row_idx (dof_handler_test.GlobalDofIndices(*entity));</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                std::span&lt;const lf::assemble::gdof_idx_t&gt; col_idx (dof_handler_trial.GlobalDofIndices(*entity));</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160; </div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                <span class="comment">//Obtain element matrix</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> elem_mat {entity_matrix_provider.Eval(*entity)};</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160; </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                LF_ASSERT_MSG(elem_mat.rows() &gt;= nrows_local, <span class="stringliteral">&quot;nrows mismatch &quot;</span> &lt;&lt; elem_mat.rows() &lt;&lt; <span class="stringliteral">&quot; &lt;-&gt; &quot;</span> &lt;&lt; nrows_local</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                                                &lt;&lt; <span class="stringliteral">&quot;, entity &quot;</span> &lt;&lt; mesh-&gt;Index(*entity));</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                LF_ASSERT_MSG(elem_mat.cols() &gt;= ncols_local, <span class="stringliteral">&quot;ncols mismatch &quot;</span> &lt;&lt; elem_mat.cols() &lt;&lt; <span class="stringliteral">&quot; &lt;-&gt; &quot;</span> &lt;&lt; nrows_local</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                                                &lt;&lt; <span class="stringliteral">&quot;, entity &quot;</span> &lt;&lt; mesh-&gt;Index(*entity));</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160; </div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                <span class="comment">//Loop over all elements of the element matrix</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nrows_local; i++) {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ncols_local; j++) {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160; </div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                        <span class="comment">//We divide by two because there are components in both the x and y direction</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                        <span class="keywordflow">if</span> (i % 2 == 0 and j % 2 == 0) {</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                            matrix.AddToEntry(row_idx[i / 2] * 2, col_idx[j / 2] * 2, elem_mat(i, j));</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                        }</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i % 2 == 0) {</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                            matrix.AddToEntry(row_idx[i / 2] * 2, col_idx[j / 2] * 2 + 1, elem_mat(i, j));</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                        }</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j % 2 == 0) {</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                            matrix.AddToEntry(row_idx[i / 2] * 2 + 1, col_idx[j / 2] * 2, elem_mat(i, j));</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                        }</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                        <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                            matrix.AddToEntry(row_idx[i / 2] * 2 + 1, col_idx[j / 2] * 2 + 1, elem_mat(i, j));</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                        }</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                    }</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                }</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            }</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        }</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adb264acfd6a564d3adffebfe6e74e790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb264acfd6a564d3adffebfe6e74e790">&#9670;&nbsp;</a></span>AssembleVectorLocally()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VECTOR , lf::assemble::EntityVectorProvider ENTITY_VECTOR_PROVIDER&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LinearElasticityAssembler::AssembleVectorLocally </td>
          <td>(</td>
          <td class="paramtype">lf::base::dim_t&#160;</td>
          <td class="paramname"><em>codim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lf::assemble::DofHandler &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ENTITY_VECTOR_PROVIDER &amp;&#160;</td>
          <td class="paramname"><em>entity_vector_provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>resultvector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assembles global load vector from local contributions. </p>
<p>This uses the Eval functions of the <a class="el" href="">LinearFELoadVector</a> or <a class="el" href="">ParametricFELoadVector</a> and uses the local ordering of the shape functions to add to the global load vector. Note that similar to these classes, this was added for completely in the case where traction conditions or body forces are added, but ended up not being used in the implementation </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VECTOR</td><td>Vector type for assembly </td></tr>
    <tr><td class="paramname">ENTITY_VECTOR_PROVIDER</td><td>Provider of element vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codim</td><td>Codimension of entities to process </td></tr>
    <tr><td class="paramname">dof_handler</td><td>DOF handler </td></tr>
    <tr><td class="paramname">entity_vector_provider</td><td>Provider of element vectors </td></tr>
    <tr><td class="paramname">resultvector</td><td>Global vector to assemble into </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                                                                                                     {</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160; </div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="keyword">auto</span> mesh = dof_handler.Mesh();</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160; </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> lf::mesh::Entity *entity: mesh-&gt;Entities(codim)) {</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160; </div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            <span class="keywordflow">if</span> (entity_vector_provider.isActive(*entity)) {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160; </div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                <span class="keyword">const</span> lf::base::RefEl refEl {entity-&gt;RefEl()};</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160; </div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                <span class="comment">//We multiply by two due to the x and y components of displacement</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                <span class="keyword">const</span> lf::assemble::size_type veclen = dof_handler.NumLocalDofs(*entity) * 2;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160; </div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                <span class="comment">//Obtain global indices for contributions of the entity</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                <span class="keyword">const</span> std::span&lt;const lf::assemble::gdof_idx_t&gt; dof_idx(dof_handler.GlobalDofIndices(*entity));</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160; </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                <span class="comment">//Obtain local vector from entity_vector_provider object</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> elem_vec {entity_vector_provider.Eval(*entity)};</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                LF_ASSERT_MSG(elem_vec.size() &gt;= veclen, <span class="stringliteral">&quot;length mismatch &quot;</span> &lt;&lt; elem_vec.size() &lt;&lt; <span class="stringliteral">&quot; &lt;-&gt; &quot;</span> &lt;&lt; veclen</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                                                 &lt;&lt; <span class="stringliteral">&quot;, entity &quot;</span> &lt;&lt; mesh-&gt;Index(*entity));</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160; </div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                <span class="comment">//Assembly loop, needs to be different if the entity is a cell or edge</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; veclen; i++) {</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                    <span class="comment">// We use the same method as in AssembleMatrixLocally, due to the presence of both x and y displacements</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                    <span class="keywordflow">if</span> (i % 2 == 0) {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                        resultvector[dof_idx[i / 2] * 2] += elem_vec[i];</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                        resultvector[dof_idx[i / 2] * 2 + 1] += elem_vec[i];</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                    }</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            }</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        }</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa59969ea728ac197847183f3a73760ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59969ea728ac197847183f3a73760ed">&#9670;&nbsp;</a></span>energyCalculator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;lf::assemble::EntityMatrixProvider ENTITY_MATRIX_PROVIDER&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LinearElasticityAssembler::energyCalculator </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; lf::mesh::Mesh &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>disp_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ENTITY_MATRIX_PROVIDER &amp;&#160;</td>
          <td class="paramname"><em>assembler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates total strain energy of the system. </p>
<p>This uses the energyCalc functions of the <a class="el" href="">LinearFEElementMatrix</a> or <a class="el" href="">ParametricFEElementMatrix</a> and sums over the results of all the cells </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ENTITY_MATRIX_PROVIDER</td><td>Provider of element matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_ptr</td><td>Pointer to mesh </td></tr>
    <tr><td class="paramname">disp_vec</td><td>Global displacement vector </td></tr>
    <tr><td class="paramname">assembler</td><td>Matrix assembler </td></tr>
    <tr><td class="paramname">degree</td><td>FE space degree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total strain energy </dd></dl>
<div class="fragment"><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                                                                                {</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160; </div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        <span class="comment">// Declare the mesh and the dof_handler for future use</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        std::shared_ptr&lt;lf::uscalfe::UniformScalarFESpace&lt;double&gt;&gt; fe_space;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="keywordflow">if</span> (degree == 1){</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            fe_space = std::make_shared&lt;lf::uscalfe::FeSpaceLagrangeO1&lt;double&gt;&gt;(mesh_ptr);</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        }</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;            fe_space = std::make_shared&lt;lf::uscalfe::FeSpaceLagrangeO2&lt;double&gt;&gt;(mesh_ptr);</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        }</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        <span class="keyword">const</span> lf::assemble::DofHandler &amp;dofh {fe_space-&gt;LocGlobMap()};</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        <span class="keyword">auto</span> mesh = dofh.Mesh();</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        <span class="keywordtype">double</span> energy = 0;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160; </div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> lf::mesh::Entity *cell : mesh-&gt;Entities(0)) {</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            energy += assembler.energyCalc(*cell, disp_vec, dofh);</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        }</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160; </div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keywordflow">return</span> energy;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2794b9828d5b86a2b6545568e9f10a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2794b9828d5b86a2b6545568e9f10a5">&#9670;&nbsp;</a></span>stressStrainLoader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;lf::assemble::EntityMatrixProvider ENTITY_MATRIX_PROVIDER&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd&gt; LinearElasticityAssembler::stressStrainLoader </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; lf::mesh::Mesh &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>disp_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ENTITY_MATRIX_PROVIDER &amp;&#160;</td>
          <td class="paramname"><em>assembler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes stress and strain fields from displacement solution. </p>
<p>This uses the stressStrain functions of the <a class="el" href="">LinearFEElementMatrix</a> or <a class="el" href="">ParametricFEElementMatrix</a> classes, and concatenates all the results </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ENTITY_MATRIX_PROVIDER</td><td>Provider of element matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_ptr</td><td>Pointer to mesh </td></tr>
    <tr><td class="paramname">disp_vec</td><td>Global displacement vector </td></tr>
    <tr><td class="paramname">assembler</td><td>Matrix assembler </td></tr>
    <tr><td class="paramname">degree</td><td>FE space degree (1 or 2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of (displacement matrix, node coordinates, stress matrix, strain matrix, quadrature point coordinates) </dd></dl>
<div class="fragment"><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                                                                                                                                {</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160; </div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        <span class="comment">// Declare the mesh and the dof_handler for future use</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        std::shared_ptr&lt;lf::uscalfe::UniformScalarFESpace&lt;double&gt;&gt; fe_space;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keywordflow">if</span> (degree == 1){</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            fe_space = std::make_shared&lt;lf::uscalfe::FeSpaceLagrangeO1&lt;double&gt;&gt;(mesh_ptr);</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        }</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            fe_space = std::make_shared&lt;lf::uscalfe::FeSpaceLagrangeO2&lt;double&gt;&gt;(mesh_ptr);</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        }</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        <span class="keyword">const</span> lf::assemble::DofHandler &amp;dofh {fe_space-&gt;LocGlobMap()};</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        <span class="keyword">const</span> lf::uscalfe::size_type N_dofs {dofh.NumDofs()};</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="keyword">auto</span> mesh = dofh.Mesh();</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="comment">// Build the matrix of node coordinates</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        Eigen::MatrixXd node_coords(2, N_dofs);</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> lf::mesh::Entity *node : mesh-&gt;Entities(2)) {</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            node_coords.block&lt;2, 1&gt;(0, dofh.GlobalDofIndices(*node)[0])</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                    &lt;&lt; node-&gt;Geometry()-&gt;Global(node-&gt;Geometry()-&gt;RefEl().NodeCoords());</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        }</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160; </div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        <span class="comment">// Build the matrix of displacements</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        Eigen::MatrixXd disp_mat(2, N_dofs);</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        disp_mat &lt;&lt; disp_vec.reshaped(2, N_dofs);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160; </div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="comment">// Build the matrix of stresses, strains, and quadrature point coordinates</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        Eigen::Matrix&lt;double, 3, Eigen::Dynamic&gt; stresses;</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        Eigen::Matrix&lt;double, 3, Eigen::Dynamic&gt; strains;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        Eigen::Matrix&lt;double, 2, Eigen::Dynamic&gt; qr_coords;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160; </div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> lf::mesh::Entity *cell : mesh-&gt;Entities(0)) {</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160; </div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="keyword">const</span> lf::base::RefEl ref_el {cell-&gt;RefEl()};</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            <span class="keyword">auto</span> trio = assembler.stressStrain(*cell, disp_vec, dofh);</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160; </div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            <span class="keywordflow">switch</span> (ref_el) {</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160; </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                <span class="comment">// In this case we must expand the matrix by 6 columns to fit the new points</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                <span class="keywordflow">case</span> lf::base::RefEl::kTria() : {</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160; </div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                    <span class="keyword">auto</span> cols = stresses.cols();</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                    stresses.conservativeResize(Eigen::NoChange_t(), cols + 6);</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                    strains.conservativeResize(Eigen::NoChange_t(), cols + 6);</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                    qr_coords.conservativeResize(Eigen::NoChange_t(), cols + 6);</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160; </div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                    stresses.block&lt;3, 6&gt;(0, cols) &lt;&lt; std::get&lt;0&gt;(trio);</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                    strains.block&lt;3, 6&gt;(0, cols) &lt;&lt; std::get&lt;1&gt;(trio);</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                    qr_coords.block&lt;2, 6&gt;(0, cols) &lt;&lt; std::get&lt;2&gt;(trio);</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160; </div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                }</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160; </div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                <span class="comment">// In this case we must expand the matrix by 4 columns to fit the new points</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                <span class="keywordflow">case</span> lf::base::RefEl::kQuad() : {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160; </div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                    <span class="keyword">auto</span> cols = stresses.cols();</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                    stresses.conservativeResize(Eigen::NoChange_t(), cols + 4);</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                    strains.conservativeResize(Eigen::NoChange_t(), cols + 4);</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                    qr_coords.conservativeResize(Eigen::NoChange_t(), cols + 4);</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160; </div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                    stresses.block&lt;3, 4&gt;(0, cols) &lt;&lt; std::get&lt;0&gt;(trio);</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                    strains.block&lt;3, 4&gt;(0, cols) &lt;&lt; std::get&lt;1&gt;(trio);</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                    qr_coords.block&lt;2, 4&gt;(0, cols) &lt;&lt; std::get&lt;2&gt;(trio);</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160; </div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                }</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160; </div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                <span class="keywordflow">default</span>: {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                    LF_ASSERT_MSG(<span class="keyword">false</span>, <span class="stringliteral">&quot;Illegal Entity Type sent to pinnDataLoader&quot;</span>);</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                }</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            }</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        }</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160; </div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="keywordflow">return</span> std::tuple(disp_mat, node_coords, stresses, strains, qr_coords);</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
